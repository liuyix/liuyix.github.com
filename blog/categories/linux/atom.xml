<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | 刘毅同学]]></title>
  <link href="http://liuyix.org/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://liuyix.org/"/>
  <updated>2015-12-17T07:11:19+08:00</updated>
  <id>http://liuyix.org/</id>
  <author>
    <name><![CDATA[liuyix]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Bash Tips]]></title>
    <link href="http://liuyix.org/blog/2014/bash-tips/"/>
    <updated>2014-09-14T16:59:00+08:00</updated>
    <id>http://liuyix.org/blog/2014/bash-tips</id>
    <content type="html"><![CDATA[<h3>Bash 遇到错误就退出</h3>

<p><a href="http://stackoverflow.com/a/4382179">http://stackoverflow.com/a/4382179</a></p>

<p><code>set -e</code></p>

<blockquote><p>If you put set -e in a script, the script will terminate as soon as any command inside it fails (i.e. as soon as any command returns a nonzero status). This doesn&rsquo;t let you write your own message, but often the failing command&rsquo;s own messages are enough.</p>

<p>The advantage of this approach is that it&rsquo;s automatic: you don&rsquo;t run the risk of forgetting to deal with an error case.</p>

<p>Commands whose status is tested by a conditional (such as if, &amp;&amp; or ||) do not terminate the script (otherwise the conditional would be pointless). An idiom for the occasional command whose failure doesn&rsquo;t matter is command-that-may-fail || true. You can also turn set -e off for a part of the script with set +e.</p></blockquote>

<h2>Bash使用数组</h2>

<h3>快速入门</h3>

<p>(Bash For Loop Array: Iterate Through Array Values)[<a href="http://www.cyberciti.biz/faq/bash-for-loop-array/">http://www.cyberciti.biz/faq/bash-for-loop-array/</a>]</p>

<ul>
<li>用括号指定，空格指定就好</li>
<li>遍历： <code>for i in "${var[@]}"</code></li>
</ul>


<h3>深入</h3>

<p>```</p>

<h1>!/bin/bash</h1>

<h1>array-ops.sh: More fun with arrays.</h1>

<p>array=( zero one two three four five )</p>

<h1>Element 0   1   2    3     4    5</h1>

<p>echo ${array[0]}       #  zero
echo ${array:0}        #  zero</p>

<pre><code>                   #  Parameter expansion of first element,
                   #+ starting at position # 0 (1st character).
</code></pre>

<p>echo ${array:1}        #  ero</p>

<pre><code>                   #  Parameter expansion of first element,
                   #+ starting at position # 1 (2nd character).
</code></pre>

<p>echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&rdquo;</p>

<p>echo ${#array[0]}      #  4</p>

<pre><code>                   #  Length of first element of array.
</code></pre>

<p>echo ${#array}         #  4</p>

<pre><code>                   #  Length of first element of array.
                   #  (Alternate notation)
</code></pre>

<p>echo ${#array[1]}      #  3</p>

<pre><code>                   #  Length of second element of array.
                   #  Arrays in Bash have zero-based indexing.
</code></pre>

<p>echo ${#array[*]}      #  6</p>

<pre><code>                   #  Number of elements in array.
</code></pre>

<p>echo ${#array[@]}      #  6</p>

<pre><code>                   #  Number of elements in array.
</code></pre>

<p>echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&rdquo;</p>

<p>array2=( [0]=&ldquo;first element&rdquo; [1]=&ldquo;second element&rdquo; [3]=&ldquo;fourth element&rdquo; )</p>

<h1>^     ^       ^     ^      ^       ^     ^      ^       ^</h1>

<h1>Quoting permits embedding whitespace within individual array elements.</h1>

<p>echo ${array2[0]}      # first element
echo ${array2[1]}      # second element
echo ${array2[2]}      #</p>

<pre><code>                   # Skipped in initialization, and therefore null.
</code></pre>

<p>echo ${array2[3]}      # fourth element
echo ${#array2[0]}     # 13    (length of first element)
echo ${#array2[*]}     # 3     (number of elements in array)</p>

<p>exit
```</p>

<p>(Arrays)[<a href="http://www.tldp.org/LDP/abs/html/arrays.html">http://www.tldp.org/LDP/abs/html/arrays.html</a>]</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Unbuffered IO]]></title>
    <link href="http://liuyix.org/blog/2014/apue-unbuffered-io/"/>
    <updated>2014-01-06T01:09:00+08:00</updated>
    <id>http://liuyix.org/blog/2014/apue-unbuffered-io</id>
    <content type="html"><![CDATA[<h2>Linux无缓冲IO</h2>

<blockquote><p>本文是笔者阅读APUE以及Robert Love的<Linux System Programming Talking Directly to the Kernel and C Library>第二版的Unbuffered IO的总结笔记。</p></blockquote>

<p>5个基本操作：
+ open</p>

<pre><code>+ 参数
+ open的tricky用法：open始终返回的是可用的最小数值，因此可以关闭标准输入、标准输出、stderr再open则返回的数值是可以知道的。
    + 该种方法也是dup2的作用
</code></pre>

<ul>
<li>read

<ul>
<li>read返回值大于0小于参数bufsize的原因</li>
</ul>
</li>
<li>write

<ul>
<li>Unix, Linux的写机制：延迟写，write返回时只代表写入到了<em>缓存</em>中，是否已经写入到设备是未知的。</li>
<li></li>
</ul>
</li>
<li>lseek

<ul>
<li>空洞文件</li>
</ul>
</li>
<li>close</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一种Linux加密解决方案——ubuntu中配置dm-crypt总结]]></title>
    <link href="http://liuyix.org/blog/2013/linux-encryption-solution/"/>
    <updated>2013-11-25T05:31:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/linux-encryption-solution</id>
    <content type="html"><![CDATA[<p>这是最近接触的个人项目中的一部分。</p>

<h2>加密需求</h2>

<p>Linux环境中的程序加密，不可读取，不可拷贝是两大需求。</p>

<ul>
<li>不可读取，指的是在运行Linux时除root用户以外，不能被其他用户读取。</li>
<li>不可拷贝，指的是单独拿出硬盘时，不能读取硬盘中的数据。</li>
</ul>


<h2>不可读取的解决方案</h2>

<p>这个很好解决，只要用户不具有root权限就可以通过设置文件权限，达到不可读取的目的。<br/>
具体来讲：将要加密的数据/程序统一设置为<code>go-rwx</code>即可</p>

<h2>不可拷贝的解决方案</h2>

<p>这个才是本文阐述的重点。由于要防止硬盘被单独拿出挂载读取，因此磁盘或者分区加密加密是必要的。 <br/>
目前ubuntu 12.10以后就已经可以在系统安装时创建加密的LVM分区，采用的是<code>dm-crypt</code></p>

<h3>手动建立luks分区</h3>

<h3>启动时自动挂载加密分区</h3>

<h3>keyfile放置于加密的home目录</h3>

<hr />

<p>通过以上步骤，就可以将需要加密的数据放到加密分区，并在启动时自动挂载，同时将自动挂载应用的key放到加密的Home目录下，进一步防止keyfile的窃取，综合几步就可以完成一定级别的保密。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有趣的fork()]]></title>
    <link href="http://liuyix.org/blog/2012/fork-introduce/"/>
    <updated>2012-02-26T19:56:00+08:00</updated>
    <id>http://liuyix.org/blog/2012/fork-introduce</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[makefile简单入门]]></title>
    <link href="http://liuyix.org/blog/2012/write-simple-makefile/"/>
    <updated>2012-02-20T04:02:00+08:00</updated>
    <id>http://liuyix.org/blog/2012/write-simple-makefile</id>
    <content type="html"><![CDATA[<blockquote><p>在linux上混了这么久，真成混的了，连makefile都没有学习过，惭愧啊～作为makefile的快速入门指南，本文是我个人学习makefile时做的笔，此为第一篇。后续会有更加详细深入的学习总结。</p></blockquote>

<h2>导言</h2>

<p>make程序可以算得上是一个domain specific language，完全是一个完整的脚本语言，make是linux,unix上编译 <strong>等</strong> 工作的标准工具，对于复杂的程序来说，可以智能的、自动化完成复杂的程序编译工作。而需要就是编写一个directive的脚本——makefile告诉编译器和其他工具应该如何编译project。 本篇是陈皓写的“跟我一起写makefile”的第一部分的总结，比较凌乱…</p>

<h2>学习资料</h2>

<ul>
<li>陈皓——“跟我一起写makefile”</li>
<li>how to write a simple makefile<!-- more --></li>
</ul>


<h2>makefile的最基本编写规则</h2>

<pre><code>target : prerequisites
    command
</code></pre>

<p>这个就是makefile最基本的编写规则，后续的讲解以及makefile的更多写法不过是为了进一步简化这个规则的编写。也就是说你只要把这个规则弄懂了，makefile你就会写了，和makefile高手，你差得就是一些技巧和高级用法了。但起码你会写makefile了。</p>

<ul>
<li><p><strong>target</strong> 就是要构建的目标——可以是C/C++的object，可以是目标程序，也可以是一个标签。</p></li>
<li><p><strong>prerequistites</strong> 是构建 <strong>target</strong> 需要的文件。对object来说，它也许是c，c++源文件； <strong>target</strong> 是目标程序，那么它就是object文件（.o文件）</p></li>
<li><p><strong>command</strong> 是将 <strong>prerequistites</strong> 变成 <strong>target</strong> 的方法</p></li>
</ul>


<p>一言以弊之，target是output,prerequisites是输入，command是过程方法。 值得注意的是command必须以一个TAB键作为开始，否则会出现"遗漏分隔符。停止"的错误。</p>

<h3>hello-makefile的makefile</h3>

<p>首先编写一个hello-makefile.c，内容我想就不用我写了吧…之后在存放hello-makefile的目录下创建一个 <em>Makefile</em>文件(注意没有扩展名)。 Makefile内容如下：</p>

<p>```makefile</p>

<pre><code>hello-makefile:hello-makefile.o
    cc -o hello-makefile hello-makefile.o
hello-makefile.o: hello-makefile.c
    cc -o hello-makefile.o hello-makefile.c
clean:
    rm *.o hello-makefile
</code></pre>

<p>```</p>

<h2>TAB键、反斜杠(/)</h2>

<ul>
<li><p>TAB键在makefile中是command开头的分割符，这在前文已有讲述。</p></li>
<li><p>反斜杠（/）用来断行，即一行没有写下或者为了美观而将 <code>command</code> 或者 <code>prerequistites</code> 拆成几行来写。刚学习写makefile时可能会忘掉而出现错误。</p></li>
</ul>


<h2>make不仅仅可以做编译</h2>

<p>target可以是目标文件、二进制程序，也可以是一个label，后面没有prerequisites，可以让makefile如同shellscript一样完成其他工作（备份、打包）。比如说我们经常使用的 <code>make clean</code> 实际上是利用make完成shell脚本一样的工作。</p>

<h2>使用变量，简化书写，减少bug</h2>

<pre><code>objects = main.o kbd.o command.o display.o \
insert.o search.o files.o utils.o
</code></pre>

<p>以后使用时就使用 <strong>$(objects)</strong></p>

<h2>自动推导</h2>

<p><strong>.PHONY</strong> 表示clean是一个伪目标文件</p>

<h2>编写makefile好习惯</h2>

<p>每个makefile中都 <em>应该</em> 定义一个clean命令，用于清空从前的编译产生的文件。</p>
]]></content>
  </entry>
  
</feed>
