<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | 刘毅同学]]></title>
  <link href="http://liuyix.org/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://liuyix.org/"/>
  <updated>2015-12-17T07:11:19+08:00</updated>
  <id>http://liuyix.org/</id>
  <author>
    <name><![CDATA[liuyix]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python并发编程手册]]></title>
    <link href="http://liuyix.org/blog/2015/python-concurrent-programming/"/>
    <updated>2015-12-17T07:08:00+08:00</updated>
    <id>http://liuyix.org/blog/2015/python-concurrent-programming</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[docopt -- Python必备的命令行接口模块]]></title>
    <link href="http://liuyix.org/blog/2015/python-docopt/"/>
    <updated>2015-10-21T00:02:00+08:00</updated>
    <id>http://liuyix.org/blog/2015/python-docopt</id>
    <content type="html"><![CDATA[<p>docopt很适合经常需要用python写命令行工具的同学使用。</p>

<h2>docopt之前</h2>

<p>工作需要，经常会用大块的代码来定(ren)义(rou)命令行界面的工具。代码经常是如下的样子：</p>

<p>```python</p>

<p>import optparse</p>

<p>parser = optparse.OptionParser()
parser.add_option(&lsquo;&mdash;foo&rsquo;, &lsquo;-f&rsquo;, default=&lsquo;1&rsquo;, type=&lsquo;int&rsquo;)
parser.add_option(&lsquo;&mdash;bar&rsquo;, &lsquo;-b&rsquo;, action=&lsquo;store_true&rsquo;)</p>

<h1>类似以上的代码大概几十行</h1>

<p>opts, args = parser.parse_args()</p>

<p>```</p>

<p>每一个python脚本都需要提供类似的接口。因此每一次都需要写类似的代码。在写过几次后为了保持DRY原则，我将初始化parser封装为一个method放在util部分。可是依旧是逃不过重复的写<code>parser.add_option</code>。不止一次地我考虑干脆自己写个模板类，以后命令行的定义直接以配置文件的形式写出来，然后每次都通过读取这个配置文件自动化的去生成parser。我相信这个问题我一定不是第一个遇到，应该会有已知的模块解决这个laber intensive的工作。</p>

<p>正在这个时候，偶然看到Python weekly发现了docopt</p>

<h2>docopt</h2>

<p>docopt官网地址：<a href="http://docopt.org/">http://docopt.org/</a></p>

<p>docopt的作者有一个30分钟的视频很好的介绍了docopt这个moudule。推荐大家看一下，自备梯子~ <a href="https://youtu.be/pXhcPJK5cMc">https://youtu.be/pXhcPJK5cMc</a></p>

<p>更令懒人们惊喜的是作者还制作了一个js版本的docopt，可以让你在浏览器中把玩docopt： <a href="http://try.docopt.org/">http://try.docopt.org/</a></p>

<p>使用docopt后，代码上会更加Pythonic，具有很高的可读性，命令行接口的定义所见即所得的样式：</p>

<p>```</p>

<h1>docopt example</h1>

<p>mydoc = &ldquo;&rdquo;&ldquo;Naval Fate.</p>

<p>Usage:
  naval_fate.py ship new <name>&hellip;
  naval_fate.py ship <name> move <x> <y> [&mdash;speed=<kn>]
  naval_fate.py ship shoot <x> <y>
  naval_fate.py mine (set|remove) <x> <y> [&mdash;moored|&mdash;drifting]
  naval_fate.py -h | &mdash;help
  naval_fate.py &mdash;version</p>

<p>Options:
  -h &mdash;help     Show this screen.
  &mdash;version     Show version.
  &mdash;speed=<kn>  Speed in knots [default: 10].
  &mdash;moored      Moored (anchored) mine.
  &mdash;drifting    Drifting mine.
&ldquo;&rdquo;"</p>

<p>from docopt import docopt</p>

<p>arguments = docopt(mydoc, version=&lsquo;0.1&rsquo;)</p>

<p>print arguments
```</p>

<p>这样就定义了一个丰富的命令行接口。命令行接口提供了<code>--help</code>和<code>--version</code>两个基础功能。其中<code>--help</code>输出<code>mydoc</code>，<code>--version</code>输出指定的<code>version</code>信息。</p>

<p>接口还提供了2个参数（ship, mine），每种参数还提供了不同的几种参数的组合。其中<code>[...]</code>内是可选参数，<code>(...|...)</code>是互斥参数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[由互联网中的Python应用想到的网站架构的优化]]></title>
    <link href="http://liuyix.org/blog/2015/python-in-industry/"/>
    <updated>2015-04-08T22:56:00+08:00</updated>
    <id>http://liuyix.org/blog/2015/python-in-industry</id>
    <content type="html"><![CDATA[<ul>
<li>国内<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>

<ul>
<li>知乎</li>
<li>豆瓣</li>
<li>果壳网</li>
</ul>
</li>
<li>国外，只列出我认识的比较出名的，还有好多<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>=。=

<ul>
<li>Quora 国外的知乎？</li>
<li>Dropbox 国外的金山快盘？</li>
<li>Disqus 国外的多说？</li>
<li>Pinterest 国外的花瓣？</li>
<li>Youtube 国外的优酷？</li>
<li>Slideshare 国外的百度文库？</li>
<li>reddit 国外的猫扑？</li>
<li>Yelp 国外的大众点评</li>
<li>&hellip;</li>
</ul>
</li>
</ul>


<p>更多的信息可以参考Python官网的<a href="https://www.python.org/about/success/">Python Success Stories</a>。</p>

<h3>Quora</h3>

<p>下面是QuorWhy did Quora choose Python for its development?a创始人在Quora上对<em>Why did Quora choose Python for its development?</em>的回答<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>

<blockquote><p>We decided that Python was fast enough for most of what we need to do (since we push our performance-critical code to backend servers written in C++ whenever possible). As far as typechecking, we ended up writing very thorough unit tests which are worth writing anyway, and achieve most of the same goals.</p></blockquote>

<p>可以看到对于Python的性能短板，Quora在performance-critical的地方尽可能换用了C++。对于Python没有静态类型，Quora用尽可能的单元测试来确保质量。之所以选择Python其实很大的原因是Founder对Python比较擅长。
进一步google了下，他们的框架用的Pylon。</p>

<h3>知乎的技术架构</h3>

<p>知乎CTO在去年年底有过分享，目前在InfoQ上能找到整理稿。链接：<a href="http://www.infoq.com/cn/news/2014/12/zhihu-architecture-evolution">http://www.infoq.com/cn/news/2014/12/zhihu-architecture-evolution</a></p>

<p>简而言之用的tornado，自己开发了日志系统Kids，消息传递系统Sink，还有页面渲染ZhihuNode。</p>

<h3>网站架构及性能的思考</h3>

<p>本周听了一次FB周海平在阿里内部的一次分享。无论是阿里、Facebook还是豆瓣，我发现了在网站架构上这几家有很多共同点的：</p>

<ul>
<li>MySQL作为存储后端</li>
<li>MySQL上一定有memcache、tair这样的KV系统做缓存</li>
<li>都各自开发了适合自己的消息分发系统，Notify, Thrift, Beanstalkd</li>
<li>后端应该都具有实时日志数据分析： HBase、云梯2、Kids</li>
<li>不同程度上用异步化来提高性能，并会一直以此来作为性能提升的方法。</li>
<li>消息链路上的优化：一个网页的渲染上是树状结构的获取数据，因此可以在通过优化这棵树来达到优化整个过程的目的</li>
</ul>


<h3>其他</h3>

<p>网站选型不单纯是比较语言优劣，还和社区的发展趋势活跃(谁都不想用过一门可能几年就无人问津的语言)、团队内普遍的好恶和掌控能力（C、C++最好，但是大家都不会）、整个行业的形势（团队内都用Lisp，但是招不到人）等等多种因素有关系。
选择哪门语言确实重要，这决定了未来几年或者更远的时间内技术的发展路线，更重要的当规模扩大后需要在性能优化上要付出的代价。（这里面可以拿Facebook优化PHP作为反例，若是当初扎克用的是java或者c++，也许也不会因此如此兴师动众的重写了PHP生态系统里面的大部分东西。）</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="http://www.zhihu.com/question/19685768">知乎-国内使用 Python 作为主要开发语言的知名网站有哪些</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="http://www.quora.com/Which-Internet-companies-use-Python">Quora-Which Internet companies use Python?</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="http://www.quora.com/Why-did-Quora-choose-Python-for-its-development">Quora-Why did Quora choose Python for its development?</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python logging模块]]></title>
    <link href="http://liuyix.org/blog/2015/python-logging/"/>
    <updated>2015-04-05T23:46:00+08:00</updated>
    <id>http://liuyix.org/blog/2015/python-logging</id>
    <content type="html"><![CDATA[<h2>Python logging使用</h2>

<h3>多模块使用logging</h3>

<p>不要在每个模块里面都创建新的logger，不然会导致重复的log日志输出。只需要在子模块开始：</p>

<p>```
import logging
LOGGER = logging.getLogger(&lsquo;foo module&rsquo;)
LOGGER.setLevel(logging.DEBUG)</p>

<p>&hellip;.</p>

<p>LOGGER.info(&lsquo;info level logging mesg&rsquo;)
LOGGER.debug(&lsquo;&hellip;.&rsquo;)
```</p>

<p>在主模块必须要初始化<code>root</code>层logging。
python的logging层次化的，最上层的即root的logger初始化可以由<code>logging.getLogger('')</code>来拿到然后进行配置。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Tips]]></title>
    <link href="http://liuyix.org/blog/2014/python-tips/"/>
    <updated>2014-09-22T14:15:00+08:00</updated>
    <id>http://liuyix.org/blog/2014/python-tips</id>
    <content type="html"><![CDATA[<h3>Python实现tail</h3>

<p>credit: <a href="http://stackoverflow.com/q/136168">http://stackoverflow.com/q/136168</a></p>
]]></content>
  </entry>
  
</feed>
