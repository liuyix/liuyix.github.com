<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Liuyix]]></title>
  <link href="http://liuyix.org/atom.xml" rel="self"/>
  <link href="http://liuyix.org/"/>
  <updated>2014-01-04T15:20:41+08:00</updated>
  <id>http://liuyix.org/</id>
  <author>
    <name><![CDATA[liuyix]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[我在BIT的这几年]]></title>
    <link href="http://liuyix.org/blog/2014/my-work-in-bit/"/>
    <updated>2014-01-03T19:39:00+08:00</updated>
    <id>http://liuyix.org/blog/2014/my-work-in-bit</id>
    <content type="html"><![CDATA[<h3>Changelog</h3>

<table>
<thead>
<tr>
<th></th>
<th>Version </th>
<th>  Time </th>
<th> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> 0.1 </td>
<td>  2014-1-3 </td>
<td> 研究生第一年</td>
</tr>
<tr>
<td></td>
<td> 0.2 </td>
<td>  2014-1-4 </td>
<td> 研究生第二年</td>
</tr>
</tbody>
</table>


<h2>我在BIT的这几年</h2>

<p>2年半的研究生即将结束，聊以此文做一下这几年的回顾吧。</p>

<p>2011年我考入了BIT，之后机缘之下来到了现在的实验室，正式成为了现在的导师的<em>第一任</em>弟子。实话说如果当时选择导师的时候能了解到更多的信息，可能就不会是这个选择了。幸运的是误打误撞的还碰到了不错的导师，与其说是导师，现在感觉倒更像是朋友和师兄，他给予了充分的自由和平等，我很感激。不过自己的散漫之气也因此耽误了不少事情，实感愧疚。这个之后会有提到。</p>

<!--more-->


<h2>第一学期</h2>

<h4>研究生课程</h4>

<p>研究生的第一年主要是上课了，没有在实验室待多少时间。第一个学期和大多数人一样尽力把培养方案中要求的课程上完，于是乎第一个学期几乎是宿舍、研究生楼、食堂、实验室这四个地方奔波，课满的时候一天5节课，从早上8点一直到晚上9点半。比较坑爹的是下午和晚上的课程之间的休息仅有40分钟——下午6点下课，晚上的课6点40就开始，40分钟几乎连晚饭都搞不定。（一是下课高峰人很多，二来距离不近）<br/>
研究生的课程难度上其实和本科生差别不大，不过还是让我感受到了一些压力：每一门专业课程都有至少一个，有时几个可以称得上是project的作业。虽然听说这种程度的project其实只能算是接近于本科生课程的要求，有的甚至还要宽松。但这恰恰是燕山大学计算机专业的不足之处，本科时我一直期待着可以有这种一试身手的有挑战的任务。</p>

<h4>环境</h4>

<p>住宿和饮食得益于北京重点高校的给力扶持令人满意，所住的宿舍环境干净、宽松，食堂因为学校的补助，饭菜相比外面实惠很多。（不过现在也因为CPI有所涨价了，从2011年￥8每顿饭到现在￥12左右）<br/>
实验室的环境同其他同学相比也好一些，人均面积可以说是在整个学院来说都是很大的。刚到的时候实验室的机器不怎么给力，是2007年的老机器了，忍受了一年之后终于在2012年的时候换成了目前非常给力的工作站。 <br/>
研究生阶段不同于大学本科，每个人的作息和时间安排因实验室而异，有的实验室要求很严格，规定了下课后必须到实验室;有的则相对灵活宽松，没有具体的要求，只要及时把任务搞定就可以。我很幸运的是后者，所以没有课的时候比较自由。不过后面会提到这样带来的一些副作用。</p>

<h4>实验室工作</h4>

<p>每个实验室因Boss不同，对研究生以及整个实验室的工作方向都有相当的差别。有的是企业项目导向的，以企业合作的方式让学生去完成一些企业项目（说白了就是当廉价劳动力&hellip;）;有的是以学术研究为导向的，具体来说就是拿到了某个基金，之后来做一些研究工作，说白了就是发论文;更多的则是兼而有之，既有一些与企业合作的项目，也有一些学术型的研究。我所在的实验室是第二种，单纯以学术研究为导向的，因而研究生的第一个学期我在实验室的主要任务就是读论文，内容集中在<em>Simulation</em>,<em>Performance Evaluation</em>这一块。由于自己之前没有什么基础，因而读的时候收获甚微。<br/>
除此之外，我还接触了<em>Gem5模拟器</em>。惭愧的是在实验室待了2年有余，Gem5模拟器钻研的不是很精，只是对整个架构，完整的工作原理有了一个初步的了解，实现了一些功能的扩展。这个稍后会细说。</p>

<p>整个一个学期，最令我印象深刻的事是关于人工智能课程，其实这个课程当初没有选，几个舍友选了之后向我推荐，当时想着不如多学些让自己有个更宽的知识面，没成想最后的结束比较狼狈，课程项目做的马马虎虎，考试也只是擦边60分水过，自己现在对AI依旧比较陌生，不得不说是一个遗憾。<strong>现在想来这是自己的一个弱点——对自己没感觉的东西，总是不能做的令人满意，如果现在设想十年后自己没有成功的原因的话，这应该算上一条。</strong></p>

<h2>第二学期</h2>

<p>2012年4月份这一个学期伊始，导师出国做为期一年的访问学者。</p>

<h4>几个月的实习</h4>

<p>临走前将我安排到了中国软件评测中心CSTC做实习（在2011年年末的时候就已经有了一些接触，当时不过是在学校来做，这个时候就正式去公司去做实习了）。实习工作比较水，一如给的不足一百的实习薪水。做的内容是Android平台的安全软件研究。具体来说就是“研究”LBE隐私卫士的实现原理。这也是我第一次接触LBE。 <br/>
之后大概两个月都在做这一块的逆向研究，越发的感觉到LBE“主动防御”技术真的好牛逼。恰巧的是同年四五月份，360安全卫士、腾讯管家也才陆陆续续的推出了类似功能。我在CSTC的情况很微妙，只是我一个人独立在做这一块，最终是大概到了4月末还是没有作出成果，原因是多方面的，对Android整个系统的了解我只是个大菜鸟，只是自学了一点皮毛，同时我也不是Hacker级别的玩家。虽然对我来说我也研究出了一些门道，但很遗憾的没有做出成品。<br/>
这一段时间我实现了利用ptrace实现<em>动态注入共享库</em>，还有运行时的<em>function redirection</em>，对Android Binder协议也接触了一点。我已经尽力了，没什么遗憾。 <br/>
之后为了交差，CSTC的指导人又让我做一个简单的短信和来电骚扰拦截应用，这个相对于前者难度很小，于是大概一个月的时间就做出来一个基于黑白名单的短信和电话过滤应用。实现使用的核心原理没什么难度，网上都有，就是Java反射调用一个没有公开的接口从而实现来电拦截。这个应用代码主要是sqlite的增删改查以及界面的实现。</p>

<h4>实验室工作</h4>

<p>导师和我在这个学期还是经常有邮件的联系，实验室的工作也一直还有，主要工作就是完成一个很tricky的trace收集算法，在gem5上实现，然后发会议paper，因为CSTC的实习，实验室的这块工作就没怎么顾得上，到了七八月份眼看着到了论文deadline，这时候CSTC那一块要求做的来电和短信的过滤应用也告一段落，因此就决定把实习辞掉，专心来做paper，这个时候是7月末。<br/>
于是从7月末开始，也就是研究生第一年的暑假，整个一个假期都在实验室苦逼地做实验，一直到9月初deadline截至时，尤其印象深刻的是deadline是北京时间的上午，距离几个小时前依旧在跑实验数据，最终算是勉强把数据跑完加上了，论文几乎没有怎么校对过。现在回顾看来，这其中至少一半的原因在于我的拖延，论文实际上在大约五六月份时就已经有了初稿。<strong>自己在一段时间不能兼顾多个任务使得最终放弃了实习，专注于实验室的工作。坦诚地来说，这也是自己需要做出改变的一点。</strong><br/>
经过了2个月的奋战，论文首先经历了HPCA顶级会议的考验。没有做出实际成品之前，一直觉得这个东西有些难度，需要花上很大的工作量才能搞定，可完成之后反过来回顾时会觉得实际做出来的东西真正弄透以后会觉得实际的东西没有那么高大上，只不过是&hellip;.（此处省去1万字）。最终在HPCA的peer review阶段，我们根据reviewer的反馈还是将paper撤了下来，得到了许多我们之前没有考虑过的东西，也发现了一些reviewer的关注点，总体上讲我们的主要目的是达到了——让顶级会议的大牛们看一下你的成果，发表下意见。如果大家都很感兴趣，那么自然很有希望被会议录用，反之也可以得到一些中肯的反驳意见。<br/>
最终我们这篇paper发到了一个C类会议上，结果虽然不是最好的，但也不至于很失望。</p>

<h2>第三学期</h2>

<p>这个学期是“无政府状态”的巅峰时期，几乎完全荒废了学业。这个学期我完全的变成了无业游民般的自由——2012年9月初，论文的事情进入尾声，此时这个学期要进行研究生的毕业开题，因此就没有找实习。这样子整个一个学期只有开题这一个任务。这里还有个背景：我所在的实验室是以学术为唯一目的的实验室，大boss，我的导师的导师，近几年几乎不招收硕士了，“<em>两年半的时间，其中还有一年来上课，半年毕业，做研究的时间太少了</em>”，因而导致<em>曾经人满为患的一个屋子现在几乎是空荡荡的，这个学期到了人最少的一个学期——常驻的学生只有我一个人&hellip;</em><br/>
虽然看起来屋子很宽敞，自己一个人极为自由，可那种只能和空气说话的气氛，人待久了会疯掉的。也就是在这个时候我发现自己一天几乎说不了几句话。（研一开始的时候就没有选择什么课余活动，宿舍的哥们都和我一样，每天宅在各自的实验室，只有晚上的时候会在宿舍）当时的我就很恐慌，怕自己因此变得自闭，与人隔绝了一般。<br/>
于是我决定做出改变，不能为了科学让自己变得脱离社会，要找机会融入集体多和人交流，找人一起玩，而因为硕士生毕业开题的事情自己觉得又不应该离开学校，恰逢第一学年的新学期开始，研究生会开始招新。于是我作为研二的学长参加了研究生会。虽然这个学期学业上几乎完全荒废了，可此时回顾来看，我依旧不后悔当初的决定，如果给我重新选择的机会，我还是会这样选择。<br/>
此后的研究生会的活动中，自从研究生开始就没怎么参加集体活动的我玩的很嗨很投入，自然而然地结交了很多好朋友，认识了许多有意思的人，同时也有机会认识了相当多的其他学院的朋友，我很满足。这里给后来人提一个醒，无论怎样都要找到一个集体，融入进去，无论是学术的还是娱乐的，人不能脱离了群体而存在。我之所以选择加入研究生会，是因为学术上并没有给我提供充分的群体归属感，我只能从其他地方寻找。<br/>
这里不得不提到知乎上的一个精彩回答:<strong>二十多岁该做些什么，将来才不会后悔？</strong><br/>
作者是<a href="http://www.zhihu.com/people/yolfilm">yolfilm</a>, 链接地址：<a href="http://zhi.hu/CddD">http://zhi.hu/CddD</a></p>

<blockquote><p>「一個人」的狀態，總是最糟的。</p>

<p>我覺得說一些我的個人經驗，於你無用，因為環境機遇不同。（多一半，還有自我吹噓的潛意識存在）。但，我可以給你一個，我母親給過我的，非常好的建議。</p>

<p>我母親曾經告誡過我，一個人的狀態，總是最糟的。</p>

<p>你一人吃穿用，一人度日過日，非常容易解決，也非常容易跌入谷底，高興時無人分享，但，失志時，那種惡劣的狀態，卻只能一再重復浸淫。所以，要讓自己振作，第一件事，絕不要長期保持「一個人」的狀態。</p>

<p>再不濟，你養條狗，這狗，都要逼你準時餵牠，準時拉牠出去運動，牠病了，你得給牠奔走求醫。你悲傷時，牠會給你溫暖，分攤你的愁苦。你成功時，牠會哈哈斥斥地笑張大嘴，靜坐在一邊共享你的快樂。</p>

<p>牠是你的責任，也是你的負擔。按我母親說的，就是養條狗，你也不會是「一個人」。</p>

<p>你可以不成家，你可以是失怙孤兒，你可以是找不見伴侶的同性戀，你可以悲慘到無以復加的地步，但，就是到那樣境地，你也要強迫自己，不要是一個人。</p>

<p>孤獨殺手里昂，也要養盆花。</p>

<p>孤獨殺手亞蘭德倫，也要養隻金絲雀。</p>

<p>我個人的經驗是，只要你不是一個人，你即使不成功，但，也絕不會失敗。</p>

<p>我一直記住老娘的教誨，一直在身上背著負擔。搞合唱團時，背著團員，搞劇團時，背著團員，開公司時，背著員工，寫劇本時，背著徒弟，拍戲時，背著債務，背著投資人。成家時，背著老婆孩子。</p>

<p>因為總不是一個人，所以你荒唐不起來，也沒辦法混噩度日。</p>

<p>如此，你謀生求職，你艱辛度日，你的理想事業，就是失敗了，但因為有負擔，不是一個人，只要保全了身上背著這些負擔，另一個層面來說，你也總是成功的。</p>

<p>所以，只要你不是一個人，不是只為自己活，某種層面來說，你永遠不會失敗。</p>

<p>你就是被車撞死了，死在半夜的馬路上，因為你不是一個人，就會至少有一個人在惦記著你。</p>

<p>你的生命，就不會沒有意義。</p></blockquote>

<!--看到了别声张，谢谢
这一学期我认识了我这辈子目前为止最有feel的她。先说下结局吧，我俩没在一起，我搞砸了。直到现在每次回忆起这段往事时都会默默的在心里骂自己是个SB，十足的，我知道即使当初没有那么二，也未必会有更好的结果，但我想至少我不会像现在这样后悔。
我第一次体会到了那种想一个人可以想到废寝忘食，整天魂不守舍，整整2个月的时间，除了研究生会的活动以外，我的生活里面只有她。然而因为自己种种的犯二到荒唐的程度（我常常以爱到失去理性安慰自己）导致我们的额关系经历了大起最终归于尘埃，到现在没有联系。在2013年上半年的时候，我依旧想着可以再重新挽回，虽然也感觉到没有了当初的那么强烈的感觉，可这时已经发现她已有了另一半，自己躁动的心也算是平静了，祝福她幸福，也再次(每次想到这段事我都会做的)对我当时的犯二行为给她造成的伤害表示歉意-->


<p>这个学期玩的太用力，导致整个开题报告做的马马虎虎，给之后的毕业论文埋下了很大的隐患，这是后话。这个学期可以用几个关键词来总结：研究生会、玩、开题报告。</p>

<h2>第四学期</h2>

<p>这学期出国访学一年的导师回来了！这也是我的研究生二年级的最后一个学期。<br/>
这个学期周围很多人开始了毕业前的实习，看到许多人开始实习，我也有些心急了，毕竟我没打算继续读博，因而找到一份理想的工作是我的主要目标。也许每一个初当导师的人都心慈手软吧，或者我的导师本来就是一个很好说话的人，总之这个学期我成功的出去实习了。<br/>
实习的公司很有意思，就是LBE！看过前面的应该都知道我在第二学期实习时花了很久来逆向研究LBE的隐私卫士，对它的技术上有很好的印象。现在来看，LBE团队依旧是具有很强的技术实力。能在LBE实习有很大的偶然——正是在自己在论坛扒实习帖子的时候偶然发现了他们在byr论坛发布的招实习生的帖子，之后才知道这个帖子已经贴了很久，我加入那时候其实他们已经不打算继续招人了的。<br/>
去LBE面试，就是面总本人来面的我（后来才知道的==），结果顺利地通过了，当时非常欣喜，竟然只有一面，因为之前一直以为能做出这么高技术含量的人，一定是一个相当规模的牛逼团队，要进入得具有相当的实力才行。<br/>
就这样，我开始了接近半年时间的实习生活。<br/>
加入LBE后才发现，这是一个不到20人创业型团队，实际开发的不到十人。而且做出隐私卫士第一版主要作者竟然是面总一个人！！膜拜&hellip;加入到LBE，原本就打算以后就从事Android平台的开发了，做个Android Developer。可命运再次向我开了个玩笑。<br/>
进去后，面总想要我来做一键root的三星专版，因为三星手机市占率很高同时三星刷机和升级手机使用的是自己开发的特殊协议Odin，同时该协议已经被国外某位大神逆向出来，制成了Heimdall工具，当时国内还没有哪一家公司使用这种方式root手机，由于当时LBE只有我和面总对Linux这一块熟悉，而他还要继续负责LBE核心应用的开发，因而自然由我来承担这块工作。这也就是我在LBE——一个以Android平台安全软件出名的公司几个月的工作成果——<em>LBE一键root三星专版</em>。而这只和Android平台沾边，<del>一点都不</del>几乎不涉及Java的开发，而主要工作是Linux系统开发、QT完成的Windows桌面应用的维护、还有一系列脚本以及一个后台抓取数据的python程序，基本上可以将这些工作归为后台开发，当然整个过程只是覆盖面很<strong>广</strong>：从<em>Linux平台的脚本</em>、<em>python程序</em>到<em>Windows平台的驱动</em>、<em>QT应用</em>再到Android手机上Framework层下的<em>Android su</em>以及Android平台的<em>Superuser</em>，单独来看哪一个部分涉及的技术要求都不高，但是得懂。<br/>
在LBE实习的这几个月，认识了许多小伙伴，大家也给予了我很多肯定，我很感激大家。唯一让我郁闷的地方是公司的地点离学校太远了，学校在西三环，而公司在东三环，后来又搬到了东四环，每天要坐地铁加步行总共1个多小时才能到，每天有2个半小时时间是在地铁上的，很辛苦。</p>

<center>To be continued&#8230;</center>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Kernel概览]]></title>
    <link href="http://liuyix.org/blog/2013/linux-kernel-overview/"/>
    <updated>2013-10-22T20:19:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/linux-kernel-overview</id>
    <content type="html"><![CDATA[<blockquote><p>总结下读过的有关Kernel的书籍，主要是<a href="http://book.douban.com/subject/2287506/">&lt;Understanding the Linux Kernel></a>>、<a href="http://book.douban.com/subject/6097773/">&lt;Linux Kernel Development></a>、<a href="http://book.douban.com/subject/1723151/">&lt;Linux Device Drivers></a></p></blockquote>

<h3>终极目标</h3>

<p>完整的回答以下问题：</p>

<ul>
<li>从开机上电到进入命令提示行，Linux完整的启动过程</li>
<li>Linux终端下敲入<code>ls</code>的完整过程。(从接收键盘设备中断到显示到结果显示到屏幕)</li>
<li>Linux终端下输入<code>cat foo.txt</code>的完整过程。(同上，其中包含了读写磁盘的操作)</li>
<li><em>to be continued&hellip;</em></li>
</ul>


<!--more-->


<h3>内核态/用户态</h3>

<p>Intel x86有4种不同的状态，Unix内核只使用内核态和用户态。</p>

<p>内核线程：</p>

<ul>
<li>内核态在内核地址空间执行</li>
<li>不与用户直接交互，无须终端设备</li>
<li>通常在系统启动时创建，一直活跃直到系统关闭</li>
</ul>


<p>陷入内核态的几种方式：</p>

<ul>
<li>用户态进程调用<code>syscall</code>系统调用</li>
<li>遇到<code>Exception</code>(无效指令、越界访问、除数为0等)：内核会代表进程处理异常</li>
<li>外设向CPU发出<code>interrupt</code></li>
<li>执行内核线程</li>
</ul>


<h3>进程实现</h3>

<p>当进程暂停时，将表征进程状态的寄存器保存到<strong>进程描述符</strong>中，其中包括：程序计数器、栈指针寄存器、通用寄存器、CPU状态信息的控制寄存器（处理器状态字）以及内存管理寄存器。当需要恢复进程执行时，再将保存的字段恢复即可。</p>

<h3>可重入内核</h3>

<p>可重入内核可以包含非可重入代码，需要利用锁机制。</p>

<p><em>Kernel Control Path</em> 内核控制路径表示内核态中内核进行的任务类型：处理syscall、异常、中断处理程序。 <br/>
内核控制路径可以交错执行。</p>

<h3>进程地址空间</h3>

<p>每个进程有“私有”的地址空间，用户态下：私有栈、数据区、代码区；内核态：内核的数据区和代码区、<strong>进程内核栈</strong></p>

<p>在进程的角度上每个进程都是独立的地址空间，但是内核管理上未必是独立的，有可能是共享。</p>

<h3>同步和临界区</h3>

<p>利用同步机制防止多个内核控制路径破坏全局的内核数据结构。</p>

<ul>
<li>非抢占式内核</li>
<li>禁止中断</li>
<li>信号量</li>
<li>自旋锁</li>
<li>避免死锁：Linux通过按规定的顺序请求信号量避免死锁。</li>
</ul>


<h3>信号和IPC</h3>

<p><em>信号机制</em>将系统事件报告给进程的机制。系统事件分为两种：异步通告(SIGINT),同步错误或异常。</p>

<p>进程间通信的机制：信号量、信息队列、共享内存；标准有两种：System V IPC和POSIX</p>

<h3>进程管理</h3>

<ul>
<li><code>fork</code></li>
<li><code>exec</code></li>
<li><code>_exit</code></li>
<li><code>wait4</code></li>
<li>zombie进程</li>
<li><em>process group</em></li>
<li><em>login session</em></li>
</ul>


<h3>内存管理</h3>

<h4>虚拟内存</h4>

<blockquote><p>虚拟内存(virtual memory) 作为一种逻辑层，处于应用程序的内存请求与MMU(Memory Management Unit，硬件内存管理单元)之间。</p></blockquote>

<h4>RAM的使用</h4>

<p>RAM中有一部分存放内核映像部分(内核代码和内核数据结构)。其余部分有三种不同的作用：</p>

<ul>
<li>内核使用</li>
<li>进程使用</li>
<li>磁盘和其他设备的高速缓存</li>
</ul>


<h4>KMA: Kernel Memory Allocator</h4>

<p>KMA内核内存分配器子系统用来处理所有的内存请求，其中包括内核内其他子系统、用户进程通过syscall请求增加内存使用的请求。</p>

<p>KMA的特点：</p>

<ul>
<li>快</li>
<li>省,浪费最少</li>
<li>尽量无碎片</li>
<li>可以同其他内存管理子系统合作</li>
</ul>


<h4>进程虚拟地址空间处理</h4>

<p><strong>尽可能的“懒”的做法</strong> ：必要时才做耗时的工作(COW和demand paging策略)，如果必须要做耗时的工作就多做些(预读取机制)</p>

<ul>
<li>demand paging内存分配策略：进程可在页没有载入主存下执行，当访问到不存在的页时，发生缺页中断，之后中断处理程序将页载入到内存。</li>
<li>COW写时复制策略</li>
</ul>


<h4>高速缓存</h4>

<ul>
<li>推迟写回磁盘的操作</li>
<li><code>sync</code> 调用</li>
</ul>


<h3>设备驱动程序</h3>

<p><img src="http://liuyix.org/images/device-driver-interface.bmp" alt="/images/device-driver-interface.bmp" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[百度校招-系统研发工程师-笔试题]]></title>
    <link href="http://liuyix.org/blog/2013/baidu-exam-review/"/>
    <updated>2013-10-15T01:36:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/baidu-exam-review</id>
    <content type="html"><![CDATA[<p>几道编程算法题：</p>

<ul>
<li>实现类似wget一样的进度条</li>
<li>100亿个单词，每个单词长度小于30，输出去重后的所有单词。</li>
</ul>


<!--more-->


<h3>实现类似wget进度条</h3>

<blockquote><p>当时没有想出来，回来才搜索之后才知道考察的是对转义符的理解。</p></blockquote>

<p>关于换行，话题看起来看似简单，但实际内容不少。</p>

<p><strong>主流操作系统文本换行的差异</strong></p>

<table>
<thead>
<tr>
<th></th>
<th> OS </th>
<th> 按下回车后插入的控制字符 </th>
<th> 含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Windows </td>
<td> <code>\r\n</code> </td>
<td> 0x0D 0x0A <em>CR LF</em> </td>
</tr>
<tr>
<td></td>
<td> Linux </td>
<td> <code>\n</code> </td>
<td> 0x0D <em>LF</em> </td>
</tr>
<tr>
<td></td>
<td> Mac OSX </td>
<td> <code>\r</code> </td>
<td> 0x0D <em>CR</em> </td>
</tr>
</tbody>
</table>


<p>因此你经常会遇到Windows下用notepad看某些Linux编辑的文本，都没有换行。</p>

<p>基本的内容就这么多，如何实现wget的进度条即是在Linux下用<code>\r</code>而不用<code>\n</code>，这样会不断的将新内容输出到同一行，从而达到“刷新”的效果。</p>

<figure class='code'><figcaption><span>demo.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//类似wget的进度条的实现，实际就是转移符\r的使用，\r的作用是返回至行首而不换行</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">bar</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">bar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;#&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;progress:[%s]%d%%</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bar</span><span class="o">+</span><span class="n">len</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>        <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span><span class="c1">//一定要fflush，否则不会会因为缓冲无法定时输出。</span>
</span><span class='line'>        <span class="n">usleep</span><span class="p">(</span><span class="mi">100000</span><span class="p">);</span><span class="c1">// 睡眠100ms</span>
</span><span class='line'>        <span class="c1">//sleep(1);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>给定100亿个单词，每个单词长度小于30，输出去重后的所有单词序列。</h3>

<p>面试准备不充分，这是trie树的最典型的题目了。
更多的信息可以看July的文章。
<a href="http://blog.csdn.net/v_july_v/article/details/6897097">http://blog.csdn.net/v_july_v/article/details/6897097</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小米面试内核驱动工程师总结]]></title>
    <link href="http://liuyix.org/blog/2013/xiaomi-onsite/"/>
    <updated>2013-10-11T19:54:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/xiaomi-onsite</id>
    <content type="html"><![CDATA[<blockquote><p>此为吐槽贴，略涉及技术。</p></blockquote>

<p>之前网申投的是<em>内核驱动工程师</em>，这个职位是凭着自己对Linux Internal还保持非常浓厚的兴趣，虽然实践不多，还有就是一看到这个title就有种高端大气上档次的赶脚。之后前几天打来电话去面试，这才知道这次是小米的bsp团队招人。</p>

<p>怀着忐忑和兴奋的心情去小米参加bsp团队的面试。结果比较让人失望，一方面是自己还有很多不够深入的地方，一方面是bsp团队明显准备不足。</p>

<!--more-->


<h4>小米总部真够偏僻的&hellip;</h4>

<p>地铁上地站下来之后，<strong>非上下班时间，没有公交车可以直达</strong>，只能打车。</p>

<h4>面试原来可以这样</h4>

<p>五彩城的环境还是蛮不错的，我直接到15层会议室，之后被告知面试官正忙，等一会儿。好吧，我就等等吧，<strong>这一等就20分钟</strong>。<br/>
之后进来一位年纪轻轻的面试官哥哥。 <br/>
面试原来可以被当做临时指派的任务。我有很大的把握说面试官是在看到我之前的几分钟才看我的简历。<br/>
<em>#自我检讨#</em> 对自己的研究工作没有弄的足够深入，被面试官稍一刁难就被问倒。一直纠缠于cache和spm之间的性能和功耗上的比较问题，最后只好作罢。于是乎慢慢的气氛变成了质疑我们实验室的研究水平，当时有点气愤，不过在有效的说明了自己发表的关于单程序trace获取的论文时还算将气氛扳回来一些。<br/>
聊了半个多小时面试官哥哥就又被叫出去开会，囧rz&hellip;大概10分钟后，另外一位面试官哥哥进来，然后由于不知道之前的面试官哥哥都<del>问过我什么问题</del>聊过什么话题，于是又有好多重复的问题出现&hellip;囧rz</p>

<p>不过第二个面试官哥哥谈吐和问的问题上明显感觉很专业，对内核和存储乃至trace这块都有很深的见解，和他聊我的毕业设计时，我还取得了非常很有价值的反馈。很赞！</p>

<p>由于自己在内核驱动这块知道的不多，第二位面试官哥哥几次试图问一些汇编语言、内核驱动的问题时，我都很无奈的回答懂得不多，<em>面试一大忌讳就是回答不了解，这样让双方都会有些挫败感，面试官可能会降低印象分</em>，但是对这几块确实连突击的时间都没有，只好这么回答了。<em>检讨：对简历上技术点挖掘的不够深，写了自己常玩github，就被问到了git的用法；写了自己爱玩新技术，就被问到了自己感兴趣的新技术有哪些，这些很可惜都能没有准备。</em> <br/>
再聊了半个小时左右之后，就结束了。感觉应该是挂了。</p>

<p>之前打听过bsp团队之前没有招过应届毕业生，所以我吐槽的这些还是可以理解的。但是没有为面试拿出足够的准备还是蛮失望的。</p>

<p>最后询问时就聊了一些比较轻松的话题，让面试官哥哥介绍了一下目前bsp团队。现在获得的情报是：目前团队规模五六十人，负责了miui之下的大部分工作，包括驱动开发、底层系统优化等等，甚至包括Java层的问题调试，工作范围面很宽。 <br/>
依旧是个创业团队的节奏——连续多年每周6x12hr的工作量。无愧于外界所说的高执行力的团队。</p>

<p>校园招聘是一个双向选择的过程，既是企业挑选人才，也是真正的人才选择企业。在面试的方方面面都会体现出一个企业，一个团队对人才的重视程度，也是赢得口碑的机会。在认真程度上来说，这次面试的体验不如阿里巴巴。<br/>
总体上这两位面试官哥哥给我的感受是非常实干的类型，对小米的这个创业团队强度的团队技术实力上的印象还是很好。祝愿你们能找到适合的人才。</p>

<h4>自己这次面试的经验</h4>

<ul>
<li>简历上的内容还需要加强。

<ul>
<li>在简历的准备上功夫还不够，还是有被问倒的可能，需要加强和巩固。</li>
<li>简历涉及的技术点还是挖掘的不够细致。</li>
</ul>
</li>
<li>面试中还没有hold住场面的能力</li>
<li>面试中需要事先准备一个可以让面试官眼前一亮的闪光点，可以是技术上的，也可以是表达或者其他方面</li>
</ul>


<h3>Update:问到的题目</h3>

<p>昨天没写是因为自己当时没记起来多少&hellip;今天复习时才慢慢都想起来了，在此分享下。</p>

<ul>
<li>关于抢占的理解（何时抢占，怎样实现的抢占）</li>
<li>kmalloc与vmalloc的区别</li>
<li>kmalloc内核是如何实现存储管理的，比如申请了14B的空间</li>
<li>A,B两个进程，运行顺序是A&mdash;B&mdash;A,有多少种可能导致的，比如阻塞，抢占等。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mac上安装octopress]]></title>
    <link href="http://liuyix.org/blog/2013/mac-install-octopress/"/>
    <updated>2013-10-06T12:31:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/mac-install-octopress</id>
    <content type="html"><![CDATA[<blockquote><p>Update: 经人提醒，可以改用国内淘宝的rubygems源下载，具体操作：<a href="http://ruby.taobao.org/">http://ruby.taobao.org/</a> <br/>
<del>可算折腾出来了。最大的障碍是渣一样的网络，rubygems想法不错，可到了国内情况就会变得很糟糕。最后不得已用goagent总算顺利的完成了。</del></p></blockquote>

<ol>
<li>安装homebrew</li>
<li>安装rbenv以及ruby-build</li>
<li><code>rbenv install 1.9.3-p448</code></li>
<li><code>official install octopress</code></li>
<li>在octopress目录下面新建配置文件<code>echo '1.9.3-p448' &gt; $your-octopress-path/.ruby-version</code></li>
</ol>


<!--more-->


<h3>原有的octopress迁移到mac</h3>

<p>如果之前在其他地方已经使用了octopress，那么在mac上的稍有不同。具体为：</p>

<ul>
<li>clone <em>yourname.github.com</em>的source分支：<code>git clone git clone -b source git@github.com:yourname/yourname.github.com.git octopress</code></li>
<li>在clone<em>yourname.github.com</em>的master分支到<code>$your_octopress/_deploy</code>目录: <code>git clone git clone git@github.com:yourname/yourname.github.com.git _deploy</code></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># 如果之前就已经在使用octopress，迁移到mac的话，不要clone octopress源，而是要clone你自己的repo源的source分支</span>
</span><span class='line'>git clone -b <span class="nb">source </span>git@github.com:yourname/yourname.github.com.git octopress
</span><span class='line'>git clone git@github.com:yourname/yourname.github.com.git octopress/_deploy
</span><span class='line'>
</span><span class='line'><span class="c">###### 安装octopress ######</span>
</span><span class='line'><span class="c"># install homebrew</span>
</span><span class='line'>ruby -e <span class="s2">&quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 使用brew安装rbenv</span>
</span><span class='line'>brew install rbenv ruby-build
</span><span class='line'>
</span><span class='line'><span class="c"># 修改.bash_profile</span>
</span><span class='line'><span class="nb">echo</span> <span class="s1">&#39;export RBENV_ROOT=/usr/local/var/rbenv&#39;</span> &gt;&gt; ~/.bash_profile
</span><span class='line'><span class="nb">echo</span> <span class="s1">&#39;if which rbenv &gt; /dev/null; then eval &quot;$(rbenv init -)&quot;; fi&#39;</span> &gt;&gt; ~/.bash_profile
</span><span class='line'>
</span><span class='line'><span class="c"># 关闭terminal，再重新开启</span>
</span><span class='line'>rbenv install ruby-1.9.3-p448
</span><span class='line'>rbenv versions <span class="c">#应该显示的是system和1.9.3-p448</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 进入到你的octopress</span>
</span><span class='line'><span class="nb">cd</span> <span class="nv">$your</span>-octopress
</span><span class='line'><span class="nb">echo</span> <span class="s1">&#39;1.9.3-p448&#39;</span> &gt; .ruby-version
</span><span class='line'>
</span><span class='line'><span class="c"># 再次关闭终端，重新打开进入到你的ocotpress目录</span>
</span><span class='line'>ruby --version <span class="c"># 应该显示的是ruby 1.9.3p448</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 推荐可选操作：更改rubygems源至国内淘宝源，下载更稳定,参考链接：ruby.taobao.org</span>
</span><span class='line'>gem sources -l <span class="c"># 看一下默认的rubygems源的url</span>
</span><span class='line'>gem sources --remove https://rubygems.org/ <span class="c">#此处的url以上一条命令为准，有时可能是http而不是https</span>
</span><span class='line'>gem sources -a http://ruby.taobao.org
</span><span class='line'>gem sources -l <span class="c"># 此处应该只显示的是淘宝的rubygems源</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 现在就可以参考官方的安装说明安装了</span>
</span><span class='line'>gem install bundler
</span><span class='line'>rbenv rehash    <span class="c"># If you use rbenv, rehash to be able to run the bundle command</span>
</span><span class='line'>bundle install
</span><span class='line'>
</span><span class='line'><span class="c"># 如果是第一次安装octopress，还需要安装默认的theme</span>
</span><span class='line'>rake install
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#吐槽# Octopress：想说爱你不容易...]]></title>
    <link href="http://liuyix.org/blog/2013/octopress-fails/"/>
    <updated>2013-09-27T23:09:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/octopress-fails</id>
    <content type="html"><![CDATA[<p>几个月时间，博客转到了github pages上的Octopress，结果是输出的文章比之前更少。（之前的几十篇文章也不见了踪影&hellip;）</p>

<p>我似乎不属于个例——一直以来都特意关注了我所能遇到的Octopress搭建的独立博客，<em>大部分Octopress我所遇到中文博客都很少更新，其中大多迁移到Octopress后几个月内就不再更新了</em>。
结合这几个月为数不多的使用，说一下Octopress的使用感受。</p>

<!--more-->


<h2>对ruby写的jekyll有种陌生的敬畏</h2>

<p>ruby从来没有学过，因此对自己不了解的东西始终有种不自觉的排斥(coder都会有这种感觉吧)，所以每次都是怀着忐忑的心情敲着 <code>rake new_post['XXX']</code> , <code>rake generate</code> ，生怕出现什么闪失而不知所措。可不幸的是，意外总是时而发生。而对此我只能做的就是打开octopress.org，照着文档重新搭建下环境。</p>

<h2>搭建环境简直就是pain in the ass</h2>

<p>我对ruby完全不了解（用了octopress感觉也不会用ruby了&hellip;）搭建环境非常繁琐，以下吐槽就当作一个不懂ruby的coder对ruby项目的吐槽吧。</p>

<p>首先是不能使用系统自带的ruby程序，需要单独下载 <code>rbenv</code> 或者 <code>rvm</code> 来搭建奇葩的ruby-1.9.3。（反观python，大多数应用直接使用默认的环境，多么的方便。）<br/>
而且每次实际上都是下载ruby源代码进行本地编译安装，<code>rbenv</code> / <code>rvm</code> 默认都需要从国外官网下载源码，速度在教育网可以说是惨不忍睹，再加之这两个工具都是个人开发，项目质量不好说，我偶尔会出现因网络问题导致失败重来的情况&hellip;<br/>
之后还要陆陆续续的现在一坨各种插件和工具，在漫长的（速度巨慢）忐忑的（尼玛要出出点啥问题我很难解决，ruby不会文档又少&hellip;）等待后，环境总算是搭建好了。<br/>
之后是 rbenv/rvm 的奇葩设置，这两种工具实际上每次都是靠<code>.bash_profile</code> 载入ruby-1.9.3环境，而Ubuntu默认的terminal必须要设置成非默认的<code>以shell运行的方式运行命令</code> 才会正常的载入ruby环境。<br/>
千辛万苦加若干次挫折你才能开始真正的写blog。</p>

<h2>不能“随时随地方便的写作”</h2>

<p>想在不同的地点，不同的电脑、设备中更新博客几乎是不可能的。（事实上这是可能的，我之前努力研究过，非常麻烦）而我的环境恰恰就是这个样子：实验室常用主机一台，宿舍笔记本一台。仅仅多了一台编辑设备，你需要更多的努力才能正确的将环境搭好。</p>

<p>这里简单的说下折腾的大致过程：</p>

<ol>
<li>clone自己blog的<code>source</code>分支到新电脑，比如clone到 <code>foo.github.com</code></li>
<li>在<code>foo.github.com</code>下新建目录<code>_deploy</code> 然后clone <code>master</code> 分支到该目录下</li>
<li>在<code>foo.github.com</code>下搭建octopress</li>
</ol>


<p>嗯，这仅仅是折腾的开始，如果在不同地点编辑的话，你需要经常<code>git pull</code>才可以，而且要是没有写好的blog，也需要push到服务器中，然后在另外的地方pull下来才能继续编辑。</p>

<hr />

<p>吐槽到此结束，没有坚持写博客，上述都是次要原因，主要的原因应该还是自己比较懒&hellip;（Octopress又让写博客变得略微的艰难，于是更加的懒）</p>

<p>嗯&hellip;你没猜错，这是又要搬家的节奏&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻墙下载附带字幕的youtube视频]]></title>
    <link href="http://liuyix.org/blog/2013/youtube-download-with-subtitle/"/>
    <updated>2013-08-09T23:59:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/youtube-download-with-subtitle</id>
    <content type="html"><![CDATA[<blockquote><p>许久没写了，上一篇水文教程。</p></blockquote>

<p>需要的工具：</p>

<ul>
<li><a href="https://code.google.com/p/goagent/">goagent</a></li>
<li><a href="http://rg3.github.io/youtube-dl/download.html">youtube-dl</a></li>
</ul>


<p>goagent教程就不上了，这个是翻墙的基本知识。:-P</p>

<h3>使用youtube-dl下载youtube视频</h3>

<p>事先声明, Windows平台的我没有试过。按照说明需要安装python 2.6以上的版本才能运行。<br/>
然后先用浏览器翻墙看一下复制你要下载的youtube的链接，比如 <a href="http://www.youtube.com/watch?v=9bZkp7q19f0">http://www.youtube.com/watch?v=9bZkp7q19f0</a><br/>
然后进入命令行，输入</p>

<ol>
<li>此步骤可选，若想选择下载的格式和大小，则可以先列出可下载的格式列表，使用命令： <code>./youtube-dl --write-sub --proxy 'http://127.0.0.1:8087' --list-formats http://www.youtube.com/watch?v=OPethpwuYEk</code></li>
<li>若执行了(1)则此步骤中可以指定<code>--format 22</code>, 即<code>./youtube-dl --write-sub --proxy 'http://127.0.0.1:8087' --format 22 http://www.youtube.com/watch?v=OPethpwuYEk</code></li>
</ol>


<p>几分钟之后就会下载好选择的视频(文件名称默认为解析出的视频名称)</p>

<hr />

<p>让我的感觉印象深刻的是这个项目是由python编写，但是项目的部署非常不错，只有一个可执行文件，没有任何其他依赖。这个之后研究下 :&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 4.3新特性——SElinux简介 ]]></title>
    <link href="http://liuyix.org/blog/2013/android-4-dot-3-selinux/"/>
    <updated>2013-07-28T00:32:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/android-4-dot-3-selinux</id>
    <content type="html"><![CDATA[<p>New Jelly Bean &mdash; Android 4.3于7月底发布，这次整体上变化不是很大，所以还是叫Jelly Bean。不过在底层，Android在安全上实际增强了不少，Android 4.3开始集成SELinux, 系统的安全性(<em>潜力</em>)提高了一个档次。</p>

<p>New Jelly Bean, New JB，Android 4.3指的都是Google新发布的Android 4.3系统，代号依旧是Jelly Bean</p>

<h2>The End of Root?</h2>

<p><strong>Absolutely NO!!</strong></p>

<ol>
<li>SELinux 目前（从长远看也很可能）是 <em>permissive</em> 模式，即不会拒绝而只是记录<em>违规</em>事件；而不是最严格的 <em>enforce</em> 模式——只要违反规则就会denial，因为普通消费者能遇到的应用和情形会非常复杂，如果使用该模式会出现更多的问题，同时也会给用户束缚自由的感觉（如同厂商卖给你手机的同时给你规定好了“你只可以xxxx而不能xxxx”，不管你是不是这样觉得，我反正是这么觉得）。这也就意味着使用漏洞提权的方法获得root权限依旧可行，只要SELinux使用的是<code>permissive</code>模式。</li>
<li>即使SELinux设置为<code>enforce</code>模式，也不会是root的末日。我们还可以通过<em>线刷</em>的方法刷入修改的或者其他的定制ROM方法获取Root权限。这样做的前提是手机厂商不锁bootloader（从而给用户自由刷机的权利）。谷歌的Nexus系列就是不锁bootloader——可以使用<code>fastboot oem unlock</code> 解锁，之后就可以用<code>fastboot</code>随意的修改定制手机ROM。
而三星手机没有强硬的采取严格的手段锁bootloader，可以用Samsung的<em>官方</em>刷机工具Odin<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>刷机，一样可以实现不锁bootloader的效果——随意修改定制手机。其他厂商就不太了解了。</li>
</ol>


<h4>New challenge for Root</h4>

<p>New Jelly Bean给root确实增加一些阻碍，这其中包括：增加了nosuid选项的system分区以及root用户的capabilities的限制。所以两位手机root的大神chainfire和koush在New JB上都采用了新的 <em>daemon</em> 模式。</p>

<!--more-->


<h2>SELinux带来了什么？</h2>

<p>极大的增强了Android系统的安全性潜力，SELinux机制实际效用依赖于<code>selinux policy</code>等SELinux的设定。SELinux的加入为Android进入更高安全性和保密性的团体和企业中提供了很大的便利，Android在企业市场有了更多的想象空间。<br/>
试举一栗子：涉密企业项目的成员移动设备定制化安全服务——可以由Android安全服务公司负责定制ROM，根据项目或者企业需求加入定制化的SELinux策略。好吧，Android移动安全领域的门槛又矮了一截子。</p>

<h2>Android SELinux一窥</h2>

<p>Google写的SELinux Guide（<a href="https://source.android.com/devices/tech/security/se-linux.html">here</a>）对部署和设置SELinux提出了指导性的概括。 <br/>
SELinux模块包含了内核空间和用户空间两部分，配置SELinux需要使用相应的Android内核。</p>

<h3>SELinux 编译和部署</h3>

<ol>
<li><p>下载源代码至<code>&lt;root&gt;/device/manufacturer/device-name/sepolicy</code>：</p>

<ul>
<li>包含SELinux的内核： <a href="https://android.googlesource.com/kernel/common/">https://android.googlesource.com/kernel/common/</a></li>
<li>编译时需要提供的SELinux配置文件: <a href="https://android.googlesource.com/platform/external/sepolicy/">https://android.googlesource.com/platform/external/sepolicy/</a></li>
</ul>
</li>
<li><p>修改BoardConfig.mk</p></li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>BOARD_SEPOLICY_DIRS :<span class="o">=</span> <span class="se">\</span>
</span><span class='line'>        &lt;root&gt;/device/manufacturer/device-name/sepolicy
</span><span class='line'>
</span><span class='line'>BOARD_SEPOLICY_UNION :<span class="o">=</span> <span class="se">\</span>
</span><span class='line'>        genfs_contexts <span class="se">\ </span>
</span><span class='line'>        file_contexts <span class="se">\ </span>
</span><span class='line'>        sepolicy.te
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>重新编译内核</li>
</ol>


<h3>SELinux定制流程(via Google)</h3>

<blockquote><ul>
<li><p>SELinux uses a whitelist approach, meaning it grants special privileges based upon role. Because the default policy provided by Android is so permissive, OEMs have great leeway in strengthening it. Here is how we recommend proceeding:</p></li>
<li><p>Use the latest Android kernel.</p></li>
<li>Adopt the principle of least privilege.</li>
<li>Address only your own additions to Android. The default policy works with the Android Open Source Project codebase automatically.</li>
<li>Compartmentalize software components into modules that conduct singular tasks.</li>
<li>Create SELinux policies that isolate those tasks from unrelated functions.</li>
<li>Put those policies in *.te files (the extension for SELinux policy source files) within the <root>/device/manufacturer/device-name/sepolicy directory.</li>
<li>Release your SELinux implementation in permissive mode first.</li>
<li>Analyze results and refine policy settings.</li>
</ul>
</blockquote>

<h2>More about SELinux for Android</h2>

<p>本节大部分信息都是从<a href="http://selinuxproject.org/page/SEAndroid">SEAndroid Wiki</a>上获取.</p>

<p>Android 4.3 采用的是SEAndroid<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，但是做了相当的精简和改变，其中没有以下部分<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>：</p>

<ul>
<li>SELinux管理API以及附带的示例程序 (The new device admin APIs for managing the SELinux functionality and the SEAdmin sample device admin app for using those APIs.)</li>
<li>除了 <code>a restricted form of its sefinfo support for labeling apps</code> 以外，没有任何MAC机制的中间件。</li>
<li>没有 <code>auditd</code> ,<em>也就是说Android 4.3并没有一个收集SELinux审计log的daemon程序</em> （The audit daemon (auditd) for collecting SELinux audit denials and writing them to /data/misc/audit/audit.log. )</li>
<li>采用和SEAndroid不同的策略，<em>fully permissive and unconfined</em> (Our sample policy configuration (Android 4.3 and AOSP master have diverged from our policy, replacing it with a policy that is fully permissive and unconfined).
)</li>
<li>没有重载SELinux策略上的优化，重载策略还需要重启daemon(Some improvements to how policy reloading is handled, particularly avoiding the need to restart daemons.)</li>
<li>对于多用户目录没有合适的安全标签（<code>security label</code>)</li>
</ul>


<p>所以如果想使用<em>完整版</em>的SEAndroid需要去下载使用独立的<a href="https://bitbucket.org/seandroid">SEAndroid</a></p>

<hr />

<p>未完待续&hellip;</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>有关Odin的XDA论坛地址：<a href="http://forum.xda-developers.com/showthread.php?t=2189539">http://forum.xda-developers.com/showthread.php?t=2189539</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>SELinux项目地址：<a href="https://bitbucket.org/seandroid">https://bitbucket.org/seandroid</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="http://selinuxproject.org/page/SEAndroid#Merge_Status">http://selinuxproject.org/page/SEAndroid#Merge_Status</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android平台上的JNI技术介绍]]></title>
    <link href="http://liuyix.org/blog/2013/android-ndk-and-jni-introduction/"/>
    <updated>2013-07-15T06:00:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/android-ndk-and-jni-introduction</id>
    <content type="html"><![CDATA[<h2>NDK简介</h2>

<p>Android是由Google领导开发的操作系统，Android依靠其开放性，迅速普及，成为目前最流行的智能手机操作系统。</p>

<p><img src="http://liuyix.org/images/android-system-architecture.jpg" alt="/images/android-system-architecture.jpg" /></p>

<center>图0-1 Android系统架构图</center>


<p>图0-1是Android系统架构图。</p>

<!--more-->


<p>大多数程序位于最上层的Java Application层。Android通过把系统划分为几个层次从而使得开发者可以使用平台无关的Java语言进行Android应用开发，不必关心程序实际的硬件环境。 Google不仅为开发者提供了SDK开发套件，为了能让开发者使用C/C++编写的本地化的共享库，利用编译后的共享库更高效的完成计算密集型的操作来提高应用的性能，或者移植重用已有的C/C++组件，提高开发效率，Android 1.5之后，又推出了NDK（Native Development Kit）。有了NDK，开发者能够在Android平台上使用JNI(Java Native Interface)技术，实现应用程序中调用本地二进制共享库。 由于Android系统不同于以往的JNI使用环境而是在嵌入式硬件环境下，Android NDK提供了一套交叉编译工具链,和构建程序的工具方便开发者在桌面环境下编译目标平台的二进制共享库。 目前NDK提供了对ARMv5TE,ARMv7-A,x86和MIPS指令集平台的支持，同时在本地接口的支持上，目前以下本地接口支持</p>

<ul>
<li>libc</li>
<li>libm</li>
<li>libz</li>
<li>liblog</li>
<li>OpenGL ES 1.1 and OpenGL ES 2.0 (3D graphics libraries) headers</li>
<li>libjnigraphics (Pixel buffer access) header (Android 2.2 以上可用).</li>
<li>C++头文件的一个子集</li>
<li>Android native应用API接口</li>
<li>JNI头文件接口</li>
</ul>


<p>由上面的介绍，我们可以知道，实际上NDK开发是以JNI技术为基础的，因此要求开发者必须要掌握基本的JNI技术，这样才能进行有效的NDK开发。</p>

<h2>JNI技术简介</h2>

<p>JNI（Java Native Interface）是Java SDK 1.1时正式推出的，目的是为不同JVM实现间提供一个标准接口，从而使Java应用可以使用本地二进制共享库，扩充了原有JVM的能力，同时Java程序仍然无需再次编译就可以运行在其他平台上，即保持了平台独立性又能使用平台相关的本地共享库提升性能。在Java开发中的位置如下图所示。JNI作为连接平台独立的Java层(以下简称Java层)与与平台相关的本地环境(以下简称Native层)之间的桥梁。</p>

<p><img src="http://liuyix.org/images/role-of-jni-intro.gif" alt="/images/role-of-jni-intro.gif" /></p>

<p>图1-1 JNI在Java开发中的位置</p>

<p>实际上在Android内部就大量的使用了JNI技术，尤其是在Libraries层和Framework层。</p>

<h2>何时使用Android NDK</h2>

<p>Google在其文档提到了NDK不能让大多数应用获益,其增加的复杂度远大于获得的性能的代价。Google建议当需要做大量的cpu密集同时少量存储操作或者重用C/C++代码时可以考虑使用NDK。 本文的余下部分将具体介绍Android平台下通过NDK的支持的如何进行JNI的开发。</p>

<h2>Hello,NDK</h2>

<p>本节通过一个简单的例子，介绍NDK开发流程以及JNI的基本使用。 笔者假定你已经下载了NDK，且有Android SDK开发的经验。 在NDK开发包中就有若干的NDK示例。其中 <code>hello-jni</code> 是一个简单的实例。该实例从native层传递字符串到java层，并显示在界面上。（你可以在Eclipse里选择 <strong>新建Anroid项目</strong> ,之后选择 “Create project from existing source”，并定位到NDK目录中的 <strong>Sample/hello-jni</strong> ,这样就可以将示例代码导入到Eclipse中。） HelloJni的Java代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">example</span><span class="o">.</span><span class="na">hellojni</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">android.app.Activity</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">android.view.View</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">android.widget.Button</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">android.widget.TextView</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">android.os.Bundle</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">android.view.View.OnClickListener</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloJni</span> <span class="kd">extends</span> <span class="n">Activity</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="cm">/** Called when the activity is first created. */</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
</span><span class='line'>        <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">main</span><span class="o">);</span>
</span><span class='line'>        <span class="n">Button</span> <span class="n">btn</span> <span class="o">=</span> <span class="o">(</span><span class="n">Button</span><span class="o">)</span><span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">btn</span><span class="o">);</span>
</span><span class='line'>        <span class="kd">final</span> <span class="n">TextView</span> <span class="n">txtv</span> <span class="o">=</span> <span class="o">(</span><span class="n">TextView</span><span class="o">)</span><span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">txtv</span><span class="o">);</span>
</span><span class='line'>        <span class="n">btn</span><span class="o">.</span><span class="na">setOnClickListener</span><span class="o">(</span><span class="k">new</span> <span class="n">OnClickListener</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>            <span class="nd">@Override</span>
</span><span class='line'>            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onClick</span><span class="o">(</span><span class="n">View</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">txtv</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="n">stringFromJNI</span><span class="o">());</span><span class="c1">//调用native函数</span>
</span><span class='line'>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">});</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* A native method that is implemented by the</span>
</span><span class='line'><span class="cm">     * &#39;hello-jni&#39; native library, which is packaged</span>
</span><span class='line'><span class="cm">     * with this application.</span>
</span><span class='line'><span class="cm">     * 声明含有native关键词的函数，就可以在类中使用了。</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">native</span> <span class="n">String</span>  <span class="nf">stringFromJNI</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* </span>
</span><span class='line'><span class="cm">     * 该函数并没有在共享库中实现，但是仍然可以声明。</span>
</span><span class='line'><span class="cm">     * 没有实现的native函数也可以在类中声明，native方法仅在首次调用时才开始搜索。</span>
</span><span class='line'><span class="cm">     * 若没有找到该方法，会抛出java.lang.UnsatisfiedLinkError异常</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">native</span> <span class="n">String</span>  <span class="nf">unimplementedStringFromJNI</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* this is used to load the &#39;hello-jni&#39; library on application</span>
</span><span class='line'><span class="cm">     * startup. The library has already been unpacked into</span>
</span><span class='line'><span class="cm">     * /data/data/com.example.HelloJni/lib/libhello-jni.so at</span>
</span><span class='line'><span class="cm">     * installation time by the package manager.</span>
</span><span class='line'><span class="cm">     * 使用静态方式再创建类时就载入共享库，该共享库（后面会介绍）在程序安装后</span>
</span><span class='line'><span class="cm">     * 位于/data/data/com.example.HelloJni/lib/libhello-jni.so</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">static</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">loadLibrary</span><span class="o">(</span><span class="s">&quot;hello-jni&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Java代码中调用native函数很简单。大致分为以下几步：</p>

<ul>
<li>调用 <code>System.loadLibrary</code> 方法载入共享库</li>
<li>声明native方法</li>
<li>调用native方法</li>
</ul>


<p>JNI的使用的一个关键点是 1) 如何找到共享库 2)如何将Java代码中的声明的native方法和实际的C/C++共享库中的代码相关联，即JNI函数注册。 第一个问题可以交给NDK构建工具 <code>ndk-build</code> 解决:通常是将编译好的so共享库放在 <code>libs/armeabi/libXXX.so</code> 之后会有更详细的介绍。第二个问题可以将在第二节中系统讲述，现在我们只简单的说一下如何做。</p>

<h3>利用javah生成目标头文件</h3>

<p>简易实用的方法是通过利用Java提供的 <code>javah</code> 工具生成和声明的native函数对应的头文件。具体操作是如下：</p>

<ol>
<li> 命令行进入到你的项目目录中</li>
<li> 确认你的android项目的java代码已经编译，如果存在 <code>bin/</code> 目录，应该是编译好的。</li>
<li> 确认你的android项目目录中存在 <code>jni</code> 子目录，如果没有则创建一个（我们现在使用的自带的实例代码，因此可以）。</li>
<li> 在项目根目录下执行命令： <code>javah -jni com.example.hellojni.HelloJNI -classpath bin/classes -o jni/hello-jni.h</code> <strong>确认javah所在路径已经在的$PATH路径下</strong></li>
<li> 若上一命令执行成功，则会在 <code>jni</code> 目录下生成一个名为 <code>my_jni_header.h</code> 的头文件。</li>
</ol>


<h3>编写C/C++共享库代码</h3>

<p>上一步骤我们得到了与Java源文件对应的头文件，因此只要编写 <code>my_jni_header.c</code> ，实现头文件里面的声明的源代码。生成的内容如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cm">/* DO NOT EDIT THIS FILE - it is machine generated */</span>
</span><span class='line'><span class="cp">#include &lt;jni.h&gt;</span>
</span><span class='line'><span class="cm">/* Header for class com_example_hellojni_HelloJni */</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#ifndef _Included_com_example_hellojni_HelloJni</span>
</span><span class='line'><span class="cp">#define _Included_com_example_hellojni_HelloJni</span>
</span><span class='line'><span class="cp">#ifdef __cplusplus</span>
</span><span class='line'><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * Class:     com_example_hellojni_HelloJni</span>
</span><span class='line'><span class="cm"> * Method:    stringFromJNI</span>
</span><span class='line'><span class="cm"> * Signature: ()Ljava/lang/String;</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">JNIEXPORT</span> <span class="n">jstring</span> <span class="n">JNICALL</span> <span class="n">Java_com_example_hellojni_HelloJni_stringFromJNI</span>
</span><span class='line'>  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * Class:     com_example_hellojni_HelloJni</span>
</span><span class='line'><span class="cm"> * Method:    unimplementedStringFromJNI</span>
</span><span class='line'><span class="cm"> * Signature: ()Ljava/lang/String;</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">JNIEXPORT</span> <span class="n">jstring</span> <span class="n">JNICALL</span> <span class="n">Java_com_example_hellojni_HelloJni_unimplementedStringFromJNI</span>
</span><span class='line'>  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#ifdef __cplusplus</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到生成的头文件中的函数和示例项目 <code>hello-jni</code> 中的 <code>hello-jni.c</code> 正好对应。据此也可知我们生成的头文件是正确的。 <code>hello-jni.c</code> 源代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;string.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;jni.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* This is a trivial JNI example where we use a native method</span>
</span><span class='line'><span class="cm"> * to return a new VM String. See the corresponding Java source</span>
</span><span class='line'><span class="cm"> * file located at:</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> *   apps/samples/hello-jni/project/src/com/example/HelloJni/HelloJni.java</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">jstring</span>
</span><span class='line'><span class="n">Java_com_example_hellojni_HelloJni_stringFromJNI</span><span class="p">(</span> <span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span>
</span><span class='line'>                                                  <span class="n">jobject</span> <span class="n">thiz</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="s">&quot;Hello from JNI.&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">NewStringUTF</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>使用NDK提供的工具编译生成共享库</h3>

<p>经过以上两步，我们已经得到了C/C++共享库的源代码，现在需要使用交叉编译工具将其编译成目标机器上的二进制共享库。NDK工具提供了一个简单的构建系统，开发者之需要编写 <code>Android.mk</code> ，之后在项目根目录下执行命令 <code>ndk-build</code> 就可以完成交叉编译过程。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">LOCAL_PATH</span> <span class="o">:=</span> <span class="err">$</span><span class="p">(</span><span class="n">call</span> <span class="n">my</span><span class="o">-</span><span class="n">dir</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">CLEAR_VARS</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">LOCAL_MODULE</span>    <span class="o">:=</span> <span class="n">hello</span><span class="o">-</span><span class="n">jni</span>
</span><span class='line'><span class="n">LOCAL_SRC_FILES</span> <span class="o">:=</span> <span class="n">hello</span><span class="o">-</span><span class="n">jni2</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">BUILD_SHARED_LIBRARY</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Android.mk</code> 可以看作是小型的makefile，关于 <code>Android.mk</code> 的更多细节，限于篇幅，这里不做详细介绍请参考NDK自带文档，里面有完整的介绍。 输出的信息类似下面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">Gdbserver</span>      <span class="o">:</span> <span class="p">[</span><span class="n">arm</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">androideabi</span><span class="o">-</span><span class="mf">4.4.3</span><span class="p">]</span> <span class="n">libs</span><span class="o">/</span><span class="n">armeabi</span><span class="o">/</span><span class="n">gdbserver</span>
</span><span class='line'><span class="n">Gdbsetup</span>       <span class="o">:</span> <span class="n">libs</span><span class="o">/</span><span class="n">armeabi</span><span class="o">/</span><span class="n">gdb</span><span class="p">.</span><span class="n">setup</span>
</span><span class='line'><span class="n">Compile</span> <span class="n">thumb</span>  <span class="o">:</span> <span class="n">hello</span><span class="o">-</span><span class="n">jni</span> <span class="o">&lt;=</span> <span class="n">hello</span><span class="o">-</span><span class="n">jni</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'><span class="n">SharedLibrary</span>  <span class="o">:</span> <span class="n">libhello</span><span class="o">-</span><span class="n">jni</span><span class="p">.</span><span class="n">so</span>
</span><span class='line'><span class="n">Install</span>        <span class="o">:</span> <span class="n">libhello</span><span class="o">-</span><span class="n">jni</span><span class="p">.</span><span class="n">so</span> <span class="o">=&gt;</span> <span class="n">libs</span><span class="o">/</span><span class="n">armeabi</span><span class="o">/</span><span class="n">libhello</span><span class="o">-</span><span class="n">jni</span><span class="p">.</span><span class="n">so</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的信息告诉我们生成好的so文件路径为 <code>libs/armeabi/libhello-jni.so</code> 。至此一个简单的NDK程序的已经制作完成。 总结一下大致过程是：</p>

<ul>
<li>编写好Java源文件，使用静态代码段载入共享库，并声明native函数。之后编译android项目</li>
<li>使用 <code>javah</code> 工具生成头文件</li>
<li>根据头文件编写native函数</li>
<li>利用 <code>ndk-build</code> 完成共享库的编译</li>
</ul>


<h2>native函数的动态注册方法</h2>

<p>上一节我们通过一个简单的实例，对NDK开发有了一个感性的认识。但是你也许会发现Java层上声明的native函数与native上面的实现之间的关联是通过javah生成头文件完成的，这个方法显得很笨拙。 实际上这种静态注册的方法是通过函数名（ <code>Java_com_example_hellojni_HelloJni_stringFromJNI</code> ）来建立联系。这种做法有诸多弊端：</p>

<ul>
<li>名字很长，没有可读性。</li>
<li>每个声明了native函数的类都要生成一个对应的头文件，对于真实的应用程序，类文件很多时不现实。</li>
<li>每次载入都需要查询native函数，效率低。</li>
</ul>


<p>Android内部实现上，在使用JNI时很显然并没有这样做，它采用了更加规范的 <code>动态注册</code> 的方法进行两个层次上的关联。</p>

<h3>动态注册版Hello-Jni</h3>

<p>以下代码是上面的 <code>hell-jni.c</code> 的动态注册版，代码中使用的是自定义的native函数名称。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;string.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;jni.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">jstring</span> <span class="n">getHelloString</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="n">JNINativeMethod</span> <span class="n">gMethods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>    <span class="s">&quot;stringFromJNI&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s">&quot;()Ljava/lang/String;&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">getHelloString</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">nMethods</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">jstring</span> <span class="n">getHelloString</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="s">&quot;Hello from JNI.&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">NewStringUTF</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">jint</span> <span class="n">JNI_OnLoad</span><span class="p">(</span><span class="n">JavaVM</span> <span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">reserved</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">jint</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="n">jclass</span> <span class="n">clz</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">vm</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetEnv</span><span class="p">(</span><span class="n">vm</span><span class="p">,(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">env</span><span class="p">,</span> <span class="n">JNI_VERSION_1_4</span><span class="p">)</span> <span class="o">!=</span> <span class="n">JNI_OK</span><span class="p">){</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">clz</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FindClass</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="s">&quot;com/example/hellojni/HelloJni&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RegisterNatives</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="n">clz</span><span class="p">,</span><span class="n">gMethods</span><span class="p">,</span><span class="n">nMethods</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">JNI_VERSION_1_4</span><span class="p">;</span><span class="c1">//根据JNI规范，JNI_OnLoad必须返回版本号常量否则出错。</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>根据Java的官方文档<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，当VM载入共享库时，会寻找 <code>jint JNI_OnLoad(JavaVM *vm, void *reserved)</code> 函数，如果存在则再载入共享库之后调用该函数。因此我们可以在该函数中完成native函数的注册工作。 <code>JNI_OnLoad</code> 函数的参数有两个，最主要就是 <code>JavaVM</code> 结构。 <code>JavaVM</code> 是存储VM信息的数据结构。更多信息将在后面讲到，这里我们只需要知道，通过JavaVM指针我们可以得到另一个JNI核心结构—— <code>JNIEnv</code> , <code>JNIEnv</code> 代表了整个JNI环境的数据结构，实际是一个函数表,其中存储了JNI的各种相关操作的函数指针，后文会详细介绍，在这里我们只需要知道在JNIEnv结构有以下的方法，通过调用就可以实现动态注册。</p>

<ul>
<li><code>jclass FindClass(JNIEnv *env, const char *name)</code> 传入JNIEnv指针和类名称返回代表这个类的结构<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></li>
<li><code>jint RegisterNatives(JNIEnv *env, jclass clazz,const JNINativeMethod *methods, jint nMethods)</code> 注册native函数的函数<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></li>
</ul>


<h3>JNINativeMethod结构</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">`</span><span class="n">RegisterNatives</span><span class="err">`</span> <span class="err">用来注册一组</span><span class="n">native</span><span class="err">函数，其中使用到了</span> <span class="err">`</span><span class="n">JNINativeMethod</span><span class="err">`</span> <span class="err">结构，具体定义如下</span><span class="mi">3</span><span class="err">：</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span> <span class="c1">//Java代码中声明的native函数的名称</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">char</span> <span class="o">*</span><span class="n">signature</span><span class="p">;</span> <span class="c1">//对应Java代码层native函数的签名，下面会介绍</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">void</span> <span class="o">*</span><span class="n">fnPtr</span><span class="p">;</span> <span class="c1">//共享库中函数指针</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="n">JNINativeMethod</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这里就涉及到了 <strong>函数签名</strong></p>

<h4>函数签名</h4>

<p>Java允许函数重载，因此在注册时就要具体区分出来，否则会出现混乱，因而这里就要使用一种方法将每个Java中的方法标上唯一的标记。这种方法就是 <strong>函数签名</strong> 。函数签名应该属于JVM内部的规范，不具有可读性。规定<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>如下：</p>

<table>
<thead>
<tr>
<th></th>
<th>类型标识 </th>
<th> Java类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Z </td>
<td> boolean</td>
</tr>
<tr>
<td></td>
<td> B </td>
<td> byte </td>
</tr>
<tr>
<td></td>
<td> C </td>
<td> char </td>
</tr>
<tr>
<td></td>
<td> S </td>
<td> short</td>
</tr>
<tr>
<td></td>
<td> I </td>
<td> int </td>
</tr>
<tr>
<td></td>
<td> J </td>
<td> long </td>
</tr>
<tr>
<td></td>
<td> F </td>
<td> float </td>
</tr>
<tr>
<td></td>
<td> D </td>
<td> double </td>
</tr>
<tr>
<td></td>
<td> L/java/lang/String; </td>
<td> String </td>
</tr>
<tr>
<td></td>
<td> [I </td>
<td> int[] </td>
</tr>
<tr>
<td></td>
<td> [L/java/lang/object; </td>
<td> Object[] </td>
</tr>
<tr>
<td></td>
<td> V </td>
<td> void </td>
</tr>
</tbody>
</table>


<p> 表1 类型标示对应表</p>

<p>每个函数签名大致格式 <code>(&lt;参数签名&gt;)返回值类型签名</code> 引用类型的参数签名形式为 <code>L&lt;包名&gt;</code></p>

<table>
<thead>
<tr>
<th></th>
<th> Java函数函数签名 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> String f()</td>
</tr>
<tr>
<td></td>
<td> ()L/java/lang/String;</td>
</tr>
<tr>
<td></td>
<td> void f(String s,AClass cls,long l)</td>
</tr>
<tr>
<td></td>
<td> (L/java/lang/String;L/com/example/AClass;J)V</td>
</tr>
<tr>
<td></td>
<td> String f(byte[]) </td>
</tr>
<tr>
<td></td>
<td> ([B)V</td>
</tr>
</tbody>
</table>


<p>表2 一些签名示例 函数看起来很难懂，我们可以利用 <code>javap</code> 工具查看类中的函数签名那个信息，具体用法：</p>

<ol>
<li> 命令行转到 <code>$PROJECT/bin/classes</code> 下（$PROJECT代表Android程序项目根目录，并假定java文件已经编译好，存在bin目录）</li>
<li> 执行命令 <code>javap -s com.example.helljni.HelloJni</code> 其中 <code>com.example.hellojni.HelloJni</code> 是类的完整名称</li>
</ol>


<h3>小结</h3>

<p>这一节中，通过动态注册版的hello-jni代码示例，简要介绍如何在JNI中实现更灵活的动态注册方法关联Java层中native函数和Native层中的实现函数。JNI规范中规定VM在载入共享库之后，要调用 <code>JNI_OnLoad</code> 函数，一般可以在共享库中实现该方法并完成动态注册。 初步接触了 <code>JavaVM</code> 结构和 <code>JNIEnv</code> 结构，并了解了 <code>JNIEnv</code> 的两个“函数成员” <code>FindClass</code> 和 <code>registerNatives</code> 。之后还看到了JNI中保存关联信息的 <code>JNINativeMethod</code> 结构以及了解了Java的 <strong>函数签名</strong> 。</p>

<h2>两个世界的数据互换</h2>

<p>Java层和Native层之间如同两个说着不同语言的国家一样，如果要互相交流就必须要懂得对方的语言。在Native层中是如何表示Java层的数据类型呢？</p>

<h3>基本数据类型和引用数据类型</h3>

<table>
<thead>
<tr>
<th></th>
<th>Java数据类型 </th>
<th> Native层数据类型 </th>
<th> 符号属性(unsigned/signed) </th>
<th> 长度(bit) </th>
<th> </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> boolean </td>
<td> jboolean </td>
<td> unsigned </td>
<td> 8 </td>
<td></td>
</tr>
<tr>
<td></td>
<td> byte </td>
<td> jbyte </td>
<td> unsigned </td>
<td> 8</td>
<td></td>
</tr>
<tr>
<td></td>
<td> char </td>
<td> jchar </td>
<td> unsigned </td>
<td> 16</td>
<td></td>
</tr>
<tr>
<td></td>
<td> short </td>
<td> jshort </td>
<td> signed </td>
<td> 16</td>
<td></td>
</tr>
<tr>
<td></td>
<td> int </td>
<td> jint </td>
<td> signed </td>
<td> 32 </td>
<td></td>
</tr>
<tr>
<td></td>
<td> long </td>
<td> jlong </td>
<td> signed </td>
<td> 64</td>
<td></td>
</tr>
<tr>
<td></td>
<td> float </td>
<td> jfloat </td>
<td> signed </td>
<td> 32</td>
<td></td>
</tr>
<tr>
<td></td>
<td> double </td>
<td> jdouble </td>
<td> signed </td>
<td> 64</td>
<td></td>
</tr>
</tbody>
</table>


<p> 表3 基本数据类型转换表</p>

<table>
<thead>
<tr>
<th></th>
<th> Java引用类型 </th>
<th> Native类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> 所有object </td>
<td> jobject</td>
</tr>
<tr>
<td></td>
<td> java.lang.Class </td>
<td> jclass</td>
</tr>
<tr>
<td></td>
<td> java.lang.String </td>
<td> jstring</td>
</tr>
<tr>
<td></td>
<td> Object[] </td>
<td> jobjectArray</td>
</tr>
<tr>
<td></td>
<td> boolean[] </td>
<td> jbooleanArray</td>
</tr>
<tr>
<td></td>
<td> byte[] </td>
<td> jbyteArray</td>
</tr>
<tr>
<td></td>
<td> char[] </td>
<td> jcharArray</td>
</tr>
<tr>
<td></td>
<td> short[] </td>
<td> jshortArray</td>
</tr>
<tr>
<td></td>
<td> int[] </td>
<td> jintArray</td>
</tr>
<tr>
<td></td>
<td> long[] </td>
<td> jlongArray</td>
</tr>
<tr>
<td></td>
<td> float[] </td>
<td> jfloatArray</td>
</tr>
<tr>
<td></td>
<td> double[] </td>
<td> jdoubleArray</td>
</tr>
<tr>
<td></td>
<td> java.lang.Throwable </td>
<td> jthrowable</td>
</tr>
</tbody>
</table>


<p> 表4 引用数据类型转换表 <br/>
 Native层中将除String以外的类都作为 <code>jobject</code> 处理，对于数组类型，只有基本数据类型的数组是单独表示，其他类型的都以 <code>jobjectArray</code> 类型存储。</p>

<h3>JavaVM</h3>

<p>JavaVM指针指向了一个代表整个VM的实例，同时对所有native线程都有效。主要有以下几个接口可以使用<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>：</p>

<ul>
<li><code>DestroyJavaVM</code> 卸载整个VM实例</li>
<li><code>AttachCurrentThread</code> 将当前的native线程attach到VM实例中，当线程加入到VM线程后，该线程就可以调用诸如访问Java对象、调用Java方法等JNI函数</li>
<li><code>DetachCurrentThread</code> 与 <code>AttachCurrentThread</code> 相反</li>
<li><code>GetEnv</code> 既可以用来检查当前线程是否已经attach到VM实例，还可以得到当前线程的JNIEnv结构。</li>
</ul>


<h3>JNIEnv</h3>

<p>JNIEnv接口包含了JNI的主要功能的函数接口，注意JNIEnv是与线程相关的结构，JNIEnv接口实际是指向内部的一个函数集合，要在Native层操纵某个具体的类，或者调用方法，则需要 <code>JNIEnv</code> 。在native函数的动态注册方法这一节就使用 <code>JNIEnv</code> 的函数进行了native函数的注册。 <code>JNIEnv</code> 是指向一个函数表的指针的指针。 其具体定义如下<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">typedef</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">JNINativeInterface</span> <span class="o">*</span><span class="n">JNIEnv</span><span class="p">;</span>
</span><span class='line'><span class="k">const</span> <span class="k">struct</span> <span class="n">JNINativeInterface</span> <span class="p">...</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>    <span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>    <span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>    <span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>    <span class="n">GetVersion</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">DefineClass</span><span class="p">,</span>
</span><span class='line'>    <span class="n">FindClass</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">FromReflectedMethod</span><span class="p">,</span>
</span><span class='line'>    <span class="n">FromReflectedField</span><span class="p">,</span>
</span><span class='line'>    <span class="n">ToReflectedMethod</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">GetSuperclass</span><span class="p">,</span>
</span><span class='line'>    <span class="n">IsAssignableFrom</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">ToReflectedField</span><span class="p">,</span>
</span><span class='line'>    <span class="p">....</span><span class="c1">//还有很多，这里略去</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>下图是 <code>JNIEnv</code> 的一个简单图示<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup></p>

<p><img src="http://liuyix.org/images/jnienv.gif" alt="/images/jnienv.gif" /></p>

<p>JNIEnv能提供的功能非常多，大体可以分为以下几类5：</p>

<ul>
<li>取得JavaVM实例</li>
<li>Java对象实例的操作

<ul>
<li>成员访问</li>
<li>方法调用</li>
</ul>
</li>
<li>静态成员的访问</li>
<li>String操作</li>
<li>Object操作</li>
<li>Array操作</li>
<li>Native方法的注册，前文介绍过。</li>
<li>Global Reference &amp; Local Reference</li>
<li>提供VM版本信息</li>
<li>JNI的Exception</li>
<li>对Java反射的支持</li>
</ul>


<p>限于篇幅，在此无法一一讲解用法。仅说明较常用的几个。更多详细信息请参考Sun出版的JNI开发者指南（<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/">地址</a>）</p>

<h4>通过JNIEnv在Native层对Java对象进行访问和调用</h4>

<p>通过JNIEnv提供的以下方法就可以调用对象的方法</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">//调用对象方法的函数原型</span>
</span><span class='line'><span class="n">NativeType</span> <span class="n">Call</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span><span class="n">Method</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span><span class="n">jmethodID</span> <span class="n">methodID</span><span class="p">,</span> <span class="p">...);</span>
</span><span class='line'><span class="n">NativeType</span> <span class="n">Call</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span><span class="n">MethodA</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span><span class="n">jmethodID</span> <span class="n">methodID</span><span class="p">,</span> <span class="n">jvalue</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
</span><span class='line'><span class="n">NativeType</span> <span class="n">Call</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span><span class="n">MethodV</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span><span class="n">jmethodID</span> <span class="n">methodID</span><span class="p">,</span> <span class="n">va_list</span> <span class="n">args</span><span class="p">);</span>
</span><span class='line'><span class="c1">//对对象成员操作的函数原型</span>
</span><span class='line'><span class="n">NativeType</span> <span class="n">Get</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span><span class="n">Field</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span><span class="n">jfieldID</span> <span class="n">fieldID</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span><span class="n">Field</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span> <span class="n">jfieldID</span> <span class="n">fieldID</span><span class="p">,</span><span class="n">NativeType</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'><span class="c1">//取得methodID,fieldId的函数原型</span>
</span><span class='line'><span class="n">jmethodID</span> <span class="n">GetMethodID</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jclass</span> <span class="n">clazz</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sig</span><span class="p">);</span>
</span><span class='line'><span class="n">jfieldID</span> <span class="n">GetFieldID</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jclass</span> <span class="n">clazz</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sig</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>前三个函数为一组调用对象方法的函数，区别仅在于传递参数的方式不同。其中 <code>NativeType</code> 表示Java方法返回值对应的Native类型，具体转换见表3,表4。 <code>&lt;type&gt;</code> 是 <code>Void</code> / <code>Boolean</code> / <code>Int</code> / <code>Long</code> / <code>Object</code> 等Java基本数据类型。调用这一组函数时，既需要传递对象的信息，还要传递方法的标识以及Java类中的方法的参数。 <code>jobject</code> 变量既可以通过在Native层中调用 <code>CallObjectMethod</code> 得到，也可以通过后面提到的创建对象实例得到。 <code>methodId</code> 则可以通过 <code>GetMethodID</code> 取得。 <code>jclass</code> 参数可以由前文提到的 <code>env-&gt;FindClass</code> 函数取得。 类似地，还有 <code>CallStatic&lt;type&gt;Method</code> 、 <code>GetStatic&lt;type&gt;Field</code> 、 <code>SetStatic&lt;type&gt;Field</code> 在此不再赘述。</p>

<h3>jstring</h3>

<p>由于String特别常用，且存在比较复杂的编码问题，JNI特意将String类作为一个独立的Native层中的数据类型jstring处理。同其他Object操作类似，jstring也是通过 <code>JNIEnv</code> 来管理的。主要的操作函数有：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">jstring</span> <span class="n">NewString</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="k">const</span> <span class="n">jchar</span> <span class="o">*</span><span class="n">unicodeChars</span><span class="p">,</span><span class="n">jsize</span> <span class="n">len</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">ReleaseStringChars</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">string</span><span class="p">,</span><span class="k">const</span> <span class="n">jchar</span> <span class="o">*</span><span class="n">chars</span><span class="p">);</span>
</span><span class='line'><span class="k">const</span> <span class="n">jchar</span> <span class="o">*</span> <span class="n">GetStringChars</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">string</span><span class="p">,</span><span class="n">jboolean</span> <span class="o">*</span><span class="n">isCopy</span><span class="p">);</span>
</span><span class='line'><span class="n">jsize</span> <span class="n">GetStringLength</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">string</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">jstring</span> <span class="n">NewStringUTF</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bytes</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">ReleaseStringUTFChars</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">string</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">utf</span><span class="p">);</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">GetStringUTFChars</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">string</span><span class="p">,</span><span class="n">jboolean</span> <span class="o">*</span><span class="n">isCopy</span><span class="p">);</span>
</span><span class='line'><span class="n">jsize</span> <span class="n">GetStringUTFLength</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">string</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数的功能可以从名称大致了解到，其中 <code>New</code> 开头的都是将JNI中将String按照编码分为两种，一种是Unicode编码（UTF-16），一种是UTF-8编码 需要注意的是Native层中并没有垃圾自动回收机制，因此申请字符串资源，用完之后要进行释放操作，否则会引起内存泄露。 使用过程中还要注意：Unicode字符串不是“0结尾”的，因此不要依赖 <code>\u0000</code> 进行字符串的操作。 常见的错误还包括调用 <code>NewStringUTF</code> 传入的参数 <code>bytes</code> 必须是 <code>Modified UTF-8</code> 格式的，否则会出现乱码。<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup></p>

<h3>jarray</h3>

<p>Native层可以通过操作jarray数据来处理Java层的数组类型。JNI中将基本类型Java数组和引用类型数组分开处理。 下面是几个Java数组的例子。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">int</span><span class="p">[]</span> <span class="n">iarr</span><span class="p">;</span> <span class="c1">//基本类型数组</span>
</span><span class='line'><span class="kt">float</span><span class="p">[]</span> <span class="n">farr</span><span class="p">;</span><span class="c1">//基本类型数组</span>
</span><span class='line'><span class="n">Object</span><span class="p">[]</span> <span class="n">oarr</span><span class="p">;</span><span class="c1">//引用类型数组，数组元素是Object</span>
</span><span class='line'><span class="kt">int</span><span class="p">[][]</span> <span class="n">arr2</span><span class="p">;</span><span class="c1">//引用类型数组，数组元素是 int[]</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>基本类型数组的操作</h3>

<p>下表是基本类型数组操作的函数小结</p>

<table>
<thead>
<tr>
<th></th>
<th> JNI函数描述 </th>
<th>    </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Get<Type>ArrayRegion </td>
<td> 将基本类型数组的数据复制到预先申请好的C数组中或者反方向操作操作</td>
</tr>
<tr>
<td></td>
<td> Set<Type>ArrayRegion </td>
<td>   </td>
</tr>
<tr>
<td></td>
<td> Get<Type>ArrayElements </td>
<td> 获得/释放指向基本类型数组的数据的指针</td>
</tr>
<tr>
<td></td>
<td> Release<Type>ArrayElements </td>
<td>   </td>
</tr>
<tr>
<td></td>
<td> GetArrayLength </td>
<td> 返回数组的长度</td>
</tr>
<tr>
<td></td>
<td> New<Type>Array </td>
<td> 新建一个指定长度的数组</td>
</tr>
<tr>
<td></td>
<td> GetPrimitiveArrayCritical </td>
<td> 获得/释放指向基本类型数据的指针</td>
</tr>
<tr>
<td></td>
<td> ReleasePrimitiveArrayCritical </td>
<td>   </td>
</tr>
</tbody>
</table>


<p>表5 基本数据类型数组的操作函数</p>

<h3>引用类型数组的操作</h3>

<p>下面以一个简单的代码片段作为说明<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup>。假设某段Java代码中声明了以下的native函数</p>

<pre><code>native int[][] get2DArray(int size);//返回 int[size][size]大小的二维数组
</code></pre>

<p>Native层可以用以下代码实现</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">jobjectArray</span> <span class="n">get2DArray</span><span class="p">(</span><span class="n">jint</span> <span class="n">size</span><span class="p">){</span>
</span><span class='line'>     <span class="n">jobjectArray</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>     <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>     <span class="n">jclass</span> <span class="n">intArrCls</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FindClass</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;[I&quot;</span><span class="p">);</span>
</span><span class='line'>     <span class="k">if</span> <span class="p">(</span><span class="n">intArrCls</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>         <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* exception thrown */</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">NewObjectArray</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">intArrCls</span><span class="p">,</span>
</span><span class='line'>                                     <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>     <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>         <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* out of memory error thrown 可能遇到空间不足*/</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>         <span class="n">jint</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>  <span class="cm">/* make sure it is large enough! */</span>
</span><span class='line'>         <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>         <span class="n">jintArray</span> <span class="n">iarr</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">NewIntArray</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'>         <span class="k">if</span> <span class="p">(</span><span class="n">iarr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>             <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* out of memory error thrown */</span>
</span><span class='line'>         <span class="p">}</span>
</span><span class='line'>         <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>             <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>         <span class="p">}</span>
</span><span class='line'>         <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SetIntArrayRegion</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">iarr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
</span><span class='line'>         <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SetObjectArrayElement</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">iarr</span><span class="p">);</span>
</span><span class='line'>         <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DeleteLocalRef</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">iarr</span><span class="p">);</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>上述代码展示了 <code>NewObjectArray</code> 、 <code>NewIntArray</code> 、 <code>SetObjectArrayElement</code> 、 <code>SetIntArrayRegion</code> 等函数的用法，代码可读性很高，这里不做进一步解释。</p>

<h2>垃圾回收管理</h2>

<p>Java作为高级语言，具有垃圾自动回收管理机制，内存管理相对轻松。而C/C++则没有这样的机制，因此在Native层对象实例可能被垃圾回收。这里就涉及到了JNI的对象引用的管理。 JNI支持三种引用类型—— <code>LocalReference</code> /  <code>GlobalReference</code> / <code>WeakGlobalReference</code> ，每一种引用类型的生命周期是不同的。 大多数JNI函数使用的是 <strong>LocalReference</strong> ,即在函数中调用的&#8221;New&#8221;操作返回的都是对象的 <code>LocalReference</code> 。 <code>LocalReference</code> 只在函数执行代码范围内有效，只要JNI函数一返回，引用就会被释放。相对地， <code>GlobalReference</code> 可以在多个函数之间共享，直到开发者自己调用释放函数才会被垃圾回收。另一方面 <code>WeakGlobalReference</code> 则具有 <strong>引用缓存</strong> 功能——一方面它可以像 <code>GlobalReference</code> 一样跨函数共享引用，另一方面它不会阻碍引用的垃圾回收过程。但JNI文档中建议开发者使用 <code>GlobalReference</code> 和 <code>LocalReference</code> 替代 <code>WeakGlobalReference</code> ,因为该引用随时都可能会被垃圾回收，即使是在调用了 <code>IsSameObject</code> 判定引用有效之后仍然可能会失效<sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup>。 有关引用的操作有</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">//GlobalReference</span>
</span><span class='line'><span class="n">jobject</span> <span class="n">NewGlobalRef</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">DeleteGlobalRef</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">globalRef</span><span class="p">);</span>
</span><span class='line'><span class="c1">//LocalReference</span>
</span><span class='line'><span class="kt">void</span> <span class="n">DeleteLocalRef</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">localRef</span><span class="p">);</span>
</span><span class='line'><span class="n">jobject</span> <span class="n">NewLocalRef</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">ref</span><span class="p">);</span>
</span><span class='line'><span class="c1">//WeakLocalReference</span>
</span><span class='line'><span class="n">jweak</span> <span class="n">NewWeakGlobalRef</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">DeleteWeakGlobalRef</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jweak</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="c1">//通用的引用操作</span>
</span><span class='line'><span class="n">jobject</span> <span class="n">AllocObject</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jclass</span> <span class="n">clazz</span><span class="p">);</span>
</span><span class='line'><span class="n">jobject</span> <span class="n">NewObject</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jclass</span> <span class="n">clazz</span><span class="p">,</span><span class="n">jmethodID</span> <span class="n">methodID</span><span class="p">,</span> <span class="p">...);</span>
</span><span class='line'><span class="n">jclass</span> <span class="n">GetObjectClass</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="n">jobjectRefType</span> <span class="n">GetObjectRefType</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="n">jboolean</span> <span class="n">IsSameObject</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">ref1</span><span class="p">,</span><span class="n">jobject</span> <span class="n">ref2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>更多信息请参考官方文档（<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#global_local">地址</a>)和JNI开发者指南(<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/refs.html">地址</a>)</p>

<h2>总结</h2>

<p>本文大致介绍了Android NDK的相关技术以及NDK的基础——JNI的使用，其中简述了NDK的开发流程、函数注册的两种方式、JNI技术的基本内容，其中包括了Java层和Native层之间的数据转换和互操作方法。不难发现，JNI技术扩展了原有Java技术的能力。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Java Native Interface Specification <a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/invocation.html">http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/invocation.html</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#wp16027">http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#wp16027</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#wp17734">http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#wp17734</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>深入理解Android：卷I pp28-29 <a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>Java Native Interface: Programmer&rsquo;s Guide and Specification <a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html">http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html</a><a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p>JNIEnv定义 <a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#wp23720">http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#wp23720</a><a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
<li id="fn:7">
<p><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/objtypes.html#5190">http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/objtypes.html#5190</a><a href="#fnref:7" rev="footnote">&#8617;</a></p></li>
<li id="fn:8">
<p>Android Developers JNI Tips <a href="http://developer.android.com/guide/practices/design/jni.html#UTF_8_and_UTF_16_strings">http://developer.android.com/guide/practices/design/jni.html#UTF_8_and_UTF_16_strings</a><a href="#fnref:8" rev="footnote">&#8617;</a></p></li>
<li id="fn:9">
<p>代码改编自 (The Java Native Interface Programmer&rsquo;s Guide and Specification)<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/objtypes.html#27791">http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/objtypes.html#27791</a><a href="#fnref:9" rev="footnote">&#8617;</a></p></li>
<li id="fn:10">
<p><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#weak">http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#weak</a><a href="#fnref:10" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Root 那些事]]></title>
    <link href="http://liuyix.org/blog/2013/android-root/"/>
    <updated>2013-07-14T19:14:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/android-root</id>
    <content type="html"><![CDATA[<h2>Root</h2>

<p>所谓root就是在Android手机上获取最高权限，Android的底层就是Linux，因此Root过程就是普通Linux用户的提权过程。</p>

<!--more-->


<h2>获得Root的几个思路</h2>

<ul>
<li>利用Android内核漏洞(实际上也是Linux的漏洞)进行提权</li>
<li>使用<code>fastboot</code> 或者厂商提供的刷机工具(比如三星的 <em>Odin</em> )刷入修改的Kernel或者第三方的Recovery，再刷入root程序</li>
</ul>


<h2>Root文件</h2>

<ul>
<li>su</li>
<li>root权限管理应用: 如常用的Superuser.apk/SuperSU.apk</li>
</ul>


<h2>Opensourced Superuser</h2>

<p>Android Hack界大神Koush写了被广泛使用的Root管理软件: <a href="https://play.google.com/store/apps/details?id=com.noshufou.android.su&amp;hl=en">Superuser</a>
Koush的Superuser由于Cyanogenmod的一部分，因此是开源的。地址：<a href="https://github.com/koush/Superuser">https://github.com/koush/Superuser</a><br/>
阅读代码我们就可以了解Android的Root管理应用以及su原理以及如何实现的。</p>

<p>未完待续&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《程序员的自我修养》小结]]></title>
    <link href="http://liuyix.org/blog/2013/advanced-linkers-and-loaders/"/>
    <updated>2013-04-09T21:05:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/advanced-linkers-and-loaders</id>
    <content type="html"><![CDATA[<p>应用开发程序员面向的是软件用户;系统程序员面向的是程序员。<br/>
应用程序使用OS提供的“抽象”的硬件——应用程序接口使用实际的硬件——用来计算的CPU，用来计时的计时器，用来输入的键盘、触摸屏、鼠标、麦克风，用来显示屏幕，用来发声的扬声器,用来保存数据的硬盘，用来和他人通信的网络等等。如果没有操作系统、没有开发工具链，那么应用的开发将回归到“原始社会”。</p>

<h2>OS存在于每一个程序之中</h2>

<p>也许你和我一样，都有一个疑问：自己编写的程序编译之后就能运行了，完全没有感觉到操作系统的存在，告诉自己操作系统只是提供了应用程序运行的平台，如同自己制作的蛋糕拿到市场售卖一般。<br/>
其实，你错了。<strong>操作系统存在于每一个程序之中。</strong><br/>
参考 <a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory">Anatomy of a Program in Memory</a> 的图示</p>

<p><img src="http://liuyix.org/images/kernelUserMemorySplit.png" alt="虚拟空间的分布" /></p>

<p>每一个操作系统上运行的原生程序，在它的虚拟内存中都有1G~2G是不属于自己的，即所谓的“kernel space”</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress修改记录]]></title>
    <link href="http://liuyix.org/blog/2013/my-customize-octopress/"/>
    <updated>2013-03-08T22:27:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/my-customize-octopress</id>
    <content type="html"><![CDATA[<p>&lt;&mdash;more&mdash;></p>

<h3>Octopress</h3>

<p>Reference: <a href="http://blog.zerosharp.com/clone-your-octopress-to-blog-from-two-places/">Clone Your Octopress to Blog From Two Places</a></p>

<p><code>$octopress</code> 代表的是 <code>git clone -b source git@github.com:username/username.github.com.git octopress</code></p>

<p>octopress有2个branch—— <code>source</code> 和 <code>master</code></p>

<p><code>master</code> 是jekyll生成后的静态网站源码，<strong>位置在_deploy目录</strong><br/>
<code>source</code> 是 octopress源码，是<em>octopress</em>根目录</p>

<h4>Blog流程</h4>

<p><code>cd $octopress &amp;&amp; rake generate</code></p>

<ol>
<li>更新octopress源码(目的是要保存markdown源文件)

<ul>
<li><code>git add &lt;modified file&gt;</code></li>
<li><code>git commit -am 'some comment'</code></li>
<li>git push origin <strong>source</strong></li>
</ul>
</li>
<li>生成后的网站源码部署

<ul>
<li><code>rake deploy</code></li>
</ul>
</li>
</ol>


<h3>多个电脑上编写octopress博客</h3>

<p>可能很多人会像我一样有这样的需求：工作地点和家里都想要更新下自己的blog，还有有时会在自己的台式机和笔记本上更新blog，这时你就会遇到我现在的问题： <em>怎么在多个电脑上部署octopress环境</em></p>

<h3>表格boarder的修复</h3>

<p>参考: <a href="" title="http://programus.github.com/blog/2012/03/07/add-table-data-css-for-octopress/">链接</a><br/>
只是作者修改的有点麻烦，我只是把data-table.css粘贴到了 <code>sass/custom/_styles.scss</code> 里面了就出效果了。</p>

<h3>markdown interpreter换成了kramdown</h3>

<p>因为默认的不支持footnote，所以直接换成了<a href="http://kramdown.rubyforge.org">kramdown</a></p>

<h4>Update 2013-07-14</h4>

<p>octopress升级到了2.0, 新的<code>rdiscount</code>支持了footnote特性，因此又换回了<code>rdiscount</code></p>

<h3>404 page</h3>

<p>在source下面建立404.html</p>

<h3>自定义sidebar</h3>

<p>这个教程里就有</p>

<h3>category-list</h3>

<p>TODO</p>

<h3>stylesheet小幅改动</h3>

<h4>awkward ul ol</h4>

<p><a href="https://github.com/imathis/octopress/issues/417">issue417</a>
在 <code>sass/custom/_styles.scss</code> 里修改</p>

<h4>footnote</h4>

<p>一个插件<a href="https://github.com/fmcypriano/footnote-octopress">octopress-footnote</a>,只是个人试用效果不好，遂将js部分去掉了，配合  <a href="http://kramdown.rubyforge.org">kramdown</a> 正好适合</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[期待 Octopress 2.1]]></title>
    <link href="http://liuyix.org/blog/2013/expecting-octopress-2-dot-1/"/>
    <updated>2013-03-08T00:11:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/expecting-octopress-2-dot-1</id>
    <content type="html"><![CDATA[<p>想给Octopress添加几个新功能,想目录的自动生成和点击图片的弹出效果。</p>

<p>搜索了一番，发现有现成的解决方案，不过稍微显得繁琐，原因之一是要手动集成jQuery，许多有趣的功能都依赖于这个强大的js库，纳闷为什么作者没有支持，搜索之后发现很早之前就有人提出这个<a href="https://github.com/imathis/octopress/issues/637#issuecomment-6565847">疑问</a>了，作者给予了回答，大意是太臃肿没必要，然社区群众们呼声很高，Octopress计划在2.1版本中支持jQuery!</p>

<blockquote><p>&#8230;Eventually I decided to add jQuery because that is what the community wants and it makes it easier for folks to work with javascript on Octopress. &#8230;</p><footer><strong>imathis, author of Octopress</strong> <cite><a href='https://github.com/imathis/octopress/issues/637#issuecomment-6565847'>github.com/imathis/octopress/&hellip;</a></cite></footer></blockquote>


<p>很期待新版本的Octopress!!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello Octopress!]]></title>
    <link href="http://liuyix.org/blog/2013/hello-octopress/"/>
    <updated>2013-03-07T18:45:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/hello-octopress</id>
    <content type="html"><![CDATA[<p><img src="http://liuyix.org/images/octopress-logo.png" title="" ></p>

<h2>初识Octopress</h2>

<p>忙里偷闲，折腾下Octopress～</p>

<blockquote><p>Octopress is a framework designed by Brandon Mathis for Jekyll, the blog aware static site generator powering Github Pages.</p><footer><strong>http://octopress.org</strong></footer></blockquote>


<p>Octopress说白了就是一个可以使用markdown<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>写博客的静态网页生成后端。而且还可以利用<a href="http://pages.github.com/" title="github pages">github pages</a>做自己的博客。<br/>
使用了一段时间的Wordpress写博客，然后写着写着就没有然后了。没有坚持下来的原因很大一部分是因为自己，当然(很喜欢这个“当然”)Wordpress不爽体验也是一个原因。这促使我考虑Wordpress的替代方案。</p>

<h3>[吐槽]从Wordpress转移到Octopress的原因</h3>

<p>吐槽Wordpress各种不爽之前，先声明这不是技术上的比较，也不是产品上的优劣比较，我只是从个人需求的角度说一下Wordpress不适合写技术博客，也可以说不能快速的书写有质量的文章。
简单的说Wordpress写博客，需要离开编辑器，操作不便，还要操心其他不相关的事。</p>

<!--more-->


<h4>不能很方便的(在emacs里)写博客</h4>

<p><span class='pullquote-right' data-pullquote='Wordpress写博客，需要离开编辑器，操作不便，还要操心其他不相关的事。'>
程序员优点之一就是 <em>“懒”</em> ，自然写博客也懒得离开编辑器在网页上码字，而且网页上码字体验远不如顺手的编辑器，还必须要联网，最让人受不了的就是手要离开键盘，用 <em>鼠标</em> 来进行各种操作！（Windows用户你不会理解的&hellip;）。<br/>
Wordpress写博客，需要离开编辑器，操作不便，还要操心其他不相关的事。
使用Wordpress的这段时间里，我一直在不停的探索如何更高效更舒服的：从最初的网页上的编辑器插件，到搜索各种Linux,Windows客户端( <a href="http://sns.juziyue.com" title="菊子曰的网站">菊子曰</a>是这一时期的终点，使用上很适合非程序员，但不幸的是只有Windows版本), 最终遇到了org2blog——使用emacs org-mode来写博客。经过我持续不懈的折腾，Wordpress这个诟病基本被我解决掉了。<br/>
</span></p>

<h5>Octopress Side</h5>

<p>Octopress前端支持markdown类的语法，和org-mode相比，同样适合编写格式化的文档，语法相似，更加精简。更欢乐的是markdown文本非常具有可读性（这也是markdown的设计哲学）。<br/>
不仅如此，依托于github，博客文章还具有云端 <em>增量备份</em> 的功能。这点和Wordpress不同，Wordpress上写好的内容用以HTML方式存入MySQL数据库，虽然也有备份的功能，可本地化特点的缺失，<em>需要离开编辑器操作</em> 实在是个鸡肋。
写作之后的同步操作也无需离开编辑器，几条命令就搞定网站！</p>

<h4>需要购买主机</h4>

<p>这是使用Wordpress写博客首先需要操心的事。搭建需要花钱买主机停放你的站点，虽然成本不高，但也不是无成本的。我目前的消费水平还不足以为了一个每天只有不到100IP的小站点购买VPS，需要精打细算——不仅要选择哪家主机划算，还要花折腾主机，还时不时地担心自己或者服务商或者同IP的莫个站点被GFW墙掉。总之一个字“累”！</p>

<h5>Octopress Side</h5>

<p>首先是免费，其次还不如管访问延时等主机相关的问题了。还记得曾有一段时间为了优化访问，花了很多精力在减少插件、优化插件、压缩网页上。虽然建站的很多东西，again, 和写博客是无关的。相比之下，Octopress实际最后就是静态的网页而非动态网站，所以不需要进行优化。</p>

<h4>博客的配置相对复杂</h4>

<p>玩过Wordpress的人都明白平时最常折腾的就是插件和主题，还有Wordpress的升级。<br/>
对于只想简简单单写技术博客，写日记，发牢骚的人来说，这些也是额外需要费心思的地方，而且没点时间和技术，博客还会显得丑陋不堪，缺乏美感。</p>

<h5>Octopress Side</h5>

<p>认识Octopress就是在一次搜索时看到一个技术博客，那个博客让我眼前一亮——简洁、大方，没有大多数Wordpress博客给人的花哨之感，很对程序员的胃口，仔细读了那个博客，才知道除了Wordpress还有一个叫Octopress的东东。<br/>
Octopress在界面上完成度很高，可以说不需要任何修改，其简约之美也足以媲美大多数的Wordpress主题。于是可以更加专注于内容。</p>

<p>第一次写Octopress，各种不熟练，花了好久。就先写到这里，有时间再写下自己的配置过程。</p>

<hr />
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>[http://en.wikipedia.org/wiki/Markdown]<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转]失败的高雅——李欧梵在香港中文大学的演讲]]></title>
    <link href="http://liuyix.org/blog/2012/nobility-of-failure-by-oufan-li/"/>
    <updated>2012-11-24T04:40:58+08:00</updated>
    <id>http://liuyix.org/blog/2012/nobility-of-failure-by-oufan-li</id>
    <content type="html"><![CDATA[<p><em>前几日在李开复的微信公共平台上看到的文章，还是有些价值的。</em></p>

<blockquote><p>你可能不知道，有一种“高雅的失败”，可以历练你的人生。“人年轻时一定要认同危机，这段时间是一个缓冲期。在人成熟前，要经过认同溷乱的阶段。爱尔兰剧作 家、现代主义荒谬剧大师萨缪尔•贝克特说过：‘再试一次，再失败一次，失败得好一点。’ 当你发现越失败越好的时候，你就成功了。”</p></blockquote>

<p>李欧梵，国际知名文化学者。现代文学及文化研究、现代小说乃至中国电影，都是他学术研究的范围。1961年毕业于台湾大学外文系，此后赴美留学，获得哈佛大 学硕士和博士学位。他曾先后任教于香港中文大学以及美国的普林斯顿大学、印第安那大学、芝加哥大学、哈佛大学等知名高校。这位在世人看来十分成功的学者， 求学和任教路上其实磨难重重。学会和失败相处，方能挫而弥坚。</p>

<p>不久前，李欧梵应邀赴香港中文大学作了一场题为《失败的高雅》（“The Nobility of Failure”）的演讲。常言道，“失败乃成功之母”，可失败的价值是什麽——这正是李欧梵要和大家分享的人生经验。<!-- more --></p>

<p>1、任何时代都有一窝蜂——都有一种时髦，有一种社会压力，有一种当时的社会价值。可每个人的生命裡不可能只有一样东西。你总有不同的兴趣，不同的价值，要应对不同的压力。<strong>你要问自己，到底喜欢什麽。</strong>这应该是中学以上、大学教育最重要的一部分。</p>

<p>小学六年级时，我成绩非常好。那时，小学新换了一个刚从美国回来的校长。用现在的话讲，他在小学裡就实施博雅教育。男生女生都要跳舞，每个学生都要学音乐、 体育。虽然当时的台湾和现在一样，六年级要恶补、补习，因为要参加联考考初中。我们已经忙得那样了，可校长说，不行，你们要去运动、要去玩。</p>

<p>也许我不用功，也许我太自信，当我考新竹中学时，突然失常了：晚上太紧张，没有睡好，第二天考数学的时候，我只得了40分。要进入当时的台湾名校，数学一定 要60分才行。我生平第一次感到耻辱。我父母都在新竹中学做老师。中学的老师和校长都是我父母的朋友。我马上想，父母怎麽办，他们没面子了。</p>

<p>我跟我父亲说，这次考试考太差了。父亲没骂我，说40分就40分吧，咱们想想办法。父亲带我去见学校的教务长，教务长看着我，对父亲摇摇头说：“你的儿子我恐怕救不了了。”</p>

<p>没想到放榜的时候，新竹中学多了一项叫“备取”。从前是没有备取的，那一年设了“备取”，有人说，就是专门为我开的。备取一共12个学生，最后一名就是我。 我那时大概10岁多，感觉自己抬不起头来。好在年纪小，过了不久成绩就跟上去了，一帆风顺到了高中三年级，又面临人生的第二个考验。</p>

<p>我的总成绩当时是全校第四名，而全校前五名还是前六名就可以保送大学。我觉得自己太幸运了，但社会压力马上就来了。</p>

<p>当时在台湾，最好的保送生一定是上医学院或是理工科，商科没有人要念。可是我的兴趣很明显，不在理工科。我高一的时候就开始参加各种活动，把班级学生组织起 来，组成一个合唱团，比赛的时候我做指挥，最后得了全校第一名。我那时就知道，自己的兴趣是音乐、艺术、文学之类的东西，可是，到抉择的时候，我该怎麽 办？</p>

<p>我记得我和父母亲第一次开诚佈公地说这个问题。 我的姨丈建议我学法律。可是法律没有我想要感受的艺术的气息。我想念的是文学，又不敢选文学，因为那时的台湾，念文学出来最多当个中学老师。于是姨丈又 说，还有一个外文系可选。我想这好，不如先把英文念好，到时候可以去当外交官。</p>

<p>现在回想起来，我对于当时的大学制度有一个批评。因为当时的台湾大学，文学院只有四个系，学生选的最多、最受欢迎的就是外文系，其他的是历史系、哲学系、考 古人类学系。其实，我和当时的潮流已经做了妥协。但是如果你现在问我，这四个系最喜欢什麽？我除了文学之外，最喜欢人类学，可那时选考古学的人非常少。</p>

<p>2、当我回顾以前，回忆是跳跃式的，想到的都是片段。常常是老师讲过的一句话，看书看到的某一页，或者是哪裡得到的灵感。<strong>而这些使我一生受用无穷灵光片语、个人经验，大多都是在我失落的时候发生的。</strong></p>

<p>我进台湾大学外文系时，一心要当外交官，所以认真练习演讲，死背英文。</p>

<p>和我同时进台大的几位同学，现在都是台湾文学界真正有名的人物，其中就包括白先勇。大家知道白先勇是怎麽上台湾大学的吗？那一年白先勇原本考上了，可是由于 种种压力，他跑到台湾南部的工学院去念水利。念了一年后，他觉得自己实在不喜欢水利，喜欢的是文学，于是第二年又考了台大。所以，白先勇是一进大学就决定 要从事文学的。到大二时，白先勇说要办一个杂志，这个杂志就是《现代文学》。当时没有钱，他问家裡亲戚朋友借钱，全部投在这个杂志上，还把我们都拉了进 去。现在大家把我说成《现代文学》的开创者之一，我有点汗颜，因为我当时只是做了一两篇翻译而已。</p>

<p>我常和白先勇常开玩笑说，就是因为你们太厉害，所以我走了另一条路。不过回想起来，我中学开始兴趣就在文学，特别是西洋文学。</p>

<p>我现在把《现代文学》第一年的几期拿出来看，发现有我几篇文章在裡面，那时我的笔名叫“李欧”，翻译的主要是一些论文。比如汤玛斯•曼的论文。时隔半个世 纪，我回到香港，在香港科技大学当客座教授的时候就讲汤玛斯•曼。可我翻译的时候，根本不知道这篇论文在说什麽，也没有看过汤玛斯•曼的小说。</p>

<p>我们的《现代文学》杂志最后失败了。鲁迅第一次翻译《域外小说集》，也只卖了几十本。我们卖了一两百本，一半以上是白先勇的亲戚买的，还有几本是有些人在书摊上买去的。但是，有的人对于自己的理想真是有一种执着。<strong>明知道在世俗眼光裡不会成功，但又总觉得，就算是失败也有意义。</strong></p>

<p>我不自觉地从同学的经验裡得到启示，但表面上还是很胆怯。毕业以后，当时一窝蜂地要到美国留学，我也跟着大家去申请。</p>

<p>现在各位要申请去美国，会到电脑上找很多资料，我们那时候没有资料，美国大学在哪裡也搞不清楚。我问自己，我要申请什麽呢？我真正想要申请的是比较文学，可又不敢申请。于是我就乱申请，像钓鱼般地乱撒网。</p>

<p>我 心裡想，我还喜欢看电影，不如申请去UCLA（加州大学洛杉矶分校）念电影系。大学四年级的时候，有个老师教西洋戏剧的课，我非常喜欢。听说美国最好的戏 剧在耶鲁，于是我写信申请念耶鲁的西洋戏剧。剩下就是选将来可以溷碗饭吃但又跟文学稍微有点关係的专业，比如传媒研究、大众媒体等等。最后我想，我念外文 系的目的就是当外交官，不能不申请一次，所以申请到芝加哥大学念国际关係。</p>

<p>差不多都准备好了，我父亲问我，为什麽不试试哈佛。我想，没有希望何必试。父亲说，试试没关係。结果我就去了，然后发现申请的大学几乎全部落空，只有两个大学有回信。一个是芝加哥大学，一个是哈佛。</p>

<p>哈佛给我的信写着“Alternate for a Scholarship”。我以为“Alternate”是指另一种奖学金，“for”那个字忘记看了。后来知道，原来又是备取！哈佛回信的意思是，如果别的获奖学金的学生不去，我可以被考虑。我们全家人都看错了。</p>

<p>芝 加哥大学给我的回信，明明写了一个字叫“Scholarship”，结果上飞机前的几个月才知道，芝加哥大学的“Scholarship”只是免学费，没 有奖学金。当时，以我们这样在台湾的中产阶级家庭，买一张飞机票是我父母全年的薪水。父母辛辛苦苦把钱凑足，买了一张单程飞机票，送我到美国去。</p>

<p>我迷迷煳煳到美国，完全是失落的。芝加哥在哪裡、怎麽走都不太清楚。所以我就买最便宜的灰狗大巴的票，一路玩到芝加哥。到了芝加哥就开始念书。美国天寒地冻，我没有衣服，就到西尔斯百货公司买一件最丑最便宜的外套。</p>

<p>学校裡老师讲的完全是“天书”。国际关係当时是讲理论，于是，我陷入到各种危机，觉得自己到美国完全是荒谬的，可能几个月都支持不住。</p>

<p>芝 加哥大学的制度和哈佛不一样，是Quarter制的，十个礼拜就是一个Quarter，学期很短。10个礼拜内要念几十本书，念完还要写一篇论文，这简直 是难以想像的。好在那位教授说，你是台湾来的，懂中文，那你试着写一个春秋战国时期的国际关係。我当时根本没有念过春秋战国的历史，只好去图书馆借书。我 记得，我看到一本现在被尊为大师的吕思勉教授写的关于春秋战国的书。我就从那本书开始接触中国历史的。</p>

<p>这篇论文交给老师，竟蒙老师欣赏，甚至他后来还要留我。可我知道，我不能一辈子搞这个。我有两条路。其实我想的是再到洛杉矶去学电影，因为在美国最失望的时候，我都坐着火车去看电影。义大利片、法国片、新潮片……都是那种怪怪的失落的片子，所以有很多认同感。</p>

<p>后来一个同学说，既然哈佛给过你一个“Alternate”，就再试试看吧。于是我就又试了一下。那个时候我在芝加哥大学远东图书馆工作，馆长钱存训先生是在美国汉学界非常有名的教授。他为我写了一封信，不知道写了什麽，竟蒙录取。</p>

<p>3、大学的目标是什麽？这段时间就是一个缓冲期，你在大学裡可以随意选课，随意地找寻自己的兴趣。<strong>在人成熟前，要经过认同溷乱的阶段。</strong></p>

<p>也许是因为我在很好的环境读书，从来没有想到，我拿到博士学位以后要做什麽。</p>

<p>各 位可能不相信，当时的环境和现在不一样，现在念书，大概三年就要拿学位。可我们那时在哈佛念博士都是拖。有的人拖了十几年，我算快的了，拖了8年。在这8 年裡，我感受到以前教育的不足，拼命念书。我总是觉得自己是不足的，当你觉得自己在这个方面做得不错的时候，总发现，怎麽有的地方还是不知道。</p>

<p>所 以，我这裡要说一点批评的话。在人文学科研究方面，如果你只是为了一个学位，为了一个专业，为了一个非常能触摸到的成功的过程或者成功的目标，你这个学者 绝对不是一流学者。可是，现在的制度往往使得一些非常有才气的年轻同事受制于这个“监牢”，不得不这麽做。所以我非常同情香港各大学人文学科的教授。<strong>人文学科是要晃荡晃荡慢慢积累的，从失落裡面汲取经验，最后慢慢发现，自己找寻的目标是什麽。</strong></p>

<p>甚至大学也是如此。我反对在大一时就分专业。我很崇拜心理学家Erikson，“认同”这个词就是他发明的。大学的目标是什麽？按照他的看法，人年轻时一定 有认同危机，这段时间就是一个缓冲期，你在大学裡可以随意选课，随意地找寻自己的兴趣。你的一生裡，只有大学这个时期可以让你在教授的、环境的保护下，找 寻自己的认同。<strong>到了社会上，就没有时间了。</strong>也就是说，在人成熟前，要经过认同溷乱的阶段。</p>

<p>我的认同溷乱，从大学一年级到博士班，至少10年。我的问题一直是，我是谁，我要做什麽？</p>

<p>4、人在一个漫长的过程中，会开始反省，什麽是成功什麽是失败。有一样金科玉律免不了：<strong>没有一连串的挫折和失败，你的成功都是虚的。</strong></p>

<p>我最宝贵的一次学术经验，不是在哈佛不是在芝加哥，是在普林斯顿。也可以说，那是我一生中犯的最大的一个错误。</p>

<p>我在香港中文大学教了一年半后，突然收到一封电报，是普林斯顿大学请我去教课。</p>

<p>我当时心中万般不想去，因为我非常喜欢香港，可是我所有的朋友都说，为了将来的前途，一定要去。于是我到了普林斯顿。</p>

<p>我 在香港中文大学的时候，人是飘飘然的感觉；一到普林斯顿就发现，好像又回到我刚来美国时的感受，压力非常大。普林斯顿请我去教中国近代史，但是近代史裡没 有文学，只有经济史、外交史这些东西。我越教越没有兴趣。这个时候，普林斯顿东亚系知道我在香港教过比较文学课，他们就说，你不如试试教文学吧。我越教就 越有兴趣，我对现代文学的兴趣也是从无形中得来的。</p>

<p>当我在普林斯顿教到第四年的时候，学校说要考虑永久职（tenure）了。当时历史系有名的教授开了一次集体讨论会，觉得李欧梵的学术还可以，可是不够普林斯顿要求的那麽好。为什麽呢？因为“他的心一半在文学”。</p>

<p>我当时正好在写鲁迅，非常痛苦，不知道该怎麽着手。历史系教授看我写的鲁迅草稿，觉得写得太差了。而东亚系觉得我是搞历史的，不是搞文学的。最后历史系主任 说，你赶快打电话求职吧，普林斯顿留不住你了。我当时傻眼了。那时候我有个女朋友，本来准备结婚了。她第一个反应是，“天哪！怎麽办？”本来我们连傢俱都 买好了，房子都找到了，可她马上离开了我。</p>

<p><strong>在这种最绝望的关头，我才知道，失败的滋味是什麽。失败的滋味，有几方面可以看得很清楚。当你在校园裡走的时候，有些跟你不熟的同事，见了面不打招呼了，因 为你是一个失败者。美国人的价值裡，LOSER（失败者）是很糟糕的。我后来反省，也许他们有道理，他们正好打中了我的弱点。我的心其实不在经济史，不在 制度史，我的心还是在文学。</strong></p>

<p>最后，两个朋友救了我。一个朋友为我在当时的一个女校找了一个职位，说我教什麽都可以。另一个职位是在印第安那大学教中国古典文学。当时系主任临时找的一个 教授不去了，本来是让他教元杂剧。于是系主任问我，能不能教元杂剧。其实我只看过一本元杂剧，叫《窦娥冤》，其他都没有看过。不过我还是说，可以。</p>

<p>当人受到极大挫折后，基本的感受就是要“生存”。我当时没有钱回去，无颜见江东父老。这麽多年在美国，怎麽能以失败收场呢？</p>

<p><strong>置之死地而后生，</strong>我接受了这个职位。可没想到，我在印第安那大学如鱼得水，因为这个大学的音乐系是全美最大的。学校有四个交响乐团，一个歌剧院，有无数个免费音乐会。我一直喜欢音乐，觉得这裡真是天堂。音乐使得我在教学学术研究上精力百倍。</p>

<p><strong>我精力百倍，只是为了争一口气。</strong>这口气不是为了我自己，这就是讲<strong>失败的价值——要为一个理想，一个有意义的而不是乱七八糟的目的。</strong>我当时觉得，美国汉学界不顾现代文学是没有道理的。他们认为，中国20世纪文学都是宣传都是政治，那我说，如果这样，鲁迅难道只是一个政客吗？</p>

<p>我不服气。可是在美国，你要把一个学科带上来，不像在华人地区这麽容易，一切都要从头做起。于是我出版了二三十本中国现代文学翻译和研究系列。没有想到，我 写的教材还没有出，已经使我在美国现代文学研究界小有名气了。因为大家要找教科书，就是找印第安那大学出版社的那本，一看就有我的名字在上面。</p>

<p>这麽多年失败的经验让我知道，我在中国现代文学研究上的成功，一方面是侥倖，一方面是所谓“天时地利人和”凑合在一起。</p>

<p>人在一个漫长的过程中会开始反省，什麽是成功什麽是失败。有一样金科玉律免不了：没有一连串的挫折和失败，你的成功都是虚的。我没有看过一个马上成功的例子，即使有，那个成功的人到了晚年也会感到空虚的。</p>

<p><strong>爱尔兰剧作家、现代主义荒谬剧大师萨缪尔•贝克说过一句话：再试一次，再失败一次，失败得好一点。</strong></p>

<p><strong>当你发现越失败越好的时候，你就成功了，这是我得到的一个教训。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转载]程序员常见的健康问题]]></title>
    <link href="http://liuyix.org/blog/2012/common-programmer-health-problem-chiness-version/"/>
    <updated>2012-05-12T05:11:12+08:00</updated>
    <id>http://liuyix.org/blog/2012/common-programmer-health-problem-chiness-version</id>
    <content type="html"><![CDATA[<blockquote><p>再战隼的博客上看到的，正巧这几日正受颈椎病的困扰 :&ndash;( 真的还算及时，在此提醒下所有战斗在代码一线的斗士们，注意身体，养成锻炼的好习惯！</p></blockquote>

<p><a href="http://www.read.org.cn/html/1926-cheng-xu-yuan-de-chang-jian-jian-kang-wen-ti.html">原文链接</a>via<a href="http://www.read.org.cn/">战隼的学习探索</a></p>

<p>其实这些问题不仅见于程序员，其他长期经常坐在电脑前的职场人士（比如：网络编辑、站长等），都会有其中的某些健康问题。希望从事这些行业的朋友，对自己的健康问题，予以重视。以下是全文。</p>

<p>我最近在写《Learn Python The Hard Way》的最后几节课，我还要加一课：关于程序员在其职业生涯中普遍的健康问题。我发现诸多代码人在敲代码的时候好像不在乎他们的身体状况， 很可能是太过于全神贯注。我希望人们可以通过知晓一些与程序员相关的健康问题而获益，并可以避免曾经发生在我身上，而且就我知道也发生在很多人身上的问题。</p>

<p>我可能不会把这篇博文全部放进该书里，因为有点多。但我会写个缩减版。请您惠知喜好，或有我可以引用的附加资源。<!-- more --></p>

<h3><strong>我的背景和资历</strong></h3>

<p>我以前是一等合格美国士兵，并学习过多种武术。近年来我未像过去学武术一样奋力工作，而是专注于瑜伽、入定和一些简单的活动。我小时候是异常健康的，现在依然如故，这归功于我早已根深蒂固的锻炼习惯。</p>

<p><img src="http://blog.jobbole.com/wp-content/uploads/vb/485-thumb_zed%20shaw.jpg" alt="zed shaw" /></p>

<p>首先先列一下我学过的武术：忍术（Ninjitsu），合气道（Aikido），柔术（Judo），泰拳（Muay Thai），咏春（Wing Tsung），卡波耶拉（Capoeira），阿尼斯（Arnis），其排序不分先后。我要讲只有泰拳我是连贯学习的，大概有六年时间。其他的用了一到两年时间。我去了很多地方，因此学习之道就是那儿有什么便学什么。</p>

<p>而且，在部队里我是体能测试优秀，几乎是连续两年满分通过的。如没记错，这其中有几乎每天两至四小时的训练，这在部队里不算什么。除此之外，别无他事可做。</p>

<p>然后，不论我干不干活，我如今一直保持着同样的体重、灵敏及力量。所以我无法告诉你怎么减肥。我很可能先天基因就是如此。这意味着你要根据自身情况来调整我的建议。</p>

<p>有着前述的体魄，当我渐老我更喜欢侵略性弱以及更灵活的一些运动。瑜伽是不错的，常被误认为很难。我同样把票投给普拉提（Pilates），游泳，舞蹈等一切对我身体无直接影响的运动。我尤其注意我的手，缘由我也会说到。</p>

<p>好，写这么多是让你知道我还有点能耐，但是更重要的是，在干这些的同时，我是一个职业编程者。在退役后，我平均每天学习八到十六个小时。 我使用盲打而且玩吉他，我还避免了腕道综合征，以及重复性劳损问题。</p>

<p>希望我保健的经验能帮你恢复或保持健康。</p>

<h3><strong>程序员的常见健康问题</strong></h3>

<p>编程乍一看是个耗人的领域，一方面似乎你没有做很多，另外和很多代码人对待其身体的态度有关。 你要一贯地保持健康，因为身体好时会减少对精神的摩擦损害，而将注意力集中到要事上，而不是你生理上的小毛病。</p>

<p>显然建议就是大多人说的饮食，外出活动。我这里不会教你怎么吃或健身，或者哪种武术。如你对这些感兴趣，找一个职业的来帮助你锻炼。</p>

<p>这里要说的程序员们平日的职业病。他们相当明显而且平常，由于某些原因他们并不在意这些本不该发生的事情：</p>

<p>▲ 腕部疼痛（重复性劳损）</p>

<p>▲ 盯着看移动的打印进度以及其后的句点造成的眼部问题</p>

<p>▲ 姿势不当造成的背部不适，尤其是背下侧，肩上侧。</p>

<p>▲ 肠道和尿道的问题（不能正常大小便）</p>

<p>▲ 摄入太多咖啡因，而且喝水少造成的脱水</p>

<p>▲ 坐姿保持太久，造成男性的痔疮或前列腺问题（我一会再细说）</p>

<p>▲ 光照不足造成维生素D缺乏</p>

<p>▲ 熬夜或者喝咖啡过多导致的睡眠失调</p>

<p>▲ 缺乏伸展导致普遍的僵硬和疼痛</p>

<p>我一直跟这些问题作抗争，因为编程，弹吉他，或者举重时误伤。每当我重获健康的时候，我就知道了此后怎样避免。只有一小部分问题是周期性的。你可能觉得这里的某些问题无关紧要，但请相信我，许多程序员都有这样那样的问题，且原因不一，即使你还没有。</p>

<h3><strong>普遍原因</strong></h3>

<p>一般来说，可以总结成嗜编程为命。你可能想成为个中翘楚，就像我一样，因此除了生活除了编程别无其他。你不去卫生间，你勇猛地进行10小时连续编程。而且你饮食不规，只神笃“真正的代码人”这一信条。</p>

<p>事实是真正的编程者都是有点傻蛋。他们从来吃不到正点，ML也没有准。跑步从来都气喘吁吁，他们的内脏有一些严重问题，但不是疾病原因。真的，在你精通某件事之前，灭了自己可不是很值。</p>

<p>所以，在你看到这些问题以及我怎么解决的时候，记住这都是为了有一个均衡的生活习惯，而不是沉溺于编码或者其他什么事。相信我你会实实在在地好起来，如果你给你自己减负并且保持健康。</p>

<h3>腕部疼痛</h3>

<p>这个可能是我用心最多的。因为频繁且长时间地编码、拨弦，我的腕部有着周期性的疼痛。那年我22岁，刚开始职业性地编码。但是我一直有一个合气道的功课，这样我的腕部就会恢复如初。</p>

<p>你知道，合气道有着绝佳的腕部练习，从而让你的腕部变得结实又柔软。他们创造的这些练习可以避免伤害，原本的许多技巧就有扭、撕扯、手臂和肩关节的脱节。</p>

<p>这些练习治好了我的所有关节错位和疼痛，并让我长时间编程且没有任何大问题。我唯一可能出现问题是因为我要把现在的键盘换成新的古怪布局的键盘，但如果我练习一周合气道我就有可以重返代码并依然强健。</p>

<p>现在如果你有严重的腕道综合征或者其他类型的重复性劳损问题，先咨询你的医师再行尝试这里的技巧。如你要做的话，开始时要轻慢，不要让你感到疼。伸展应该不会疼，只会轻度有点不适。如果你感觉疼，是过度拉伸了。.</p>

<p>你实际想每次伸展运动得到放松。这有点难解释，但不是强迫你的关节在某个固定位置，而是先到达一个位置，想一想放松而后再到更远的位置。</p>

<p>记住这一点，怎么做练习则有很多视频：</p>

<p>▲ 翻转手腕 （Youtube的视频，须翻墙）</p>

<p>▲ 扭腕</p>

<p>▲ 手腕外侧弯曲</p>

<p>▲ 手腕内侧弯曲</p>

<p>下面介绍当你坐下来打字的时候怎么去做锻炼（每次都要这样）：</p>

<ol>
<li><p>首先要热身，将手伸向前方在空中尽可能快速地抓20次。然后甩手，再做手腕单侧弯曲10次，然后换方向弯曲10次。</p></li>
<li><p>用你最擅长的，以中速做5至10次。</p></li>
<li><p>继续做各项动作，但甩手和甩胳膊，弯曲手腕后到要归位。这些动作会移动手腕中的骨头，甩的时候它们就会归位。</p></li>
<li><p>千万不要做过头，让你手腕感到损伤。要适度恰好，并放松。那个“没有付出就没有收获”只会伤害你。</p></li>
</ol>


<p>每次敲代码前做这系列动作，每天要做，而且停下来的时候也做一次。用不了多长时间，一段时间的不适之后你的手腕就会开始适应并回到正常，并感到好许多。</p>

<p>还有：在做这些之前先咨询一下医生。你做这些可是自己冒风险，所以自己不小心搞坏了手腕不要来起诉我。 这些是千年武术中的家常便饭，所以我知道它们不会有危险，但各人情况不同。如果你做法不对可能后果严重，如果感到疼痛立即停止并咨询医师。</p>

<h3><strong>吉他手更糟糕</strong></h3>

<p>在吉他手或贝司手跟前，程序员的重复性劳损可是小菜。这起因是诸多愚蠢的理由，许多著名的音乐家讲一天八小时或十六小时学习法。正因如此，吉他手们糟践自己，最后不能演奏。</p>

<p>吉他对于手来讲是硬乐器，所以有一点点疼痛你就歇菜了。我在学校的时候，像个傻比一样轻信我的老师自己一天练八个小时的琴。我字面理解就是一下子就八个小时，我这样折磨自己一个月然后就崩了。</p>

<p>我的拇指有了赘骨，其他的指头疼痛难止。我的手腕还耐得住，但指头已经不行了。 二逼呵呵的我没有听那句话，任何新的运动需要循序渐进。</p>

<p>我解决这个的唯一办法，而且用了一年半，是做以下的事情：</p>

<ol>
<li><p>找把不伤手的吉他。说你啥样吉他都能玩是屁话。去找个最好的不伤你手的吉他。</p></li>
<li><p>做上面的锻炼，我的指头做得更多。</p></li>
<li><p>通过做练习，慢慢开始恢复指头的力度并注意放松。</p></li>
<li><p>在弹的时候注意放松，拨弦的时候更轻巧。</p></li>
<li><p>避免弯曲，这些曾导致我的手受伤。</p></li>
<li><p>变换姿势和演奏风格，不抓紧吉他就能快速移动，舒服地把拇指压在琴颈背面。</p></li>
<li><p>调整吉他高度，让我的肩和手都觉得舒服。</p></li>
<li><p>站着，很少长时间坐下，长时间摆一个姿势是很别扭的。</p></li>
</ol>


<p>去年做完这些后我的手最终痊愈了，并且感觉良好。我还没有不让我弄伤自己的好习惯。我已经老大不小了，所以这些对我很重要，但这也意味着我不能做那些可能弄伤我手的活计。</p>

<p>我的手现在是我的命根子，所以不能再打拳了，或者其他我还想学习的事情。因为打沙袋我手上已经有多处凹陷了。</p>

<h3><strong>眼疲劳</strong></h3>

<p>我觉得这对我不是问题，但你最好悠着点。我年轻的时候比20/20还要好，但用了几十年电脑有点偏了，曾经用过眼镜矫正，我用得着的时候一直戴着，没有它们看周围的世界真是恼人的模糊。</p>

<p>在黑暗时期，我们天天还瞅的是CRT显示器，烦人的闪烁已经把一些人的眼睛整垮了。现在的问题是多数LCD屏幕对字体的糟糕渲染。 我想归功于苹果公司的专利，多数LCD屏都不能正常渲染字体。尽管有人认为苹果的字体看起来毛茸茸的，所以对于你的好处将很难说。</p>

<p>我想每天两个小时不看电脑。要么我去玩吉他不用费眼力，要么去公园散步。我可能不是整整两个小时都去这样干，但是加起来要保持两个小时。</p>

<p>这对于你可能有的头痛有助益。多数时候程序员可能会想玩电脑的时候开着灯导致了头痛，但其实是因为体位不对，还有糟糕的字体，饮水不足，而且是跟电脑打持久战。</p>

<p>不是把你房间的灯都关掉，只需要合理的照明，选择适合你液晶屏和室内灯光的色彩方案。 即融合室内照明，液晶屏亮度和字体，以及让你感觉更舒服的色彩方案。</p>

<p>但还是先休息一下吧。</p>

<h3><strong>背部问题</strong></h3>

<p>我挺走运的，背一直还可以。尽管如此，我相当多时间是坐办公室，并保持着灵活强健的脊背。</p>

<p>我的问题是背的上半部分，脖子，肩部。我习惯猫在键盘上，所以必须强迫自己坐直。事实是，刚刚敲这段话的时候我就没坐直，才想起矫正一下。</p>

<p>现在选择你的座椅很重要，我喜欢艾伦椅（Aeron），那种硬质小凳子或长凳。现在非常热衷我的40美元的钢琴凳，过去我坐着它弹钢琴的。因为没有后背，凳子会时时逼迫你坐端正 ，并调用我的核心肌肉（肚子和背部）。</p>

<p>我的肩部完全处于压/迫状态。我习惯于在我全神贯注的时候收紧双肩，这样让我的整个背上部感到疼痛，一直蔓延到脖子和头部。当我长时间玩吉他的时候问题更糟。</p>

<p>我发现最有效的解决办法是伸展上肢，做俯卧撑。伸展办法很简单，抓住门框，然后双臂同向或反向拉伸。你觉得身体有点僵硬的时候试试下面这些招数：</p>

<ol>
<li><p>用一只手抓紧门框，手心朝向你的身体，然后向前挺胸，越过肩位。</p></li>
<li><p>用另一只手握紧门框，胳膊交叉在前，手心继续朝里，然后伸展肩部，使背部得到伸展。</p></li>
<li><p>两只手都抓住门框，高举过头，稍向后站呈倾斜，然后来回拉伸。（就像站着做俯卧撑）</p></li>
</ol>


<p>如果你做了，同时做抡臂，摇摆，你就会觉得好一些。或许在你开始干活之前加一些腕部伸展。</p>

<p>另外就是做真正的俯卧撑了。我工作的时候并不做这个，因为它会让你很累，难于工作。在睡前我做十次，这十下足以对付胸、背、肩、腕。 不要过快，要慢，注意在做的时候使身体平衡。</p>

<h3><strong>脱水</strong></h3>

<p>这个问题不大，我时常有点内疚。我发现我一天狂喝咖啡，正因为这样我想我也该喝点水。如果我没有头疼那倒有点不对。脱水的问题很难发觉，直到你发现的时候已经晚了。</p>

<p>我的建议（我也要多做的）是，喝其他非纯净水的饮料时也喝一杯水。同样请勿喝苏打水。它们只是一堆伪糖，让你变胖导致糖尿病，还有它并没有给你产生水。喝纯黑咖啡吧，它们真他妈好，记着再喝些水。</p>

<h3><strong>肠道及尿道问题</strong></h3>

<p>好吧，接下来的两个问题确实不雅，所以就不提发生在我身上的事了，但我要说这句话：“<strong>上厕所的时候他妈赶紧去，别犹豫。</strong>”</p>

<p>你不知道这条提示有多有用，我真希望我年轻的时候知道这句话。因为我是一个拼命汉从不间断，跳过上厕所，憋相当长时间。 肠道问题就是你的机体不再告诉你你该拉屎了，只是愈积愈多。</p>

<p>这样的话最后会导致便秘，这将终结你的健康状态。对于尿道倒次要，但是你依然可能会有感染和其他令你惊奇的事情。</p>

<p>如果你已经搞砸了，你去弄一些纤维片，待在家里然后吃掉，不要去外面，因为后果很囧的。</p>

<p>然后，你觉得是时候了，拾起身去拥抱上帝吧。我告诉你，在你拉完屎之后你的伟大想法才会自然迸发。</p>

<h3><strong>痔疮和前列腺问题</strong></h3>

<p>另外一个不上厕所会导致的就是痔疮。我知道够恶心的，我保证只提这一次。但是，许多编程者有这个问题，并羞于启齿，他们并不知道为什么。下面听我一一道来，我做过下述所有事情，但是只得过一两次痔疮：</p>

<ol>
<li><p>长时间坐着。</p></li>
<li><p>举重东西，不用辅助。</p></li>
<li><p>该去解决内急的时候不去。</p></li>
<li><p>强迫自己去拉屎，实际上不需要。</p></li>
<li><p>最糟糕的：坐在厕所里看书。</p></li>
</ol>


<p>最后一条就是罪魁祸首。如果你不是必须要大C，可别老泡在那。这相当于将你整个身体和肠子的重量压进已经泻完的直肠上，并试图挤出来。恶心至极！这导致痔疮因为你的血管中的血压不自然地升高。</p>

<p>确实臭哄哄的，但潜在危害很大。恩，危急情形是血流一地，这时候谁都知道去看大夫。你可能需要手术，但做无妨。我没有做但也差点：有一年我在举重，然后在库房工作，不间断编程，没有用过厕所。</p>

<p>是，我是个大笨蛋。你可别学我。为了你的屁屁的健康，请做以下的事：</p>

<ol>
<li><p>多吃果蔬，至少吃点纤维片。</p></li>
<li><p>该解决个人问题时赶紧的！</p></li>
<li><p>任何情况下不要压/迫直肠。</p></li>
</ol>


<p>还有一个导致前列腺的问题，如果整天坐在屁股上的话。站起来转转就可以。如果尿血或者排尿困难，去看医生，否则会更危险。</p>

<h3><strong>维生素D不足</strong></h3>

<p>维生素D有点怪。的确只能通过晒太阳产生，但你并不必去专门为此去暴露在阳光下。5到30分钟就好，取决于光照的强度。还与你的钙水平和磷缺乏程度有关。但你要是饮食规律，并非只吃些薯片的话，就问题不大。</p>

<p>还有一些事比如消沉，搞坏的牙齿，一些奇怪部位的疼痛比如臂肘的骨头，肌肉痉挛，总体来讲就是跟烂泥一样。同样，如果你觉得不行的话去看医生，正常情况下在日头正盛的时候，去外面溜达半个小时足矣。</p>

<p>事实上，我觉得一个问题是硅谷里很多刚起步公司提供的餐饮。因为你要泡在办公室，经常吃残汤剩饭，而且照明也不好，太阳高照的时候你也不出去晒下。加上你的睡眠习惯你的维生素D状况就糟糕透了。</p>

<p>不要吃盒饭，在中午去外面吃一顿。好处你自知，而且外面的食物好多了。</p>

<p>我在温哥华和西雅图的时候有轻微的维生素D缺乏，那儿光照不足，对于我来说简直要我命。有人能搞定，但是像我这样青年时代在热带岛屿上度过的人，不足的光照确实就是杀手。</p>

<p>所以，你趁有太阳的时候出去晒晒。</p>

<h3><strong>睡眠失调</strong></h3>

<p>我的睡眠时间一向很灵活，跟季节和地域有关。有时候我如猫头鹰附体，熬夜熬到很晚才睡。最近搬到旧金山后开始早睡，不再晚睡了，最近感觉很好。</p>

<p>有时候，我不确定为何在夜里创作音乐或编程倒多产。我认为在一个疲惫的状态下我的大脑确是在休息的。我还觉得是因为夜里更安静，没有滋扰。</p>

<p>不管怎样，早睡晚睡已经把我的睡眠机制搞砸了。当我渐长我更喜欢早起，我觉得白天更清醒更放松。熬夜后再睡往往觉得自己有遗留反应，而且头疼。</p>

<p>如果你也有睡眠问题，我有一些简单的调适方法助你入睡。需要实践，但很有效。</p>

<p>首先，花你的血本买个好床，2000+美元不算多。我买了2200块的Tempur-Pedic。 的确很值。</p>

<p>有了床，开始练习助睡法，有点自我催眠的意味：</p>

<ol>
<li><p>关掉你房内的所有灯光和音响。</p></li>
<li><p>躺下，让手放在让你舒服的位置。</p></li>
<li><p>缓慢地深呼吸，并想象空气流进身体及逸散出体外的场景。</p></li>
<li><p>当你能注意到你的呼吸之时，想象你在看窗外辽阔的太空，悬星满布。</p></li>
<li><p>然后伴随呼吸幻想自己漂浮在空中，渐入巨幅的星系，一切星辰，皆伴随你左右。</p></li>
<li><p>持续幻想，感觉你的床也在漂浮，直到皆不见。</p></li>
</ol>


<p>你或许在四五点睡觉，但不是要出去的话，就幻想自己漂浮直到你真感觉融化了。</p>

<p>如果你有重度失眠，还请咨询医师。但还是试下这招，一天做一到两个小时。练习后绝对会让你入睡。</p>

<h3><strong>刚柔并济</strong></h3>

<p>如果浑身不适难于活动，这时就该做下伸展运动。当然最好莫过于去瑜伽馆每周做练习，并回家自己练习。如果没有时间，可以买书或在图书馆借N多教程。入门级就可以，你真的不需要太多。</p>

<p>我想如果你晚上入睡前做5-6个大幅的伸展练习就够了。你会觉得相当放松，你的健康状况和自我感觉也会有提升。</p>

<p>伸展身体的时候同样要放松大脑，增长创造性的一大妙法就是做瑜伽或半个小时的伸展运动，然后早晨冲澡。 伴随禅定你就会精神自适并发觉个中未曾体验之奥妙。</p>

<p>我也不知为何，但是精神之松弛对于突发的灵感多有助益。</p>

<h3><strong>迈出第一步</strong></h3>

<p>上面的内容可能对于你有点多，我当然希望你不会都有这些问题缠身。然而我建议，尽管你可能没有那些毛病，但要避免它们的发生。如果你要开始编码，请采用“编前热身”。</p>

<p>下面就是我在敲代码前要干的，或者玩吉他前，以及我变僵需要休息的时候。</p>

<ol>
<li><p>活动身体各关节，只需将腕、臂、颈、臀转摇几下。比如正向五次，然后反向五次。</p></li>
<li><p>在各部分前做一些腕部练习，摇一下手腕。</p></li>
<li><p>将臂举过头顶尽可能高，然后向后伸展尽可能远，然后伸到身体前面来。</p></li>
<li><p>最后，小心地用手扶着头分别向右、左、前、后摇几下。</p></li>
</ol>


<p>如果你做这些的话，将避免一些编程会带来的伤害。因为编程并不会大伤体能，避免受伤还是很容易的，因此上述部分就够了。</p>

<p>然而，如果有特殊问题的话，继续去咨询医疗师，如果得到他们允许可以试试我的这些方法。我这儿说的无过激或奇异的方法，只是些基本的练习和一些常识，因此是个医生都会许可的。我告诉你要咨询别人是只是因为我不想吃官司。</p>

<p>真希望这些能让你变好，如果没有的话，记下建议，以防出现这些状况。如果你够好运，连一个问题都不会有，但我觉得是个程序员都有或多或少的问题。</p>

<p>如果对上述的事情持有疑问，可以给我发邮件，我会给你一些建议。</p>

<p>保重。</p>

<p><strong>作者Zed Shaws</strong>是一位作家、软件开发人员、音乐人（下文中提到吉他手），于2010年发布《Learn Python The Hard Way》一书，他也是 Mongrel Web 服务器系统的作者之一。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个简单的python小程序——使用douban API通过ISBN查询书籍信息]]></title>
    <link href="http://liuyix.org/blog/2012/a-simple-python-prog-with-douban-api/"/>
    <updated>2012-03-11T07:52:00+08:00</updated>
    <id>http://liuyix.org/blog/2012/a-simple-python-prog-with-douban-api</id>
    <content type="html"><![CDATA[<p>刚学python时做的一个小程序，虽然小，但是也用到了不少内容。具体有以下几个方面：</p>

<ul>
<li>命令行的解析</li>
<li>文件的读写</li>
<li>XML解析</li>
<li>http连接</li>
<li>多线程</li>
</ul>


<p>短短不到200行的程序就可以做到这些，可以算是python的推广广告吧，哈哈</p>

<script src="https://gist.github.com/liuyix/6738920.js"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eclipse下配置NDK开发环境小结]]></title>
    <link href="http://liuyix.org/blog/2012/android-ndk-eclipse-configuration/"/>
    <updated>2012-03-11T06:11:00+08:00</updated>
    <id>http://liuyix.org/blog/2012/android-ndk-eclipse-configuration</id>
    <content type="html"><![CDATA[<p>分享下最近几周我的一些NDK开发经验和心得。</p>

<p>Eclipse配置NDK环境，主要完成的功能使能调用Android NDK提供的工具链编译用C/C++源代码写好的共享库或者可执行的应用程序。由于我的工作需要的基本是完全native程序的编写，因此这里介绍的方法 <strong>更适合编译Android下的本地应用程序或者共享库</strong></p>

<p>本文提供的方法皆非原创，在这里感谢原创作者的分享。</p>

<h2>NDK环境配置之前</h2>

<p>Eclipse需要事先安装好 <strong>CDT</strong> ，本文在Ubuntu平台上测试可用。</p>

<h2>最简单有效的方法————创建新的Builder</h2>

<p>本方法是在Eclipse中调用NDK提供的 <code>ndk-build</code> 命令进行编译。综合这几周的开发，感觉还是这个方法是最靠谱的。因为你只需要编写一个Android.mk，无需考虑依赖关系，同时也最大程度的遵循了google提供的NDK build方法。</p>

<h3>具体配置步骤</h3>

<ul>
<li><p>新建一个C++ Project</p></li>
<li><p>进入到这个project的 <strong>Propertities</strong> 选项中</p></li>
<li><p><strong>Builders</strong> 一栏 –> <strong>New</strong> –> <strong>Program</strong></p></li>
<li><p>参考下面这张图进行配置，几个重要的地方：</p>

<ul>
<li><p><strong>Location</strong> 填入 <code>$NDK_HOME</code> /ndk-build 其中 <code>$NDK_BUILD</code> 是NDK安装的根目录</p></li>
<li><p><strong>Working Directory</strong> 填入当前project的位置，可以通过选择 <strong>Browse Workspace…</strong> 选择</p></li>
<li><p>可选步骤： <strong>Arguments</strong> 中写下需要传给ndk-build的参数</p></li>
<li><p>如果要实现 <em>auto-build</em> 可以在 <strong>Refresh</strong> 和 <strong>Build Options</strong> 中进行配置，我个人觉得auto-build对开发没有实际作用，因此这里就不介绍了。</p></li>
</ul>
</li>
</ul>


<p>简单几步就可以编译共享库了，够简单吧</p>

<h2>参考链接</h2>

<p><a href="http://mobilepearls.com/labs/ndk-builder-in-eclipse/">Setting up Automatic NDK Builds in Eclipse</a></p>

<h2>其他方法</h2>

<p>这里还有一种我试验可用的方法，但是配置起来实在麻烦，适合移植已有程序或者开发大型项目时完全定制编译过程中使用。这里只给出出处，有兴趣的同学可以看看。</p>

<ul>
<li><a href="http://www.srombauts.fr/2011/03/06/standalone-toolchain/">http://www.srombauts.fr/2011/03/06/standalone-toolchain/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]初次参与开源软件项目的六个忠告]]></title>
    <link href="http://liuyix.org/blog/2012/6-easy-ways-to-get-started-programming-open-source-chn/"/>
    <updated>2012-03-11T06:00:00+08:00</updated>
    <id>http://liuyix.org/blog/2012/6-easy-ways-to-get-started-programming-open-source-chn</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://grokcode.com/108/6-easy-ways-to-get-started-programming-open-source">http://grokcode.com/108/6-easy-ways-to-get-started-programming-open-source</a></p>

<p>开源项目是一种好的释放自己的热情(&ldquo;geek out&rdquo;?)和做自己喜爱的事情的方式。有一个自己参与的开源项目可以使你的工作做起来更加快乐和满足，也会使你保持良好的编程水平，也会经常给你带来其他机遇。许多人不知道从何出入手向开源项目贡献自己的力量。以下是接触参与开源项目的六个简单的忠告。</p>

<h2>参与到平时使用的开源软件的项目之中(言外之意是不要鲁莽的参与到你不使用或者不了解的开源项目中)</h2>

<p>这一条很明显，但是记得不要尝试参与到你不使用或者你一无所知的项目中去。给你平时使用的，你也许愿意投入贡献的开源软件列一张清单。别忘了还有你使用的开源类库、开源模块也可以考虑投入贡献，记得参与到一个有许多开发者使用的开源项目有更多的益处。你使用框架吗、文件转换工具、图形类库或者一般开源软件需要使用的构建工具吗，或者一个新功能？以上这些都是你第一次参与开源项目的首选。</p>

<h2>Do What You Love 做你真正感兴趣的部分</h2>

<p>记得要找一个你 <strong>真正</strong> 感兴趣的部分做出你的贡献。比如说你对解析器情有独钟，那么一个编译器项目就不是第一次参与的项目首选。也许可以考虑一个webserver项目或者构建工具项目中的解析配置文件模块。</p>

<h2>掌握开源软件中常用的工具</h2>

<p>对于每个开源项目，版本控制系统、bug追踪系统、patch提交系统，有自己的代码规范，feature request，问题排查系统(user troubleshooting issues)以及构建工具和开发者讨论社区，这些都会有所差异。因此你应该花些时间学习熟悉这个项目使用的工具。一些常识，例如不该在开发者邮件列表里询问如何使用SVN;不该在用户论坛里提交bug，这些都该知道。认真阅读开发文档，学习使用上述的工具不仅可以节省大家的时间也会提高你所做的贡献被接受的可能。</p>

<h2>观察了解项目的人际圈子</h2>

<p>除了认真考虑技术，了解项目中的社交圈子也很重要。你该知道哪些人是核心开发人员(core maintainer)，这些核心开发者是如何与他人交流的，在开发社区中哪些人更活跃，他们为项目制定了那些规则。对于新的贡献者，有些项目会很开放和热心帮助，而有些项目则不大友好。记得要多在邮件列表、IRC或者其他开发者交流渠道上花时间观察，熟悉项目开发的交流氛围。 也许你认为开发者社区的交流互动不很重要，但是这却是成为一个成功的贡献者还是沮丧的离开的差异所在。回忆器我第一次尝试贡献开源项目时，我想改善一个音乐播放器程序的播放列表格式，因为这个音乐播放器程序在命令行下指定播放列表时，它不支持所有可用的格式。由于我的歌曲文件名字超出了Linux内核支持的命令行参数的字符上限，因此我没有办法将所有的音乐放入播放列表中。于是我在邮件列表中发了封邮件询问开发组他们是否考虑支持新的播放列表格式。于是立即引起了一场争论。当我第二天查看邮件列表时，我看到了上百个回复，一些人表示支持，一些人说现在的已有格式已经很好，还有些人问道这是哪来的新人。于是整个事情由回应问题变成了争论。 我当时犯的错误就是没有足够了解项目的社交圈。查看下邮件列表的存档，你才会发现有些项目只对一小撮核心贡献者开放，而对大多数人尤其是那些连一个bugfix都没提交过的人一点都不理会的。因此这就引出了我要谈到的下一条也是最重要的一条忠告——从小处入手</p>

<h2>从小处入手</h2>

<p>从小处入手有两方面含义，一是小的贡献，二是规模小的项目。提交一些小的bugfix或者实现一个简单的feature可以帮助你提高社区中的声望，同时也会使你熟悉项目中的提交流程。这两个方面都灰是你的补丁被接受的可能性大大提高。 一个规模小的项目中，你的贡献会更富有成效，因为熟悉提交流程和工具链会更快，你还能和核心开发者有更好的沟通。一个只有一个维护者的项目，提交一个bugfix补丁通常和邮寄一封附有diff文件和问题描述信息的邮件给维护者一样简单。</p>

<h2>开始自己的开源项目</h2>

<p>开始接触开源项目的一个最简单的方法就是建立自己的开源项目。写一个firefox插件、一个wordpress插件或者一个emacs mode都是不错的想法，既可以快速写就，通常还会赢得不少用户的肯定。 不过在你创建自己的项目之前，记得一定要好好查查，确保你的工作没有人在做。你也许会惊喜的发现有许多项目只需要一点点关注就会使这些项目变得更有价值。</p>

<p>以上就是6条初次参与开源软件项目的忠告。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[域名邮件不再被spam——SPF记录设置]]></title>
    <link href="http://liuyix.org/blog/2012/howto-add-spf-record-for-domain/"/>
    <updated>2012-02-26T00:26:17+08:00</updated>
    <id>http://liuyix.org/blog/2012/howto-add-spf-record-for-domain</id>
    <content type="html"><![CDATA[<p>一直使用的是QQ提供的<a href="http://domain.mail.qq.com/">域名邮箱</a>功能，很不错。本文旨在教你如何设置SPF记录防止自己域名的邮件被标记为spam。</p>

<h2>什么是SPF记录</h2>

<p>参考wiki：<a href="http://en.wikipedia.org/wiki/Sender_Policy_Framework">http://en.wikipedia.org/wiki/Sender_Policy_Framework</a></p>

<p>SPF是<strong>Sender Policy Framework</strong>的简称，是一种email验证系统，旨在通过检测email proofing，验证发送者IP地址的方法来杜绝垃圾邮件的方法。</p>

<blockquote><p>接收邮件方会首先检查域名的SPF记录，来确定发件人的IP地址是否被包含在SPF记录里面，如果在，就认为是一封正确的邮件，否则会认为是一封伪造的邮件进行退回。</p></blockquote>

<h2>设置过程</h2>

<p>本文以DNSPod为例展示QQ域名邮箱的SPF设置过程。</p>

<ol>
<li><p> 进入DNSPod制定域名的管理界面</p></li>
<li><p> “添加记录”，填入如下内容：</p>

<p>v=spf1 include:spf.mail.qq.com ~all</p></li>
<li><p> 最后点击保存即可</p></li>
</ol>

]]></content>
  </entry>
  
</feed>
