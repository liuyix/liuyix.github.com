<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[刘毅同学]]></title>
  <link href="http://liuyix.org/atom.xml" rel="self"/>
  <link href="http://liuyix.org/"/>
  <updated>2016-07-10T23:13:24+08:00</updated>
  <id>http://liuyix.org/</id>
  <author>
    <name><![CDATA[liuyix]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Yield小结]]></title>
    <link href="http://liuyix.org/blog/2016/python-yield/"/>
    <updated>2016-07-10T21:51:00+08:00</updated>
    <id>http://liuyix.org/blog/2016/python-yield</id>
    <content type="html"><![CDATA[<p><code>yield</code> 是用来简化以下场景：函数来生成序列，并且使用遍历的方式来访问序列中的元素。</p>

<p><code>yield</code>的实现原理理解上来说在调用<code>yield</code>时Python会保留函数的<em>现场</em>，当再次遍历时函数的状态不丢失，可以继续生成。</p>

<h3>经典的例子斐波那契数列</h3>

<h4>问题描述</h4>

<p>返回斐波那契数列前n个元素</p>

<h4>Python解法</h4>

<h5>第一个版本：朴素实现</h5>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">fab</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class='line'>    <span class="n">fab_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span><span class='line'>    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
</span><span class='line'>    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
</span><span class='line'>        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
</span><span class='line'>        <span class="n">fab_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'>        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">fab_list</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个版本是遍历并保存所有前n项斐波那契数列的元素。最大的问题是会占用非常多的内存，当调用fab(10000)时，在我的电脑中已经是无法完成的了。</p>

<h5>第二个版本: 简单的迭代器实现</h5>

<p>实现一个迭代器类</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">Fab</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="bp">self</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
</span><span class='line'>            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">r</span>
</span><span class='line'>        <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Fab</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="n">i</span>
</span></code></pre></td></tr></table></div></figure>


<p>第二个版本实现了迭代器，每次调用时再生成下一个元素，因此对内存的占用是恒定值。但缺点是代码很长，不够易读。</p>

<h5>第三个版本：yield方法</h5>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">fab</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class='line'>    <span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
</span><span class='line'>    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
</span><span class='line'>        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
</span><span class='line'>        <span class="k">yield</span> <span class="n">a</span>
</span><span class='line'>        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">fab</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="n">n</span>
</span><span class='line'>    <span class="k">print</span> <span class="n">fab</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>第三种yield方法兼具了第一种的简洁，第二种的高效。</p>

<p><code>fab(5)</code>返回的是一个<a href="https://wiki.python.org/moin/Generators"><code>generator</code></a>对象——让一个函数像iterator那样工作，这样在遍历的场景下既可以保持代码简洁，又保持了内存使用的高效。</p>

<h4>相关介绍链接</h4>

<ol>
<li><a href="http://jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained">Improve Your Python: &lsquo;yield&rsquo; and Generators Explained</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/">Python yield 使用浅析</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python流式压缩和解压缩调研总结]]></title>
    <link href="http://liuyix.org/blog/2015/python-compress-stream/"/>
    <updated>2015-12-26T22:52:00+08:00</updated>
    <id>http://liuyix.org/blog/2015/python-compress-stream</id>
    <content type="html"><![CDATA[<h3>Changelog</h3>

<table>
<thead>
<tr>
<th></th>
<th>  Time </th>
<th> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> 2016-01-05 </td>
<td> 小幅修改</td>
</tr>
<tr>
<td></td>
<td> 2015-12-26 </td>
<td> initial version</td>
</tr>
</tbody>
</table>


<p>最近两周在研究和实现了xtrabackup流式压缩上传&amp;下方案，这里做一下总结分享。</p>

<p>实现的效果是备份不在本地暂存，压缩内置到上传逻辑中，通过配置文件可以配置压缩细节，对上传使用者来讲是『无感知』的。利用压缩提高了上传效率和备份空间的使用率。</p>

<h2>压缩率和压缩性能的比较</h2>

<ul>
<li>lz4</li>
<li>gzip/pigz</li>
<li>lzop</li>
<li>qpress</li>
</ul>


<p>结论：在兼顾压缩率和压缩占用CPU资源以及压缩效率几个方面，最终选择了lzop。</p>

<p>lz4据说是压缩最快的算法，最终没有选择，有几个方面的原因：</p>

<ul>
<li>Python支持不完善，因为我的需求是<strong>流式</strong>的上传和下载，压缩源是一个tar stream，和压缩后的文件不会落在本地，而是直接上传到远端。</li>
<li>可运维性不高：lzo文件没有找到和gzip, lzop这样的命令行工具可以一个命令来对一个完整的lz4文件管理。当调用<code>file a.lz4</code> 显示的文件是data，这样就无法确认这个文件到底是否正确了。</li>
</ul>


<p>gzip给力的地方：</p>

<ul>
<li>gzip是目前应用最为广泛的格式了，看过很多压缩率评测的文章，gzip压缩率十分给力，在compresslevel是7到9时，压缩比很给力。</li>
<li>Python也是在standard library中支持gzip的压缩和解压缩。</li>
</ul>


<p>gzip不够给力的地方：</p>

<ul>
<li>压缩速度慢，在高压缩率上很慢。但是compress level在2~3时，gzip无论是压缩比还是压缩效率上都很有竞争优势</li>
<li>Python标准库gzip压缩对stream支持不够，流式压缩期望的方法是：传入一个fileobj，返回一个fileobj。而Gzip模块直接用的话是不支持这种方式的。</li>
</ul>


<p>然而gzip不足点是可以弥补的。
首先是压缩速度上，默认gzip是不支持并行化的压缩，最多只能有单核的性能，这是压缩性能的瓶颈。但是gzip是有其他工具支持<strong>并行压缩的</strong> —— <code>pigz</code>就是并行压缩版本的gzip，测试结果显示pigz可以充分利用多核并行化的性能，让压缩时间有明显的减少，当然代价就是load也会成倍的增长（24核机器上，我只测试了2~8个线程数）</p>

<p>其次是流式压缩可以通过Python轻松实现数据分块并行压缩。这里很重要的一点是：<strong>可以将每个数据分块看做一个独立文件压缩最终可以合成一个符合Gzip格式的压缩文件</strong>
简单的看了下的pigz的代码注释，发现pigz的原理也是这样子的。Python中使用生产者和消费者模式（生产者：一个线程专门来从数据源拉数据，数据存入Queue中，多个压缩进程负责压缩，把压缩后数据再放入到PriorityQueue按顺序组合成一个文件即可，当然也可以直接分块上传到远端服务器）。这也是我实现的第一个版本的流式压缩方案。这个方案主要的弱点在于内存资源占用比较大：无论是从数据源读取的原始数据块还是压缩后的压缩数据块，在最终写入/上传前都需要缓存在内存中。
在流式压缩上传的场景下，压缩上传的输出端是REST上传接口，因此并行压缩的内存占用上一定程度上受上传接口的性能影响。极端的情况，当上传速度很慢时，为了不影响压缩效率则需要在内存中开辟更大的内存buffer来放入等待压缩的数据块，这时就会占用到比较大的内存资源。不过也可以通过限制上传队列大小，在队列满的情况，数据源的<code>write</code>会阻塞等待。</p>

<p>我的第二个方案的是利用pigz外部工具在读取数据源前利用管道先接入到<code>pigz</code>，在从<code>pigz</code>直接读取到压缩后的数据流。这个方案算是最终方案的替代方案，之所以没有最终使用，原因在于和lzop相比，在压缩率相近的情况下，<code>pigz</code>消耗了更多的CPU资源。</p>

<p>对比方案：<code>pigz -p 2 -2</code> vs <code>lzop -c</code> ，即通过2线程压缩等级2和默认的lzop对比，前者压缩比可以高出10%，但是Load比后者高出了2倍不止，同时速度上也慢了25%。</p>

<p>lzop给力的地方：
实际测试中，lzop兼顾性能和压缩比同时压缩占用的CPU上是最平衡的。压缩速度稍慢于lz4，压缩比上可以达到gzip等级2~3的水平，同时cpu占用率和内存上比gzip低。</p>

<p>lzop不给力的地方：</p>

<ul>
<li>Python bindings 接口较少，不能直接用来流式压缩上传。

<ul>
<li>通过 <em>外挂</em> 方式也可以完成。（其实即使支持的好，也需要多进程来并行工作，和外挂差别不大）</li>
</ul>
</li>
</ul>


<h2>总结</h2>

<ul>
<li>lzop和pigz这两个压缩方案上在实际应用上都很有竞争力，只是我涉及的项目需求是生产环境上尽量不占用过多CPU，MEM资源，可以在压缩比上做妥协。因此选择了lzop。如果你在意CPU资源，更在乎压缩数据大小，则pigz是不错的选择。</li>
<li><em>外挂</em> 方式的数据压缩方案虽然集成上让Python程序有更多的外部依赖，但是考虑到Python本身并没有真正的线程的并行方案（你想要并行也要生成多个进程），其实资源占用区别不大。同时方案选型上也更加灵活。</li>
</ul>


<table>
<thead>
<tr>
<th></th>
<th> 压缩工具 </th>
<th> 描述 </th>
<th> 参数 </th>
<th> 优势 </th>
<th> 劣势 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> gzip </td>
<td> 最常用的压缩工具 </td>
<td> <code>-2</code> </td>
<td> 压缩比在压缩参数大于2时很高，平台上通用很高，所有Linux发行版都会有预装，同时tar也集成了gzip压缩 </td>
<td> 单线程，较慢</td>
</tr>
<tr>
<td></td>
<td> pigz </td>
<td> 多线程版gzip，<a href="http://zlib.net/pigz/">主页</a>, <a href="https://github.com/madler/pigz">github</a> </td>
<td> 多线程并行+gzip压缩算法，无论从性能上还是压缩输出上都很不错，是个很不错的选择 </td>
<td> 压缩效率和系统资源占用成正比</td>
<td></td>
</tr>
<tr>
<td></td>
<td> lzop </td>
<td> </td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python中的subprocess与Pipe]]></title>
    <link href="http://liuyix.org/blog/2015/python-subprocess-pitfalls/"/>
    <updated>2015-12-23T21:31:00+08:00</updated>
    <id>http://liuyix.org/blog/2015/python-subprocess-pitfalls</id>
    <content type="html"><![CDATA[<h2>一、纠结的困境</h2>

<p>Python在多进程上不是很令人满意，尤其是<code>subprocess</code>模块。当用Python实现一个shell脚本中的管道时就出现了比较尴尬的局面。</p>

<h3>大数据量的管道问题</h3>

<p>subprocess模块有两种方式来和生成的子进程交互：<code>wait</code>和<code>communicate</code>。
关于<code>wait</code>文档中有以下说明：</p>

<blockquote><p>Warning This will deadlock when using stdout=PIPE and/or stderr=PIPE and the child process generates enough output to a pipe such that it blocks waiting for the OS pipe buffer to accept more data. Use communicate() to avoid that.</p></blockquote>

<p>即当stdout/stdin设置为PIPE时，使用<code>wait()</code>可能会导致死锁。因而建议使用<code>communicate</code></p>

<p>而对于<code>communicate</code>，文档又给出：</p>

<blockquote><p>Note The data read is buffered in memory, so do not use this method if the data size is large or unlimited.</p></blockquote>

<p><code>communicate</code>会把数据读入内存缓存下来，所以当数据很大或者是无限的数据时不要使用。</p>

<p>那么问题来了：当你要使用Python的<code>subprocess.Popen</code>实现命令行之间的管道传输，同时数据源又非常大（比如读取上GB的文本或者无尽的网络流）时，官方文档不建议用<code>wait</code>，同时<code>communicate</code>还可能把内存撑爆&hellip; <img src="http://liuyix.org/images/1.jpg" alt="/images/1.jpg" /></p>

<h2>探究实现</h2>

<p>Python在系统编程领域可以理解为就是C语言的一种简写，因为无论是用C语言还是Python都是对系统Linux/Windows API的使用，只是相比于C，Python封装后由于是解释型语言而变得易于编写和调试。</p>

<p>在Python中subprocess是用来创建新的进程，同时创建管道连接子进程的stdout, stderr, stdin（可选）。然后执行子进程，最后得到子进程的return code。</p>

<blockquote><p>This module intends to replace several older modules and functions:
os.system
os.spawn<em>
os.popen</em>
popen2.<em>
commands.</em></p></blockquote>

<p>所以可以理解为Python意图用subprocess模块来统一之前若干生成子进程的方式。</p>

<p>关于subprocess的基础用法再次暂时略过，网上相关的内容很多，有时间再赘述。这里重点说一下shell多管道流对应的python实现。</p>

<h3>一个shell多管道脚本的改写</h3>

<p>shell编程领域，将cli工具结合强大的pipe，可以一行代码就能完成相对复杂的工作，尤其是在文本编辑上。如以下的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ps aux | egrep 'xtrabackup|innobackupex' | grep -v grep | awk '{print $2}' | xargs kill</span></code></pre></td></tr></table></div></figure>


<p>这是（我比较常用的）杀掉备份进程的一行命令。大致流程如下图所示。</p>

<p><img src="http://liuyix.org/images/0105-1.svg" alt="流程图" /></p>

<p>那么如果如何将上述代码转换为python脚本表达呢？</p>

<p>推荐的做法：分别生成subprocess子进程，同时用管道相连。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import subprocess
</span><span class='line'>import shlex
</span><span class='line'>ps_proc = subprocess.Popen(shlex.split('ps aux'), stdout=subprocess.PIPE)
</span><span class='line'>grep_proc = subprocess.Popen(shlex.split("egrep 'xtrabackup|innobackupex'"), stdin=ps_proc.stdout, stdout=subprocess.PIPE)
</span><span class='line'>awk_proc = subprocess.Popen(shlex.split('awk "{print $2}"'), stdin=grep_proc.stdout, stdout=subprocess.PIPE)
</span><span class='line'>kill_proc = subprocess.Popen(shlex.split('xargs kill'), stdin=awk_proc.stdout)</span></code></pre></td></tr></table></div></figure>


<p>每一个子进程的<code>stdin</code>都是上一个子进程的<code>stdout</code>，除最后一个子进程外其余进程的stdout参数都是<code>subprocess.PIPE</code>即管道输出，这样就首先了首尾相连。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quora每周摘选（第2期）]]></title>
    <link href="http://liuyix.org/blog/2015/my-quora-digest-issue-2/"/>
    <updated>2015-12-21T23:18:00+08:00</updated>
    <id>http://liuyix.org/blog/2015/my-quora-digest-issue-2</id>
    <content type="html"><![CDATA[<ul>
<li><a href="https://www.quora.com/Why-is-there-C++-but-no-C+/answer/Derek-Ross-9" target="_blank">C++名字的由来</a></li>
<li><a href="https://www.quora.com/Web-Developers/If-you-had-to-start-your-whole-career-over-again-what-would-you-do-knowing-what-you-know-now" target="_blank">Web Developers: If you had to start your whole career over again, what would you do knowing what you know now?</a> Web开发当你必须重新开始时，以你现在的经验你会做什么？</li>
<li><a href="http://qr.ae/RbEliB" target="_blank">How can you make people like you in 90 seconds or less?</a>

<ul>
<li>一个社交相关的问答：如果在90秒之内使他人对你有好的印象？</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python并发实用编程手册[Draft]]]></title>
    <link href="http://liuyix.org/blog/2015/python-concurrent-programming/"/>
    <updated>2015-12-17T07:08:00+08:00</updated>
    <id>http://liuyix.org/blog/2015/python-concurrent-programming</id>
    <content type="html"><![CDATA[<p>Python并发编程<del>常用的</del>builtin就是2个模块：<code>threading</code>和<code>multiprocessing</code>。其中<code>threading</code>因为著名的GIL，实际是<em>伪多线程</em>，每个thread并没有对应一个pthread；<code>multiprocessing</code>则是利用多进程的手段来绕过GIL达到并发的效果。</p>

<p>如果你的任务并非是CPU密集型，而是IO密集型或者网络应用的话——单线程时CPU总是处于等待的状态时，用threading其实影响不大。</p>

<!--more-->


<h2>threading</h2>

<p>Doc: <a href="https://docs.python.org/2/library/threading.html">https://docs.python.org/2/library/threading.html</a></p>

<h3>Thread</h3>

<p>和其他语言的线程创建类似，有两种方式创建线程的方式，一种是创建thread时传入要执行的工作方法，另外一种是创建<code>Thread</code>的子类。</p>

<h4>join</h4>

<p><code>join()</code> 方法提供了不同线程间的协同功能。通常的用法是主线程在创建完所有的工作线程后，循坏调用没有工作线程的<code>join()</code>方法来等待所有线程的结束。<code>join()</code>方法还可以增加<code>timeout</code>参数设置超时时间，可以用来避免一个工作线程出问题使得整个程序死等的情况。</p>

<h4>daemon</h4>

<p><code>daemon</code>是Thread的一个属性，程序退出不关心设置了<code>daemon</code>线程的『死活』。即只要所有非<code>daemon</code>线程都结束了，那么程序就可以结束掉了。
<code>daemon</code>线程类似于程序内部的『后台服务』，提供了程序运行时的『基础设施』，而不是程序工作流程链路中的部分。</p>

<h2>Lock, RLock</h2>

<p>并发编程中，锁是基本原语。当有共享资源需要『互斥』访问时就要用锁来对这些资源进行保护。<del>然而Python语言中由于GIL问题，实际上builtin的数据类型都是thread-safe的，使用时无需上锁</del>对于mutable类型的变量在多线程共享使用时应该用Lock来控制并发，不能依赖Python的具体实现。</p>

<p>在Python 2.6以上，可以使用<code>with</code>简化获取和释放锁的过程，让代码更加简洁。</p>

<h2>Condition</h2>

<p>是对Lock的一层封装。提供了<code>acquire()</code>, <code>release()</code>这两个Lock原语，还提供了<code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code>这三个接口。</p>

<ul>
<li><code>wait()</code> 是获得锁的线程主动释放锁，转入等待过程。</li>
<li><code>notify()</code> 是获得锁的一方不释放锁，但是会唤醒等待这把锁的其中一个线程。</li>
<li><code>notifyAll()</code> 类似<code>notify()</code>，不同的是不是唤醒一个，而是唤醒所有等待锁的线程。</li>
</ul>


<p>典型的使用场景是生产者消费者模式。一个生产者，若干个消费者用一个队列来交互，这时候每个工作线程要想工作首先都需要尝试获得队列的锁。当一个消费者拿到了锁可以访问队列时发现队列时空的，这时候就要使用<code>wait()</code>来主动释放这把锁，然后将自己放到等待线程列表中等待；当一个生产者获得了队列的锁时，将数据放入到队列中，同时在释放锁之前调用<code>notify()</code>来通知其他等待这把锁的线程：『达令，有你快递儿~』，然后在释放锁。如果生产了多个数据，那么就可以使用<code>notifyAll()</code>通知所有的等待线程。</p>

<h2>Event</h2>

<p>Event接口非常简单，就是<code>is_set()</code>和<code>set()</code>, Event用于在多线程间共享某一事件是否发生。我经常用来创建一个<code>stop_event</code>传给所有的worker线程，这样如果程序遇到异常或者其他需要终止的条件时，只要<code>stop_event.set()</code>，其他工作线程会循环的检查<code>stop_event.is_set()</code>。</p>

<h2>Semphore</h2>

<p>上过操作系统课程的同学对『信号量』都有过接触，信号量和对应的<code>p</code>, <code>v</code>操作是并发程序的『操作原语』，即用这两个操作就可以表示所有的并发程序的设计和实现了。上述的Lock, Condition都可以看做是信号量的特定形式。</p>

<p>信号量由一个内部计数器和两个接口构成，内部的计数是非负数，对计数的操作：<code>release()</code>用于增加计数，<code>acquire()</code>用于减计数器。当计数器减到0时，<code>release()</code>操作就会阻塞直至其他工作线程完成<code>acquire()</code>。</p>

<p>Python的<code>acquire()</code>还支持可选参数<code>blocking</code>，当设置为True且计数器为0时，则会阻塞等待。</p>

<blockquote><p>前面的叙述都算是对基本内容的解读，干货现在开始。</p></blockquote>

<h2>如何优雅的中断其他线程的任务</h2>

<h3>使用Event</h3>

<p>在每个线程创建时传入<code>stop_event</code>,遇到异常或者到程序需要结束的时候，则<code>stop_event.set()</code>就可以了。
缺点：只有在线程完成一次工作后才会检查stop_event一次。因此如果线程工作比较久时会设置了<code>stop_event</code>也不会立刻结束。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># worker</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">do_some_job</span><span class="p">(</span><span class="n">job_q</span><span class="p">,</span> <span class="n">stop_event</span><span class="p">):</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">while</span> <span class="ow">not</span> <span class="n">stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
</span><span class='line'>      <span class="k">try</span><span class="p">:</span>
</span><span class='line'>          <span class="n">do_foo</span><span class="p">()</span>
</span><span class='line'>      <span class="k">except</span><span class="p">:</span>
</span><span class='line'>          <span class="n">stop_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c"># manager</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">Queue</span>
</span><span class='line'><span class="n">thread_count</span> <span class="o">=</span> <span class="mi">4</span>
</span><span class='line'><span class="n">stop_event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
</span><span class='line'><span class="n">job_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="n">threads</span> <span class="o">=</span> <span class="p">[</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">do_some_job</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">job_queue</span><span class="p">,</span> <span class="n">stop_event</span><span class="p">,))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">thread_count</span><span class="p">)]</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">thr</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
</span><span class='line'>  <span class="n">thr</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">thr</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
</span><span class='line'>  <span class="n">thr</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Signal的处理</h2>

<p>多线程中Signal只能由<strong>主线程</strong>处理Signal。这部分还没有搞过，暂时略过。</p>

<ul>
<li><a href="https://pymotw.com/2/signal/#signals-and-threads">https://pymotw.com/2/signal/#signals-and-threads</a></li>
<li><a href="http://stackoverflow.com/questions/25676835/signal-handling-in-multi-threaded-python">http://stackoverflow.com/questions/25676835/signal-handling-in-multi-threaded-python</a></li>
<li><a href="https://docs.python.org/2/library/signal.html">https://docs.python.org/2/library/signal.html</a></li>
</ul>


<h2>multiprocessing &ndash; Process-based “threading” interface.</h2>

<p>多进程方式实现threading的接口，从而真正的达到并发。对于计算密集型的应用来说，利用<code>multiprocessing</code>模块可以用Python释放<em>真¤多核</em>性能。</p>

<p>多线程的弊端：多进程相比单进程会有独立的内存地址空间，因此无法共享同父进程的资源，进程切换的系统开销会比多线程多。同时进程间的交互、资源共享也比较复杂和『耗能』。</p>

<h2>Python并发常见编程模式 &mdash; 生产者消费者模式</h2>

<ul>
<li>使用<code>multiprocessing.Queue</code>来进行数据交互</li>
<li>使用<code>multiprocessing.Event</code>来交互事件信号</li>
</ul>


<h2>Python并发常见编程模式 &mdash; Pool + map</h2>

<p>TODO</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[成为早起者的几个步骤[Quora]]]></title>
    <link href="http://liuyix.org/blog/2015/how-to-be-a-morning-man/"/>
    <updated>2015-12-17T06:46:00+08:00</updated>
    <id>http://liuyix.org/blog/2015/how-to-be-a-morning-man</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="https://www.quora.com/How-do-I-become-a-morning-person-1">How do I become a morning person?</a></p>

<p>如何成为一个牛逼的Morning Person,也困扰了我很久。虽然现在依旧没有成功（捂脸）。成为Moring Person后就可以每天早上5点起来在无人打扰的环境里做自己喜欢的或者和梦想有关的事情，当然也可以给自己做一份丰盛的早餐，或者起来加班&hellip;.</p>

<!--more-->


<p>成为Morning Person的几个步骤：</p>

<h3><strong>Step 1</strong> 睡前做好准备。</h3>

<p>睡前就把第二天早上的计划想好，减少你通常在早上需要做的决定，能尽早决定的就晚上确定下来。比如第二天要早期读书，那么就确定好要读哪本书，具体从哪一章节开始，要读多久等等。做决策会消耗精力导致疲劳，所以不要把早上的充沛的精力花费在考虑今天开穿什么衣服，想吃什么早餐这样的决定上。</p>

<p>所以在睡前你要做好：</p>

<ul>
<li>装好包随时可以出门上班</li>
<li>准备好早上要穿的衣服</li>
<li>准备好早餐</li>
<li>确定好早上计划要搞定的几件事</li>
</ul>


<h3><strong>Step 2</strong> 睡你麻痹起来嗨！</h3>

<p>早上一睁开眼睛关了闹钟，忽略身体上的不适感，立马从床上跳下来，做十个立定跳远！
就这么简单！！！10个立定跳远，让身体的血液流动起来，激活能量，人也就精神起来了。</p>

<h3>Step 3（最重要的一点）<red>给自己找一个充分的早起理由——让早起富有意义</red></h3>

<p>这个步骤并不是说在醒来之后告诉自己一些上纲上线的理由，什么生活有多美好啦，或者多么幸运啦（除非这是你早上时间主要的活动，我完全支持）。
你需要有一些你想在清晨做的事情，比如完成繁忙的一天中最该尽早完成的任务（a task you want to accomplish early on before the madness of the day starts to slow you down），你需要参加的会议、活动（有大清早开的会吗&hellip;.我个人理解是需要早起赴约，比如比赛或者赶车），或者锻炼等等。总之，你要有一个无法拒绝的早起的理由。要不大清早起来后，发现老子清晨五六点起来毫无意义，你很可能就又回去睡回笼觉了。<strong>你必须要有一些『只是想一想都有些小激动呢』放在早上来做</strong>，或者<strong>有一些可以让你充满正能量，让你感觉非常开心的，能让一整天达到最佳状态的事情</strong>，这样早起才充满动力。</p>

<p>举几个栗子，这个步骤很好懂，因为要事要早起——赶火车，飞机，外出集合，或者有非常让你小激动的事情——你要陪女神早上跑步，仅仅这些充满诱惑力的理由，即使没有任何准备你也会早起，不是吗？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quora每周摘选(第1期)]]></title>
    <link href="http://liuyix.org/blog/2015/my-quora-digest-issue-1/"/>
    <updated>2015-12-15T23:13:00+08:00</updated>
    <id>http://liuyix.org/blog/2015/my-quora-digest-issue-1</id>
    <content type="html"><![CDATA[<blockquote><p>因为订阅了Quora Digest，发现推送的邮件里面好多不错的文章。这里每周会从我读到的Quora里面翻译部分精选。</p></blockquote>

<ul>
<li><a href="https://www.quora.com/How-do-I-become-a-morning-person-1">How do I become a morning person?</a> ==> <a href="http://liuyix.org/blog/2015/how-to-be-a-morning-man/">成为早起者的几个步骤</a>

<ul>
<li>这篇Post提供了几个比较有效的早起的技巧，最打动我的就是早起你要有一个让自己兴奋到必须要早起的理由。</li>
</ul>
</li>
<li><a href="https://www.quora.com/Is-staying-a-software-engineer-your-whole-life-a-good-career-choice">Is staying a software engineer your whole life a good career choice?</a> ==> 选择做一辈子软件开发是否明智？

<ul>
<li>其实无论在国内还是国外，程序员的职业发展都差不多，要么转管理要么继续Coding</li>
</ul>
</li>
<li><a href="http://qr.ae/RbVArL">What are some of the most important things that we should be informed about in life?</a> ==> 有哪些生活中我们应该知道的重要的事？

<ul>
<li>还是一篇在<em>Life Lessons</em>版过万的upvote的帖子，这周有时间翻译下。</li>
</ul>
</li>
<li>(What are some &lsquo;unofficial mottos&rsquo; of programming languages?)[<a href="https://www.quora.com/What-are-some-unofficial-mottos-of-programming-languages">https://www.quora.com/What-are-some-unofficial-mottos-of-programming-languages</a>]

<ul>
<li>笑点低的我看到强力吐槽能量的帖子，笑个不停</li>
</ul>
</li>
<li><a href="https://www.quora.com/What-programming-languages-should-all-programmers-know">What programming languages should all programmers know?</a> &mdash; 哪些编程语言每个程序员都应该知道

<ul>
<li>无论是知乎还是Quora，越是『简单的』问题就越是可以得到广泛的讨论，反而更容易出比较精华的回答。</li>
</ul>
</li>
</ul>


<!--more-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Data Model]]></title>
    <link href="http://liuyix.org/blog/2015/python-data-model/"/>
    <updated>2015-10-22T08:41:00+08:00</updated>
    <id>http://liuyix.org/blog/2015/python-data-model</id>
    <content type="html"><![CDATA[<blockquote><p>本文介绍了『Python Data Model』官方的总结笔记，主要内容是Python对象的详细介绍</p></blockquote>

<p>Original: <a href="https://docs.python.org/2/reference/datamodel.html#data-model">https://docs.python.org/2/reference/datamodel.html#data-model</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docopt -- Python必备的命令行接口模块]]></title>
    <link href="http://liuyix.org/blog/2015/python-docopt/"/>
    <updated>2015-10-21T00:02:00+08:00</updated>
    <id>http://liuyix.org/blog/2015/python-docopt</id>
    <content type="html"><![CDATA[<p>docopt很适合经常需要用python写命令行工具的同学使用。</p>

<h2>docopt之前</h2>

<p>工作需要，经常会用大块的代码来定(ren)义(rou)命令行界面的工具。代码经常是如下的样子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">optparse</span>
</span><span class='line'>
</span><span class='line'><span class="n">parser</span> <span class="o">=</span> <span class="n">optparse</span><span class="o">.</span><span class="n">OptionParser</span><span class="p">()</span>
</span><span class='line'><span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;--foo&#39;</span><span class="p">,</span> <span class="s">&#39;-f&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&#39;int&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;--bar&#39;</span><span class="p">,</span> <span class="s">&#39;-b&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;store_true&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c"># 类似以上的代码大概几十行</span>
</span><span class='line'>
</span><span class='line'><span class="n">opts</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>每一个python脚本都需要提供类似的接口。因此每一次都需要写类似的代码。在写过几次后为了保持DRY原则，我将初始化parser封装为一个method放在util部分。可是依旧是逃不过重复的写<code>parser.add_option</code>。不止一次地我考虑干脆自己写个模板类，以后命令行的定义直接以配置文件的形式写出来，然后每次都通过读取这个配置文件自动化的去生成parser。我相信这个问题我一定不是第一个遇到，应该会有已知的模块解决这个laber intensive的工作。</p>

<p>正在这个时候，偶然看到Python weekly发现了docopt</p>

<h2>docopt</h2>

<p>docopt官网地址：<a href="http://docopt.org/">http://docopt.org/</a></p>

<p>docopt的作者有一个30分钟的视频很好的介绍了docopt这个moudule。推荐大家看一下，自备梯子~ <a href="https://youtu.be/pXhcPJK5cMc">https://youtu.be/pXhcPJK5cMc</a></p>

<p>更令懒人们惊喜的是作者还制作了一个js版本的docopt，可以让你在浏览器中把玩docopt： <a href="http://try.docopt.org/">http://try.docopt.org/</a></p>

<p>使用docopt后，代码上会更加Pythonic，具有很高的可读性，命令行接口的定义所见即所得的样式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#docopt example</span>
</span><span class='line'>
</span><span class='line'><span class="n">mydoc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;Naval Fate.</span>
</span><span class='line'>
</span><span class='line'><span class="s">Usage:</span>
</span><span class='line'><span class="s">  naval_fate.py ship new &lt;name&gt;...</span>
</span><span class='line'><span class="s">  naval_fate.py ship &lt;name&gt; move &lt;x&gt; &lt;y&gt; [--speed=&lt;kn&gt;]</span>
</span><span class='line'><span class="s">  naval_fate.py ship shoot &lt;x&gt; &lt;y&gt;</span>
</span><span class='line'><span class="s">  naval_fate.py mine (set|remove) &lt;x&gt; &lt;y&gt; [--moored|--drifting]</span>
</span><span class='line'><span class="s">  naval_fate.py -h | --help</span>
</span><span class='line'><span class="s">  naval_fate.py --version</span>
</span><span class='line'>
</span><span class='line'><span class="s">Options:</span>
</span><span class='line'><span class="s">  -h --help     Show this screen.</span>
</span><span class='line'><span class="s">  --version     Show version.</span>
</span><span class='line'><span class="s">  --speed=&lt;kn&gt;  Speed in knots [default: 10].</span>
</span><span class='line'><span class="s">  --moored      Moored (anchored) mine.</span>
</span><span class='line'><span class="s">  --drifting    Drifting mine.</span>
</span><span class='line'><span class="s">&quot;&quot;&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">from</span> <span class="nn">docopt</span> <span class="kn">import</span> <span class="n">docopt</span>
</span><span class='line'>
</span><span class='line'><span class="n">arguments</span> <span class="o">=</span> <span class="n">docopt</span><span class="p">(</span><span class="n">mydoc</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;0.1&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="n">arguments</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样就定义了一个丰富的命令行接口。命令行接口提供了<code>--help</code>和<code>--version</code>两个基础功能。其中<code>--help</code>输出<code>mydoc</code>，<code>--version</code>输出指定的<code>version</code>信息。</p>

<p>接口还提供了2个参数（ship, mine），每种参数还提供了不同的几种参数的组合。其中<code>[...]</code>内是可选参数，<code>(...|...)</code>是互斥参数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress迁移到新主机]]></title>
    <link href="http://liuyix.org/blog/2015/new-mac-test/"/>
    <updated>2015-08-24T00:04:00+08:00</updated>
    <id>http://liuyix.org/blog/2015/new-mac-test</id>
    <content type="html"><![CDATA[<ul>
<li>新机器上首先是把ssh key加入到github的setting，然后配置好基本的git信息（email, name），此处步骤略过。可以参考：<a href="https://help.github.com/articles/set-up-git/">https://help.github.com/articles/set-up-git/</a></li>
<li><code>git clone -b source git@github.com:username/username.github.com.git octopress</code>

<ul>
<li>操作完这一步后就相当于把当前octopress的source文档拉到了本地了。</li>
<li><strong>这一步操作前一定要确保在其他机器上的markdown文件以及其他配置文件的修改都已经push到source分支了，否则这一步会导致博客文章丢失！！！</strong></li>
</ul>
</li>
<li>进入到octopress, 然后<code>git clone git@github.com:username/username.github.com.git _deploy</code>

<ul>
<li>这一步是在<code>_deploy</code>建立好指向master分支的git仓库，方便之后发布文章时使用</li>
</ul>
</li>
<li>安装octopress相关的ruby依赖等

<ul>
<li>建议修改rubygems的安装源到国内的taobao源，详细操作步骤：<a href="http://ruby.taobao.org/">http://ruby.taobao.org/</a>，默认的rubygems.org源已经被墙，速度很慢。</li>
</ul>
</li>
</ul>


<p>完成上面几步后，就可以尝试调用<code>rake generate</code>生成一次网站，然后<code>rake deploy</code>看下是否成功~</p>

<h3>在不同主机上使用Octopress上发布文章</h3>

<p>每次发布新的文章或者修改现有文章时，需要把<code>source</code>分支的修改（即octopress目录所指向的git仓库分支）commit并且push到github上，之后在另外的主机上首先进入到octopress目录，在编辑文章前首先<code>git pull</code>下拉取修改。这样的编辑才能连贯，不然会发生文章丢失的情况。</p>

<p>Reference:</p>

<ul>
<li><a href="http://blog.zerosharp.com/clone-your-octopress-to-blog-from-two-places/">Clone Your Octopress to Blog From Two Places</a></li>
</ul>


<p>-EOF-</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[由互联网中的Python应用想到的网站架构的优化]]></title>
    <link href="http://liuyix.org/blog/2015/python-in-industry/"/>
    <updated>2015-04-08T22:56:00+08:00</updated>
    <id>http://liuyix.org/blog/2015/python-in-industry</id>
    <content type="html"><![CDATA[<ul>
<li>国内<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>

<ul>
<li>知乎</li>
<li>豆瓣</li>
<li>果壳网</li>
</ul>
</li>
<li>国外，只列出我认识的比较出名的，还有好多<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>=。=

<ul>
<li>Quora 国外的知乎？</li>
<li>Dropbox 国外的金山快盘？</li>
<li>Disqus 国外的多说？</li>
<li>Pinterest 国外的花瓣？</li>
<li>Youtube 国外的优酷？</li>
<li>Slideshare 国外的百度文库？</li>
<li>reddit 国外的猫扑？</li>
<li>Yelp 国外的大众点评</li>
<li>&hellip;</li>
</ul>
</li>
</ul>


<p>更多的信息可以参考Python官网的<a href="https://www.python.org/about/success/">Python Success Stories</a>。</p>

<h3>Quora</h3>

<p>下面是QuorWhy did Quora choose Python for its development?a创始人在Quora上对<em>Why did Quora choose Python for its development?</em>的回答<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>

<blockquote><p>We decided that Python was fast enough for most of what we need to do (since we push our performance-critical code to backend servers written in C++ whenever possible). As far as typechecking, we ended up writing very thorough unit tests which are worth writing anyway, and achieve most of the same goals.</p></blockquote>

<p>可以看到对于Python的性能短板，Quora在performance-critical的地方尽可能换用了C++。对于Python没有静态类型，Quora用尽可能的单元测试来确保质量。之所以选择Python其实很大的原因是Founder对Python比较擅长。
进一步google了下，他们的框架用的Pylon。</p>

<h3>知乎的技术架构</h3>

<p>知乎CTO在去年年底有过分享，目前在InfoQ上能找到整理稿。链接：<a href="http://www.infoq.com/cn/news/2014/12/zhihu-architecture-evolution">http://www.infoq.com/cn/news/2014/12/zhihu-architecture-evolution</a></p>

<p>简而言之用的tornado，自己开发了日志系统Kids，消息传递系统Sink，还有页面渲染ZhihuNode。</p>

<h3>网站架构及性能的思考</h3>

<p>本周听了一次FB周海平在阿里内部的一次分享。无论是阿里、Facebook还是豆瓣，我发现了在网站架构上这几家有很多共同点的：</p>

<ul>
<li>MySQL作为存储后端</li>
<li>MySQL上一定有memcache、tair这样的KV系统做缓存</li>
<li>都各自开发了适合自己的消息分发系统，Notify, Thrift, Beanstalkd</li>
<li>后端应该都具有实时日志数据分析： HBase、云梯2、Kids</li>
<li>不同程度上用异步化来提高性能，并会一直以此来作为性能提升的方法。</li>
<li>消息链路上的优化：一个网页的渲染上是树状结构的获取数据，因此可以在通过优化这棵树来达到优化整个过程的目的</li>
</ul>


<h3>其他</h3>

<p>网站选型不单纯是比较语言优劣，还和社区的发展趋势活跃(谁都不想用过一门可能几年就无人问津的语言)、团队内普遍的好恶和掌控能力（C、C++最好，但是大家都不会）、整个行业的形势（团队内都用Lisp，但是招不到人）等等多种因素有关系。
选择哪门语言确实重要，这决定了未来几年或者更远的时间内技术的发展路线，更重要的当规模扩大后需要在性能优化上要付出的代价。（这里面可以拿Facebook优化PHP作为反例，若是当初扎克用的是java或者c++，也许也不会因此如此兴师动众的重写了PHP生态系统里面的大部分东西。）</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="http://www.zhihu.com/question/19685768">知乎-国内使用 Python 作为主要开发语言的知名网站有哪些</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="http://www.quora.com/Which-Internet-companies-use-Python">Quora-Which Internet companies use Python?</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="http://www.quora.com/Why-did-Quora-choose-Python-for-its-development">Quora-Why did Quora choose Python for its development?</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git Workflow]]></title>
    <link href="http://liuyix.org/blog/2015/git-workflow/"/>
    <updated>2015-04-05T23:30:00+08:00</updated>
    <id>http://liuyix.org/blog/2015/git-workflow</id>
    <content type="html"><![CDATA[<p>Git近几年有逐渐取代svn的趋势，一部分原因是github的风靡，google code也关门大吉，令人唏嘘<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。很多公司开始逐渐从svn代码仓库迁移到企业私有版的github&mdash;<a href="https://gitlab.com/">gitlab</a>。知道怎么玩git是大势所趋。</p>

<p>Git小白推荐读物：atlassian出版的<a href="https://www.atlassian.com/git/tutorials">Git Tutorials</a>，这家公司拥有mac上最佳git客户端SourceTree以及Bitbucket。</p>

<p>本文是对<a href="https://www.atlassian.com/git/tutorials/comparing-workflows">Comparing Workflows</a>这篇文章和自己的使用心得所做的总结。</p>

<p>以下三种工作流只是典型的代表，不是规范，而是参考，可以结合自己的使用特点灵活选择和修改。</p>

<ul>
<li>Centralized Workflow</li>
<li>Feature Branch Workflow</li>
<li>Gitflow</li>
</ul>


<!--more-->


<h3>Centralized Workflow</h3>

<ul>
<li>适合几个人的小项目或者自己玩。</li>
<li>和svn差别小。</li>
<li>多人协作采用rebase方式并入master。

<ul>
<li>小李和小红分别把代码拉到本地进行开发，然后小李先提交到了master，这时候小红再提交她的修改会被reject，因为push的过程中小红本地的Master分支和remote（服务器）上的不同。这时候小红需要<code>git pull --rebase origin master</code>将远程的代码和她本地的修改进行融合，融合的目的是让小红提交的所有的commit看起来实在小李同学push到master分支后的那个点开始做的。</li>
</ul>
</li>
</ul>


<p><img src="https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/centralized-workflow/11.svg" alt="小红在小李之后push到master" /></p>

<h3>Feature Branch Workflow</h3>

<ul>
<li>适合几个人的小项目。</li>
<li>利用<em>pull request</em>进行code review和交流改进。</li>
</ul>


<p>相比<em>Centralized Workflow</em>，这个工作流没有增加多少内容，只是在merge过程时一定要创建<code>pull request</code>让大家可以有个代码review和交流修改的过程。</p>

<h3>Gitflow</h3>

<p>比较适合多人的大型项目。</p>

<p><img src="http://nvie.com/img/git-model@2x.png" title="git branching model" alt="git branching model" /></p>

<ul>
<li>master</li>
<li>develop</li>
<li>release</li>
<li>feature</li>
<li>bugfix</li>
</ul>


<!-- 一个例子是线上生产稳定的跑着1.2版本（master分支），开发和测试主要活跃在develop分支，产品路线图中计划的下个月的1.3版本的发布是develop的一个release分支。在1.3版本中总共加入了3个feature和5个bugfix，总共由4个人负责代码开发。-->




<!--2个主要分支：master和develop。master分支对应生产环境跑的代码，很像rpm包的`current channel`；develop对应的就是rpm发布的`test channel`，feature和release在完成后都会并入到develop分支。-->


<h3>More Readings</h3>

<ul>
<li><a href="http://paulhammant.com/2014/01/08/googles-vs-facebooks-trunk-based-development/">Google&rsquo;s vs Facebook&rsquo;s Trunk Based Development</a></li>
</ul>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>http://google-opensource.blogspot.com/2015/03/farewell-to-google-code.html<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL 5.6 GTID 学习笔记]]></title>
    <link href="http://liuyix.org/blog/2014/mysql-gtid-introduction/"/>
    <updated>2014-09-20T18:45:00+08:00</updated>
    <id>http://liuyix.org/blog/2014/mysql-gtid-introduction</id>
    <content type="html"><![CDATA[<h3>Reading List</h3>

<ul>
<li>Facebook部署5.6 GTID的blog: <a href="https://www.facebook.com/notes/mysql-at-facebook/lessons-from-deploying-mysql-gtid-at-scale/10152252699590933">Lessons from Deploying MySQL GTID at Scale</a>(需要翻墙)

<ul>
<li>Facebook@Percona Live 2014 <a href="http://www.percona.com/live/mysql-conference-2014/sessions/global-transaction-id-facebook">GLOBAL TRANSACTION ID AT FACEBOOK</a></li>
<li>MySQL Manual使用时GTID时的限制：<a href="http://dev.mysql.com/doc/refman/5.6/en/replication-gtids-restrictions.html">17.1.3.4 Restrictions on Replication with GTIDs</a></li>
</ul>
</li>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash Tips]]></title>
    <link href="http://liuyix.org/blog/2014/bash-tips/"/>
    <updated>2014-09-14T16:59:00+08:00</updated>
    <id>http://liuyix.org/blog/2014/bash-tips</id>
    <content type="html"><![CDATA[<h3>Bash 遇到错误就退出</h3>

<p><a href="http://stackoverflow.com/a/4382179">http://stackoverflow.com/a/4382179</a></p>

<p><code>set -e</code></p>

<blockquote><p>If you put set -e in a script, the script will terminate as soon as any command inside it fails (i.e. as soon as any command returns a nonzero status). This doesn&rsquo;t let you write your own message, but often the failing command&rsquo;s own messages are enough.</p>

<p>The advantage of this approach is that it&rsquo;s automatic: you don&rsquo;t run the risk of forgetting to deal with an error case.</p>

<p>Commands whose status is tested by a conditional (such as if, &amp;&amp; or ||) do not terminate the script (otherwise the conditional would be pointless). An idiom for the occasional command whose failure doesn&rsquo;t matter is command-that-may-fail || true. You can also turn set -e off for a part of the script with set +e.</p></blockquote>

<h2>Bash使用数组</h2>

<h3>快速入门</h3>

<p>(Bash For Loop Array: Iterate Through Array Values)[<a href="http://www.cyberciti.biz/faq/bash-for-loop-array/">http://www.cyberciti.biz/faq/bash-for-loop-array/</a>]</p>

<ul>
<li>用括号指定，空格指定就好</li>
<li>遍历： <code>for i in "${var[@]}"</code></li>
</ul>


<h3>深入</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'># array-ops.sh: More fun with arrays.
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>array=( zero one two three four five )
</span><span class='line'># Element 0   1   2    3     4    5
</span><span class='line'>
</span><span class='line'>echo ${array[0]}       #  zero
</span><span class='line'>echo ${array:0}        #  zero
</span><span class='line'>                       #  Parameter expansion of first element,
</span><span class='line'>                       #+ starting at position # 0 (1st character).
</span><span class='line'>echo ${array:1}        #  ero
</span><span class='line'>                       #  Parameter expansion of first element,
</span><span class='line'>                       #+ starting at position # 1 (2nd character).
</span><span class='line'>
</span><span class='line'>echo "--------------"
</span><span class='line'>
</span><span class='line'>echo ${#array[0]}      #  4
</span><span class='line'>                       #  Length of first element of array.
</span><span class='line'>echo ${#array}         #  4
</span><span class='line'>                       #  Length of first element of array.
</span><span class='line'>                       #  (Alternate notation)
</span><span class='line'>
</span><span class='line'>echo ${#array[1]}      #  3
</span><span class='line'>                       #  Length of second element of array.
</span><span class='line'>                       #  Arrays in Bash have zero-based indexing.
</span><span class='line'>
</span><span class='line'>echo ${#array[*]}      #  6
</span><span class='line'>                       #  Number of elements in array.
</span><span class='line'>echo ${#array[@]}      #  6
</span><span class='line'>                       #  Number of elements in array.
</span><span class='line'>
</span><span class='line'>echo "--------------"
</span><span class='line'>
</span><span class='line'>array2=( [0]="first element" [1]="second element" [3]="fourth element" )
</span><span class='line'>#            ^     ^       ^     ^      ^       ^     ^      ^       ^
</span><span class='line'># Quoting permits embedding whitespace within individual array elements.
</span><span class='line'>
</span><span class='line'>echo ${array2[0]}      # first element
</span><span class='line'>echo ${array2[1]}      # second element
</span><span class='line'>echo ${array2[2]}      #
</span><span class='line'>                       # Skipped in initialization, and therefore null.
</span><span class='line'>echo ${array2[3]}      # fourth element
</span><span class='line'>echo ${#array2[0]}     # 13    (length of first element)
</span><span class='line'>echo ${#array2[*]}     # 3     (number of elements in array)
</span><span class='line'>
</span><span class='line'>exit</span></code></pre></td></tr></table></div></figure>


<p>(Arrays)[<a href="http://www.tldp.org/LDP/abs/html/arrays.html">http://www.tldp.org/LDP/abs/html/arrays.html</a>]</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[拖延的反思]]></title>
    <link href="http://liuyix.org/blog/2014/procrastination-helps/"/>
    <updated>2014-09-14T11:39:00+08:00</updated>
    <id>http://liuyix.org/blog/2014/procrastination-helps</id>
    <content type="html"><![CDATA[<p>昨天在多看阅读中看到的一篇关于拖延症的文章&mdash;《“被绑架”了的拖延症患者 &mdash; 爱上拖延症的八个理由》。原始出处已无法考据，感谢原作者的分享。在网上找到了一个<a href="http://talk.ifeng.com/zaixianjiangtang/shys/special/tuoyanzheng/zuixin/detail_2012_10/30/18669615_0.shtml">引用链接</a>。</p>

<p>之前也正好看到了李松蔚在微信公众账号里面发表的拖延症系列文章中的《框架中的拖延者（3）：和解，无关明日》，二者有想通之处：拖延是内心不和谐的表征，造成拖延一定有更深层次的原因。如果发生拖延了不深究原因只一味的自责，那么拖延只会恶化，身心不会得到解脱，真正的“病因”因此会一直纠缠着自己。</p>

<p>在《被绑架》一文中，笔者就内省自己拖延的原因，勇敢的做出了改变。</p>

<p>笔者自述自己拖延中大部分时间是用来玩游戏、听音乐、看电影、读文章、读书。相比于『有意义的工作』，笔者把这作为自己内省和成长的一部分。</p>

<p>这一点上我部分赞同，不想工作必然有其他可理解的原因，不仅仅是『找回属于自己的时间』。我觉得拖延不做工作，尤其是周末。有可能是自己的身体在通过『懒惰小人』告诉自己需要休息放松。<em>人不是机器，一般情况下很难长期保持高强度的工作。</em></p>

<p>在“行为和内心一致”这一节中，笔者在工作中发现越来越讨厌工作，逃避工作。</p>

<blockquote><p>这一阶段的拖延虽然还有漫无目的的无聊，但更多的是一些有意识地利用拖延下来的时间学习哲学、心理学或者英语和写作等相关技能
事后从这个角度看，事情甚至完全反过来，就像是为了获得收入和安全感拖延了我的学习时间而去做无趣的工作。</p></blockquote>

<p>笔者确实发现了自己不喜欢自己的工作。（事后也用自己的行动的结果说明了自己在其他领域有更好的发展。）但是通常而言无论是什么事，总有你不愿意做的部分和喜欢做的部分。认清自己内心到底喜欢做什么并能持之以恒，这是需要智慧的。若是缺乏智慧，则误把因为“懒”做事挑肥拣瘦当做这不是我喜欢做的工作。今天从银行辞职该做摄影师，坚持不了多久又觉得摄影不是真正喜欢的事情，又改写小说&hellip;<br/>
用智慧做出判断，用勇气做出改变相比治疗拖延症是更重要的。
关于如何甄选自己喜欢的职业，建议读一读<a href="http://book.douban.com/subject/4953695/">《拆掉思维里的墙》</a>这本书。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[积跬步至千里]]></title>
    <link href="http://liuyix.org/blog/2014/keep-doing-make-miracle/"/>
    <updated>2014-09-13T21:19:00+08:00</updated>
    <id>http://liuyix.org/blog/2014/keep-doing-make-miracle</id>
    <content type="html"><![CDATA[<p>焦虑的我今天冥冥中发现了BYVoid的github，进而去他的博客兜了一圈，感触良多。先介绍下背景。</p>

<p>BYVoid这个人是去年校招时听闻的。那时刚参加完阿里的校招，还没有出结果，焦急的等待中持续关注着北邮人论坛的有关阿里校招的消息。那个时候不知阿里内部哪位好事者漏出了一张阿里校招时给出A+ offer的面试后台系统记录截图。（A+就是去年阿里校招的阿里星计划，60W年薪+股票期权），这个八卦中的主角就是郭家宝，网名BYVoid。一个九零后的清华本科生，本科的假期在MSRA，Google，Hulu，Facebook有过实习经历，初高中参加信息学竞赛，后来保送到清华。还出过一本书<a href="http://book.douban.com/subject/10789820/">《Node.js开发指南》</a>。<br/>
关于他个人的更多介绍，可以看下他的博客介绍：<a href="https://www.byvoid.com/zht/about/resume">链接</a>以及他的报告<a href="https://byvoid.github.io/slides/experiences-2014/index.html">《我的一些经历》</a></p>

<p>我最感兴趣的是<em>一个牛人是如何成长的</em>，<em>他的博客文章的质量是如何提高的</em>。进到博客一看发现这位新秀从2007年就开始写博客了(2010年才上大学)。于是我就从最后面的文章开始翻起来，有种在读别人的日记的赶脚&hellip;（兴致勃勃的去看一个本科毕业生在初三时写的文章，没有这种赶脚才怪呢）BYVoid<br/>
这几年确实没少写。每个月有十几篇二十几篇的数量。</p>

<p>花了一个晚上的时间把所有的文章题目过了一遍。感触挺多:
技术牛人其实也是普通人，只是做事更加深入、认真，专注一些和坚持久一些『罢了』。</p>

<h4>履历</h4>

<p>BYVoid初中一次偶然的机会，他的老师发现了他在信息学上的天分（拿出一张卷子让他做，结果竟然很多都做对了，后来才知道这是去年的信息学竞赛试题）。也许就是这样的契机让郭同学的人生轨迹变得和同龄人与众不同。之后郭家宝同学通过竞赛保送到省实验中学，之后的高中几年就一直在做信息学竞赛。从他的博客上来看，BYVoid不仅是有天分，本身也很喜欢信息学竞赛，解数学题。他不仅做了老师要求的内容，还在课下自己主动刷题训练（高中的文章很多都是UASCO解题报告）。高中联赛名次不错，最后联赛超常发挥拿到了国家比赛的金牌，靠这块金牌顺利的保送到了清华大学，这时的他才高中二年级。接下去的一年和很多人不同的是，他不再有高考压力，于是在看新白娘子传奇的过程中，发现了自己对汉语字体的兴趣，逐渐开始了汉字研究。到了大学，还保持着这份兴趣。建立了至今广为使用的Opencc开源项目。<br/>
<em>良好的编程功底</em>加上清华大学计算机系拥有的资源，BYVoid在MSRA, Hulu, Google, Facebook都做过实习。今年毕业的他应该是去了瑞士Google（从他的LinkedIn了解到的）</p>

<h4>感悟</h4>

<ul>
<li>不怀目的的写作是最真实的成长记录，<a href="https://www.byvoid.com/zhs/blog/read-rss">这篇文章</a>就是很好的一个例子。</li>
<li>任何人都是从基础逐渐开始成长。写作的能力也一样，长文写作也是一点点培养建立的，BYVoid自己也做了几年博客文章的一个总结（<a href="https://www.byvoid.com/zhs/blog/my-blog-four-years">link</a>）。技能的提高都是通过不断的坚持练习达到的。对于写作来说只有不断的写，开始时也许文字会短小、不连贯，包含很多主观的随感以及转载。但是不断的坚持，慢慢的开始有了深度和广度。在BYVoid的博客中我看到了<strong>每一个阶段都是真实的表现了自己同期的水平和状态</strong>，一个初中生不会一开始就会写出有研究深度的文章和报告而是会写出介绍环境搭建、介绍Vim用法等入门心得。没有刻意地训练只是日积月累的写作，量变终会得到质变。写就<a href="https://byvoid.github.io/slides/cassandra/index.html"><Cassandra></a>、<a href="https://byvoid.github.io/slides/bitcoin-internals/index.html">Bitcoin Internals</a>这样的Slides。</li>
<li><strong>兴趣</strong>、<strong>自我驱动</strong>更有可能成为领域达人。退一步讲成为不了达人，自己也可以自得其乐。这也是『过程比结果重要』的一种诠释吧。兴趣使然 &mdash;> 深入研究 &mdash;> 升华提高。</li>
<li><strong>持久</strong>和<strong>钻研</strong>的个性是能力持续提高的秘诀。拥有兴趣而没有持之以恒的坚持也很难成为一位达人（当然也可以将持久作为兴趣定义的属性）。这些文章 <a href="https://www.byvoid.com/blog/string-hash-compare">Hash函数比较</a>，<a href="%E7%A0%B4%E8%A7%A3Firefox%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8%E5%8A%A0%E5%AF%86%E7%9A%84%E4%BF%A1%E6%81%AF">破解Firefox密码管理器加密的信息</a>，<a href="https://www.byvoid.com/zhs/blog/firefox-js">CmYkRgb123 Online Grading System</a> ，还有OpenCC 不仅能看出他的兴趣也能感受到一份钻研的热情。</li>
</ul>


<p>拥有足够浓厚的兴趣和一个非功利的健康心态很容易成为某一领域的达人。但是如果没有这些，只要你：持之以恒、不浮躁、耐心、钻研、自我驱动也一样可以达成。</p>

<h3>『我不追求输赢，我只是认真』</h3>

<p>『钻研』是BYVoid给我印象最深的一点。作为一种个性，不仅是在技术能力上体现，会在生活的很多方面能感受得到。高中信息学竞赛时，他把NOIP2000到2007年所有题都做了一遍<a href="https://www.byvoid.com/blog/noip-allsolutions/">link</a> 并整理出来这个就不是所有人都能做到的。还有他特别爱玩仙剑奇侠传游戏，这个很多人都爱玩，但是很少有人像他这样详细相关的情节、剧情都详细写成评测文章，<a href="https://www.byvoid.com/blog/pal4-experience">仙剑四</a>，<a href="https://www.byvoid.com/zhs/blog/tag/%E4%BB%99%E5%8A%8D%E4%BA%94">仙剑五系列</a>。或者看一部电影做一个影评<a href="https://www.byvoid.com/zhs/blog/under-the-hawthorn-tree">山楂树之恋</a>。还体现在文字的研究上，从他的<a href="https://www.byvoid.com/zhs/blog/xb-word-pron">第一篇文章</a>，之后有了OpenCC——<a href="https://www.byvoid.com/zhs/blog/open-chinese-convert">文章link</a>，在简繁字体的研究一直持续着。</p>

<p>因为没有看到合适的介绍node.js的书籍，也恰逢认识了图灵图书的编辑，于是促成了一本Node.js开发指南的诞生。这让我想到『机会总是留给有准备的人』。</p>

<p>所以成就一个牛人主要是一个人身上的某种品质——如BYVoid的钻研，而不仅仅是兴趣。</p>

<h3>一些博客链接</h3>

<ul>
<li><a href="https://www.byvoid.com/zhs/blog/new-year-2009">2008年总结</a>，2008年年末开始刷POI，2009年开始写比较长的解题报告，匈牙利算法，很认真的画了图，写了很详细，很认真</li>
<li>2009年近半年的近期总结-<a href="https://www.byvoid.com/zhs/blog/summary-2009-3">https://www.byvoid.com/zhs/blog/summary-2009-3</a></li>
<li>一次吐槽 &mdash; <a href="https://www.byvoid.com/zhs/blog/sequence-mad">https://www.byvoid.com/zhs/blog/sequence-mad</a></li>
<li>NOI2009 &mdash; <a href="https://www.byvoid.com/zhs/blog/noi-2009%EF%BC%8Chttps://www.byvoid.com/zhs/blog/noi-ssc-exp">https://www.byvoid.com/zhs/blog/noi-2009%EF%BC%8Chttps://www.byvoid.com/zhs/blog/noi-ssc-exp</a></li>
<li>语言研究的第一篇文章 &mdash; <a href="https://www.byvoid.com/zhs/blog/xb-word-pron%EF%BC%8C%E4%B9%8B%E5%90%8E%E6%85%A2%E6%85%A2%E5%BC%80%E5%A7%8B%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E8%AF%AD%E8%A8%80%E4%BA%86%EF%BC%8C%E6%9C%89%E8%B6%A3%E7%9A%84%E4%B8%80%E7%AF%87https://www.byvoid.com/zhs/blog/bh-diao-cao%EF%BC%8C%E4%B9%8B%E5%90%8E%E5%B0%B1%E4%B8%80%E7%9B%B4%E5%9C%A8%E7%A0%94%E7%A9%B6%E7%AE%80%E7%B9%81%E5%AD%97%E4%BD%93">https://www.byvoid.com/zhs/blog/xb-word-pron%EF%BC%8C%E4%B9%8B%E5%90%8E%E6%85%A2%E6%85%A2%E5%BC%80%E5%A7%8B%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E8%AF%AD%E8%A8%80%E4%BA%86%EF%BC%8C%E6%9C%89%E8%B6%A3%E7%9A%84%E4%B8%80%E7%AF%87https://www.byvoid.com/zhs/blog/bh-diao-cao%EF%BC%8C%E4%B9%8B%E5%90%8E%E5%B0%B1%E4%B8%80%E7%9B%B4%E5%9C%A8%E7%A0%94%E7%A9%B6%E7%AE%80%E7%B9%81%E5%AD%97%E4%BD%93</a></li>
<li>有自己开发维护的系统：<a href="https://www.byvoid.com/zhs/blog/vakuum-dev-note-02">https://www.byvoid.com/zhs/blog/vakuum-dev-note-02</a></li>
<li>2010年6月开启了OpenCC项目 <a href="https://www.byvoid.com/zhs/blog/open-chinese-convert">https://www.byvoid.com/zhs/blog/open-chinese-convert</a></li>
<li>讲述自己与汉语 <a href="https://www.byvoid.com/zhs/blog/i-and-chinese-language">https://www.byvoid.com/zhs/blog/i-and-chinese-language</a></li>
<li>2011年11月份的博客质量很高

<ul>
<li><a href="https://www.byvoid.com/zhs/blog/godel-incompleteness-theorems-agnosticism">https://www.byvoid.com/zhs/blog/godel-incompleteness-theorems-agnosticism</a></li>
<li><a href="https://www.byvoid.com/zhs/blog/rdbms-isolation-lock-concurrency">https://www.byvoid.com/zhs/blog/rdbms-isolation-lock-concurrency</a></li>
</ul>
</li>
<li>仙剑五总结 <a href="https://www.byvoid.com/zhs/blog/pal5-comment">https://www.byvoid.com/zhs/blog/pal5-comment</a></li>
<li>写书小记 &mdash; <a href="https://www.byvoid.com/zhs/blog/compose-a-book">https://www.byvoid.com/zhs/blog/compose-a-book</a></li>
<li><a href="https://www.byvoid.com/zhs/blog/why-functional-programming">https://www.byvoid.com/zhs/blog/why-functional-programming</a></li>
<li><a href="https://www.byvoid.com/zhs/blog/i-and-chinese-language">https://www.byvoid.com/zhs/blog/i-and-chinese-language</a></li>
<li>影评山楂树之恋 <a href="https://www.byvoid.com/zhs/blog/under-the-hawthorn-tree">https://www.byvoid.com/zhs/blog/under-the-hawthorn-tree</a></li>
<li>2012年的总结 **<a href="https://www.byvoid.com/zhs/blog/recent-one-year**">https://www.byvoid.com/zhs/blog/recent-one-year**</a></li>
<li><a href="https://www.byvoid.com/blog/treasure-young-days/">https://www.byvoid.com/blog/treasure-young-days/</a></li>
<li>美国之行系列： <a href="https://www.byvoid.com/blog/usa-tour-impress">https://www.byvoid.com/blog/usa-tour-impress</a></li>
<li>海外面试经历 <a href="https://www.byvoid.com/zhs/blog/oversea-internship-interviews">https://www.byvoid.com/zhs/blog/oversea-internship-interviews</a></li>
<li>绥芬河出国 <a href="https://www.byvoid.com/zhs/blog/archive/2014/1">https://www.byvoid.com/zhs/blog/archive/2014/1</a></li>
<li><a href="http://www.qyer.com/u/1754807/footprint">http://www.qyer.com/u/1754807/footprint</a></li>
<li>整个高中的经历：

<ol>
<li> <a href="https://www.byvoid.com/zhs/blog/my-highschool-1">https://www.byvoid.com/zhs/blog/my-highschool-1</a></li>
<li> <a href="https://www.byvoid.com/blog/my-highschool-2">https://www.byvoid.com/blog/my-highschool-2</a></li>
<li> <a href="https://www.byvoid.com/blog/my-highschool-3">https://www.byvoid.com/blog/my-highschool-3</a></li>
<li> <a href="https://www.byvoid.com/blog/my-highschool-4">https://www.byvoid.com/blog/my-highschool-4</a></li>
<li> <a href="https://www.byvoid.com/blog/my-highschool-5">https://www.byvoid.com/blog/my-highschool-5</a></li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[明日迷的一天]]></title>
    <link href="http://liuyix.org/blog/2014/work-review/"/>
    <updated>2014-09-13T13:09:00+08:00</updated>
    <id>http://liuyix.org/blog/2014/work-review</id>
    <content type="html"><![CDATA[<p>上一篇博客还是在1月份，转眼已经大半年过去了。大概曾经有兴趣关注本人的也都没什么兴致了吧，呵呵。 <br/>
不禁有些感慨。 <br/>
对一个人的真正了解，无论是了解他人还是认识自己，从行动上看的最真实的。我以为自己爱写字、爱表现。可是从博客的更新频度和质量上来看，这些只是内心的美好想法，说的不好听就是“幻觉”。能真正认识自己很难。而且与这相比，更难的是认识了之后接受这样的自己。</p>

<p>前几天在微信中读到的印象很深的是李松蔚先生在微信公众账号里面的一篇文章<a href="https://app.yinxiang.com/shard/s3/sh/26f47ed4-d76e-4c39-8dd6-bda46e068ca5/733c63d816b9fbc42f341cb4b0eb0021">《框架中的拖延者（4）：希望与不满》</a>，文章中描述了生活中的一类人“明日迷”，我是非常典型的这类人。</p>

<blockquote><p>&hellip;每一位明日迷的心里都积压了深深的不满。我们对自己失望。我们懊恼，愤怒，责怪自己又浪费了时间，碌碌无为，离明日的解脱还是遥遥无期。
每一个“今天”，我们都用这种想法折磨自己，再用行动上的放纵补偿自己。</p></blockquote>

<p>这篇文章中的每一个字都几乎命中了我的每一日生活，我对现在的自己不满意，我觉得我可以做的更好，做的更努力，现在的我达不到我内心中那个满意的标准。“现在，我不满意自己”。</p>

<p>令我没有想到的是这样的“上进的”想法，我一直引以为豪，以为是我不断进步的想法竟然是给我造成痛苦的罪魁祸首。</p>

<blockquote><p>  “现在，我不满意自己。”这个念头潜移默化地，为我们带来了多少痛苦？<br/>
  让我们不快乐，让我们觉得现在这些时间毫无价值。<br/>
  让我们耽于幻想，沉迷于将来有朝一日成功后的如释重负。<br/>
  让我们忍不住泄气，自怨自艾，精神萎靡，缺乏动力。<br/>
  “啊，还是先睡一觉，先吃点零食，先刷刷淘宝，养精蓄锐再开始奋斗吧……”<br/>
  甚至于，即使有兴趣的事，快乐的事，如果当成“正事”来做，也会慢慢感觉到痛苦，感觉到肩上的担子一天比一天沉。原理很简单：做正事，我们就希望“进步”。<br/>
  而希望进步，就等于说现在，我们还不满意自己。</p></blockquote>

<p>呵呵，还是个不断恶性循环的怪圈。</p>

<ol>
<li>在“你丫连自己满意的标准还没有达到，赶紧进步”的想法中过的不快乐 &mdash;></li>
<li>转念便有了“别看你们现在这么神气，哥以后一定会成为技术新秀，藐杀所有不努力的人。”的幻想 &mdash;></li>
<li>可是&hellip;“哎呀，我还有好多书买了都没有看，连最经典最基础的都没看完，更别提读经典的代码了，事情好多啊，累觉不爱啊” &mdash;></li>
<li>压力之后，潜意识就会&hellip; “刚起床，先刷个朋友圈缓解下吧”，“在看看今天有什么新闻”，“今天周末了，看个电影放松下，前一段时间太累了，需要多休息的”，一个上午就这样消磨掉了。&mdash;></li>
<li>于是想到了“你丫连自己满意的标准还没有达到，赶紧进步！”，再次回到了开始的不快乐。</li>
</ol>


<p>产生的结果是在不快乐郁闷中，用看电影、刷微博、看朋友圈过了一上午。而且</p>

<blockquote><p>甚至于，即使有兴趣的事，快乐的事，如果当成“正事”来做，也会慢慢感觉到痛苦，感觉到肩上的担子一天比一天沉。原理很简单：做正事，我们就希望“进步”。</p></blockquote>

<p>文章的最后正写出了我们的内心写照：</p>

<blockquote><p>一旦把目光放到未来的进步，对此刻的不满就难以避免。“勤奋小人”和“懒惰小人”会立刻开战。而我们已经知道了，一旦被这场希望与不满的战争席卷，我们的内心便会天昏地暗，永无宁日。做事的乐趣破坏殆尽，我们背着沉重的包袱，举步维艰。</p></blockquote>

<p>万万没想到，优秀青年具有的上进的想法是事实上自己不是很上进的心理根源。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我在BIT的这几年]]></title>
    <link href="http://liuyix.org/blog/2014/my-work-in-bit/"/>
    <updated>2014-01-03T19:39:00+08:00</updated>
    <id>http://liuyix.org/blog/2014/my-work-in-bit</id>
    <content type="html"><![CDATA[<h3>Changelog</h3>

<table>
<thead>
<tr>
<th></th>
<th>Version </th>
<th>  Time </th>
<th> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> 0.3 </td>
<td> 2014-3-1 </td>
<td> 毕业设计的总结</td>
</tr>
<tr>
<td></td>
<td> 0.21 </td>
<td> 2014-1-5 </td>
<td> 最后一学年的小结</td>
</tr>
<tr>
<td></td>
<td> 0.2 </td>
<td>  2014-1-4 </td>
<td> 研究生第二年</td>
</tr>
<tr>
<td></td>
<td> 0.1 </td>
<td>  2014-1-3 </td>
<td> 研究生第一年</td>
</tr>
</tbody>
</table>


<h2>我在BIT的这几年</h2>

<p>2年半的研究生即将结束，聊以此文做一下这几年的回顾吧。</p>

<p>2011年我考入了BIT，之后机缘之下来到了现在的实验室，正式成为了现在的导师的<em>第一任</em>弟子。实话说如果当时选择导师的时候能了解到更多的信息，可能就不会是这个选择了。幸运的是误打误撞的还碰到了不错的导师，与其说是导师，现在感觉倒更像是朋友和师兄，他给予了充分的自由和平等，我很感激。不过自己的散漫之气也因此耽误了不少事情，实感愧疚。这个之后会有提到。</p>

<!--more-->


<h2>第一学期</h2>

<h4>研究生课程</h4>

<p>研究生的第一年主要是上课了，没有在实验室待多少时间。第一个学期和大多数人一样尽力把培养方案中要求的课程上完，于是乎第一个学期几乎是宿舍、研究生楼、食堂、实验室这四个地方奔波，课满的时候一天5节课，从早上8点一直到晚上9点半。比较坑爹的是下午和晚上的课程之间的休息仅有40分钟——下午6点下课，晚上的课6点40就开始，40分钟几乎连晚饭都搞不定。（一是下课高峰人很多，二来距离不近）<br/>
研究生的课程难度上其实和本科生差别不大，不过还是让我感受到了一些压力：每一门专业课程都有至少一个，有时几个可以称得上是project的作业。虽然听说这种程度的project其实只能算是接近于本科生课程的要求，有的甚至还要宽松。但这恰恰是燕山大学计算机专业的不足之处，本科时我一直期待着可以有这种一试身手的有挑战的任务。</p>

<h4>环境</h4>

<p>住宿和饮食得益于北京重点高校的给力扶持令人满意，所住的宿舍环境干净、宽松，食堂因为学校的补助，饭菜相比外面实惠很多。（不过现在也因为CPI有所涨价了，从2011年￥8每顿饭到现在￥12左右）<br/>
实验室的环境同其他同学相比也好一些，人均面积可以说是在整个学院来说都是很大的。刚到的时候实验室的机器不怎么给力，是2007年的老机器了，忍受了一年之后终于在2012年的时候换成了目前非常给力的工作站。 <br/>
研究生阶段不同于大学本科，每个人的作息和时间安排因实验室而异，有的实验室要求很严格，规定了下课后必须到实验室;有的则相对灵活宽松，没有具体的要求，只要及时把任务搞定就可以。我很幸运的是后者，所以没有课的时候比较自由。不过后面会提到这样带来的一些副作用。</p>

<h4>实验室工作</h4>

<p>每个实验室因Boss不同，对研究生以及整个实验室的工作方向都有相当的差别。有的是企业项目导向的，以企业合作的方式让学生去完成一些企业项目（说白了就是当廉价劳动力&hellip;）;有的是以学术研究为导向的，具体来说就是拿到了某个基金，之后来做一些研究工作，说白了就是发论文;更多的则是兼而有之，既有一些与企业合作的项目，也有一些学术型的研究。我所在的实验室是第二种，单纯以学术研究为导向的，因而研究生的第一个学期我在实验室的主要任务就是读论文，内容集中在<em>Simulation</em>,<em>Performance Evaluation</em>这一块。由于自己之前没有什么基础，因而读的时候收获甚微。<br/>
除此之外，我还接触了<em>Gem5模拟器</em>。惭愧的是在实验室待了2年有余，Gem5模拟器钻研的不是很精，只是对整个架构，完整的工作原理有了一个初步的了解，实现了一些功能的扩展。这个稍后会细说。</p>

<p>整个一个学期，最令我印象深刻的事是关于人工智能课程，其实这个课程当初没有选，几个舍友选了之后向我推荐，当时想着不如多学些让自己有个更宽的知识面，没成想最后的结束比较狼狈，课程项目做的马马虎虎，考试也只是擦边60分水过，自己现在对AI依旧比较陌生，不得不说是一个遗憾。<strong>现在想来这是自己的一个弱点——对自己没感觉的东西，总是不能做的令人满意，如果现在设想十年后自己没有成功的原因的话，这应该算上一条。</strong></p>

<h2>第二学期</h2>

<p>2012年4月份这一个学期伊始，导师出国做为期一年的访问学者。</p>

<h4>几个月的实习</h4>

<p>临走前将我安排到了中国软件评测中心CSTC做实习（在2011年年末的时候就已经有了一些接触，当时不过是在学校来做，这个时候就正式去公司去做实习了）。实习工作比较水，一如给的不足一百的实习薪水。做的内容是Android平台的安全软件研究。具体来说就是“研究”LBE隐私卫士的实现原理。这也是我第一次接触LBE。 <br/>
之后大概两个月都在做这一块的逆向研究，越发的感觉到LBE“主动防御”技术真的好牛逼。恰巧的是同年四五月份，360安全卫士、腾讯管家也才陆陆续续的推出了类似功能。我在CSTC的情况很微妙，只是我一个人独立在做这一块，最终是大概到了4月末还是没有作出成果，原因是多方面的，对Android整个系统的了解我只是个大菜鸟，只是自学了一点皮毛，同时我也不是Hacker级别的玩家。虽然对我来说我也研究出了一些门道，但很遗憾的没有做出成品。<br/>
这一段时间我实现了利用ptrace实现<em>动态注入共享库</em>，还有运行时的<em>function redirection</em>，对Android Binder协议也接触了一点。我已经尽力了，没什么遗憾。 <br/>
之后为了交差，CSTC的指导人又让我做一个简单的短信和来电骚扰拦截应用，这个相对于前者难度很小，于是大概一个月的时间就做出来一个基于黑白名单的短信和电话过滤应用。实现使用的核心原理没什么难度，网上都有，就是Java反射调用一个没有公开的接口从而实现来电拦截。这个应用代码主要是sqlite的增删改查以及界面的实现。</p>

<h4>实验室工作</h4>

<p>导师和我在这个学期还是经常有邮件的联系，实验室的工作也一直还有，主要工作就是完成一个很tricky的trace收集算法，在gem5上实现，然后发会议paper，因为CSTC的实习，实验室的这块工作就没怎么顾得上，到了七八月份眼看着到了论文deadline，这时候CSTC那一块要求做的来电和短信的过滤应用也告一段落，因此就决定把实习辞掉，专心来做paper，这个时候是7月末。<br/>
于是从7月末开始，也就是研究生第一年的暑假，整个一个假期都在实验室苦逼地做实验，一直到9月初deadline截至时，尤其印象深刻的是deadline是北京时间的上午，距离几个小时前依旧在跑实验数据，最终算是勉强把数据跑完加上了，论文几乎没有怎么校对过。现在回顾看来，这其中至少一半的原因在于我的拖延，论文实际上在大约五六月份时就已经有了初稿。<strong>自己在一段时间不能兼顾多个任务使得最终放弃了实习，专注于实验室的工作。坦诚地来说，这也是自己需要做出改变的一点。</strong><br/>
经过了2个月的奋战，论文首先经历了HPCA顶级会议的考验。没有做出实际成品之前，一直觉得这个东西有些难度，需要花上很大的工作量才能搞定，可完成之后反过来回顾时会觉得实际做出来的东西真正弄透以后会觉得实际的东西没有那么高大上，只不过是&hellip;.（此处省去1万字）。最终在HPCA的peer review阶段，我们根据reviewer的反馈还是将paper撤了下来，得到了许多我们之前没有考虑过的东西，也发现了一些reviewer的关注点，总体上讲我们的主要目的是达到了——让顶级会议的大牛们看一下你的成果，发表下意见。如果大家都很感兴趣，那么自然很有希望被会议录用，反之也可以得到一些中肯的反驳意见。<br/>
最终我们这篇paper发到了一个C类会议上，结果虽然不是最好的，但也不至于很失望。</p>

<h2>第三学期</h2>

<p>这个学期是“无政府状态”的巅峰时期，几乎完全荒废了学业。这个学期我完全的变成了无业游民般的自由——2012年9月初，论文的事情进入尾声，此时这个学期要进行研究生的毕业开题，因此就没有找实习。这样子整个一个学期只有开题这一个任务。这里还有个背景：我所在的实验室是以学术为唯一目的的实验室，大boss，我的导师的导师，近几年几乎不招收硕士了，“<em>两年半的时间，其中还有一年来上课，半年毕业，做研究的时间太少了</em>”，因而导致<em>曾经人满为患的一个屋子现在几乎是空荡荡的，这个学期到了人最少的一个学期——常驻的学生只有我一个人&hellip;</em><br/>
虽然看起来屋子很宽敞，自己一个人极为自由，可那种只能和空气说话的气氛，人待久了会疯掉的。也就是在这个时候我发现自己一天几乎说不了几句话。（研一开始的时候就没有选择什么课余活动，宿舍的哥们都和我一样，每天宅在各自的实验室，只有晚上的时候会在宿舍）当时的我就很恐慌，怕自己因此变得自闭，与人隔绝了一般。<br/>
于是我决定做出改变，不能为了科学让自己变得脱离社会，要找机会融入集体多和人交流，找人一起玩，而因为硕士生毕业开题的事情自己觉得又不应该离开学校，恰逢第一学年的新学期开始，研究生会开始招新。于是我作为研二的学长参加了研究生会。虽然这个学期学业上几乎完全荒废了，可此时回顾来看，我依旧不后悔当初的决定，如果给我重新选择的机会，我还是会这样选择。<br/>
此后的研究生会的活动中，自从研究生开始就没怎么参加集体活动的我玩的很嗨很投入，自然而然地结交了很多好朋友，认识了许多有意思的人，同时也有机会认识了相当多的其他学院的朋友，我很满足。这里给后来人提一个醒，无论怎样都要找到一个集体，融入进去，无论是学术的还是娱乐的，人不能脱离了群体而存在。我之所以选择加入研究生会，是因为学术上并没有给我提供充分的群体归属感，我只能从其他地方寻找。<br/>
这里不得不提到知乎上的一个精彩回答:<strong>二十多岁该做些什么，将来才不会后悔？</strong><br/>
作者是<a href="http://www.zhihu.com/people/yolfilm">yolfilm</a>, 链接地址：<a href="http://zhi.hu/CddD">http://zhi.hu/CddD</a></p>

<blockquote><p>「一個人」的狀態，總是最糟的。</p>

<p>我覺得說一些我的個人經驗，於你無用，因為環境機遇不同。（多一半，還有自我吹噓的潛意識存在）。但，我可以給你一個，我母親給過我的，非常好的建議。</p>

<p>我母親曾經告誡過我，一個人的狀態，總是最糟的。</p>

<p>你一人吃穿用，一人度日過日，非常容易解決，也非常容易跌入谷底，高興時無人分享，但，失志時，那種惡劣的狀態，卻只能一再重復浸淫。所以，要讓自己振作，第一件事，絕不要長期保持「一個人」的狀態。</p>

<p>再不濟，你養條狗，這狗，都要逼你準時餵牠，準時拉牠出去運動，牠病了，你得給牠奔走求醫。你悲傷時，牠會給你溫暖，分攤你的愁苦。你成功時，牠會哈哈斥斥地笑張大嘴，靜坐在一邊共享你的快樂。</p>

<p>牠是你的責任，也是你的負擔。按我母親說的，就是養條狗，你也不會是「一個人」。</p>

<p>你可以不成家，你可以是失怙孤兒，你可以是找不見伴侶的同性戀，你可以悲慘到無以復加的地步，但，就是到那樣境地，你也要強迫自己，不要是一個人。</p>

<p>孤獨殺手里昂，也要養盆花。</p>

<p>孤獨殺手亞蘭德倫，也要養隻金絲雀。</p>

<p>我個人的經驗是，只要你不是一個人，你即使不成功，但，也絕不會失敗。</p>

<p>我一直記住老娘的教誨，一直在身上背著負擔。搞合唱團時，背著團員，搞劇團時，背著團員，開公司時，背著員工，寫劇本時，背著徒弟，拍戲時，背著債務，背著投資人。成家時，背著老婆孩子。</p>

<p>因為總不是一個人，所以你荒唐不起來，也沒辦法混噩度日。</p>

<p>如此，你謀生求職，你艱辛度日，你的理想事業，就是失敗了，但因為有負擔，不是一個人，只要保全了身上背著這些負擔，另一個層面來說，你也總是成功的。</p>

<p>所以，只要你不是一個人，不是只為自己活，某種層面來說，你永遠不會失敗。</p>

<p>你就是被車撞死了，死在半夜的馬路上，因為你不是一個人，就會至少有一個人在惦記著你。</p>

<p>你的生命，就不會沒有意義。</p></blockquote>

<!--看到了别声张，谢谢
这一学期我认识了我这辈子目前为止最有feel的她。先说下结局吧，我俩没在一起，我搞砸了。直到现在每次回忆起这段往事时都会默默的在心里骂自己是个SB，十足的，我知道即使当初没有那么二，也未必会有更好的结果，但我想至少我不会像现在这样后悔。
我第一次体会到了那种想一个人可以想到废寝忘食，整天魂不守舍，整整2个月的时间，除了研究生会的活动以外，我的生活里面只有她。然而因为自己种种的犯二到荒唐的程度（我常常以爱到失去理性安慰自己）导致我们的额关系经历了大起最终归于尘埃，到现在没有联系。在2013年上半年的时候，我依旧想着可以再重新挽回，虽然也感觉到没有了当初的那么强烈的感觉，可这时已经发现她已有了另一半，自己躁动的心也算是平静了，祝福她幸福，也再次(每次想到这段事我都会做的)对我当时的犯二行为给她造成的伤害表示歉意-->


<p>这个学期玩的太用力，导致整个开题报告做的马马虎虎，给之后的毕业论文埋下了很大的隐患，这是后话。这个学期可以用几个关键词来总结：研究生会、玩、开题报告。</p>

<h2>第四学期</h2>

<p>这学期出国访学一年的导师回来了！这也是我的研究生二年级的最后一个学期。<br/>
这个学期周围很多人开始了毕业前的实习，看到许多人开始实习，我也有些心急了，毕竟我没打算继续读博，因而找到一份理想的工作是我的主要目标。也许每一个初当导师的人都心慈手软吧，或者我的导师本来就是一个很好说话的人，总之这个学期我成功的出去实习了。<br/>
实习的公司很有意思，就是LBE！看过前面的应该都知道我在第二学期实习时花了很久来逆向研究LBE的隐私卫士，对它的技术上有很好的印象。现在来看，LBE团队依旧是具有很强的技术实力。能在LBE实习有很大的偶然——正是在自己在论坛扒实习帖子的时候偶然发现了他们在byr论坛发布的招实习生的帖子，之后才知道这个帖子已经贴了很久，我加入那时候其实他们已经不打算继续招人了的。<br/>
去LBE面试，就是面总本人来面的我（后来才知道的==），结果顺利地通过了，当时非常欣喜，竟然只有一面，因为之前一直以为能做出这么高技术含量的人，一定是一个相当规模的牛逼团队，要进入得具有相当的实力才行。<br/>
就这样，我开始了接近半年时间的实习生活。<br/>
加入LBE后才发现，这是一个不到20人创业型团队，实际开发的不到十人。而且做出隐私卫士第一版主要作者竟然是面总一个人！！膜拜&hellip;加入到LBE，原本就打算以后就从事Android平台的开发了，做个Android Developer。可命运再次向我开了个玩笑。<br/>
进去后，面总想要我来做一键root的三星专版，因为三星手机市占率很高同时三星刷机和升级手机使用的是自己开发的特殊协议Odin，同时该协议已经被国外某位大神逆向出来，制成了Heimdall工具，当时国内还没有哪一家公司使用这种方式root手机，由于当时LBE只有我和面总对Linux这一块熟悉，而他还要继续负责LBE核心应用的开发，因而自然由我来承担这块工作。这也就是我在LBE——一个以Android平台安全软件出名的公司几个月的工作成果——<em>LBE一键root三星专版</em>。而这只和Android平台沾边，<del>一点都不</del>几乎不涉及Java的开发，而主要工作是Linux系统开发、QT完成的Windows桌面应用的维护、还有一系列脚本以及一个后台抓取数据的python程序，基本上可以将这些工作归为后台开发，当然整个过程只是覆盖面很<strong>广</strong>：从<em>Linux平台的脚本</em>、<em>python程序</em>到<em>Windows平台的驱动</em>、<em>QT应用</em>再到Android手机上Framework层下的<em>Android su</em>以及Android平台的<em>Superuser</em>，单独来看哪一个部分涉及的技术要求都不高，但是得懂。<br/>
在LBE实习的这几个月，认识了许多小伙伴，大家也给予了我很多肯定，我很感激大家。唯一让我郁闷的地方是公司的地点离学校太远了，学校在西三环，而公司在东三环，后来又搬到了东四环，每天要坐地铁加步行总共1个多小时才能到，每天有2个半小时时间是在地铁上的，很辛苦。</p>

<!--
在今年的下半年的时候，遇到了很有意思的女孩子。成熟，漂亮，性格偏女汉子，有很强的事业心。
-->


<h2>最后一学期</h2>

<p>9月份研究生最后一个学年（两年半学制）。一到九月份就结束了自己的实习，在暑期的时候就得知和导师合作的那篇论文被会议录用了，会议的地点就在贵阳，因此可以两个人一起去那里参加，很开心。 <br/>
9月初2014年秋季校园招聘就逐渐拉开了大幕，第一波互联网公司的校招接踵而至，首先来的是阿里巴巴——我最向往的互联网公司。自己还曾下豪言，如果拿到阿里的offer真的就别无他求了。与此同时，至于毕业设计嘛，呵呵&hellip;不巧的是阿里校招的笔试时间和那个国际会议的的时间几乎挨着，可为了阿里的校招，果断放弃了去贵州贵阳“免费旅游”的机会。<br/>
就这样9月下旬参加了阿里校招，一周后得到面试通知，面试那天从上午10点一直聊到了中午12点多，感觉还蛮不错的。这时正巧临近十一长假，最终有没有通过面试只有长假之后才会通知。就这样几乎杳无音信的一直到10月18日，终于得到了阿里巴巴发来的短信，拿到了阿里的offer!虽然这几周过得异常虐心和纠结，现在想来也算值了。在等待的这一段时间由于不敢确定阿里是否能给offer，所以还是其他的笔试面试没有掉以轻心，百度、小米和网易的都参加了笔试和面试，因为自己选择的都是Linux内核相关以及底层的东西，因为自己没有实际经验，小米的算是面试之后默拒了，百度的一面就被不明原因莫名其妙的刷掉了，至今还很纳闷，网易等其他的公司都是在收到阿里offer之后才给的面试通知，因此就都没有去。<br/>
之后的事情目前还没有结束，待本学期结束了再做总结吧。</p>

<!--<center>To be continued&#8230;</center>&#8211;>


<p>时光匆匆，现在已到了2014年3月了，在校的日子已经只有几周。恰逢前几日北京严重雾霾天气，真心觉得离开北京可以说是一个正确的选择（也许心理暗示的成分更多些吧）。杭州，我就要来了！<br/>
继续开始总结。
10月到12月，本应该专心做毕业论文的时候基本上却没怎么忙毕业设计，这一段时间一部分精力集中在做一个关于手机root的兼职开发维护工作，中间还夹杂了一个甲骨文的几次面试。最后甲骨文止于最后一面，蛮可惜的。</p>

<!--当然不得不提的是我遇到了一个漂亮，更重要的是性格我也很欣赏的女孩子，遗憾的是以好朋友交往的短短2个月就发生了数次分分合合，看来有些事真的强求不来，她在一些事上总是很强势，她的心思更在自己的实习工作和学习生活上，我的地位总是卑微的，在11月中下旬的时候终于在一次争吵中结束。
-->


<p>可以说确定offer后的这一段时间里是研究生阶段里最堕落的一段时间了：上午10点左右起床，到实验室也快中午，上上微博看看新闻就去吃午饭，然后下午做一些事情，晚上便又开始玩了起来。毕业设计的进度极为缓慢，过了年末才慢慢的抓紧时间了。这应该算是一个典型拖延症患者的自白了吧。<br/>
幸好这一段时间一直使用印象笔记做每天的时间流水账，回顾可以看到每天差不多专心工作的时间大概在3小时上下，有时还不到这个数。完全可以说这个学期专注工作的能力已经残了&hellip;<br/>
就这样，到了1月中下旬为了逃避论文的压力，我早早的启程回家了。事实证明，这是个极错误的决定。1月19日到家后，我才发现家里的环境远远不如学校实验室，在家里甚至连个像样的桌子也没有。而这时候正好是春节前夕，因此更加的不想做毕设了，可心里又很清楚年后就要毕业答辩了，这样纠结的情绪一直弥漫于整个在家的假期之中，以至于春节的那几天躺在床上回想时“想到实验还没做出来，不到几周就要答辩了，这是要悲剧的节奏啊！！！”，于是我失眠了。年三十的时候和导师做了电话沟通，我像个犯了错误的孩子一样忏悔了自己的无作为，于是我和导师研究了毕业论文的解决方案。我们选择了改变策略，做不到预想的实验就不做了，把已有的实验结果加上去也算完整。沟通之后，忐忑的心总算平静了一些。<br/>
本来已经订了农历十六返程车票，因为爷爷家出了一些事，临时改变了计划，当时一想反正也要退票，不如直接提前回校了。后来证明这是最后时刻做出的正确选择。<br/>
就这样我农历十二就到校了。可是对我来说，这依旧没有到<em>最后时刻</em>，每天还是会开小差，到了2月12日，论文的初稿还没有弄出来。这时候开始了爆发突击模式，2月13日到2月17日这几天每天都搞到很晚，还通宵了两次，总算在2月17日交了初稿，并且于2月18日通宵完成修订稿，2月20日发出外审。在最后时刻及时完成了毕业论文。2月27日顺利过了毕业答辩。<br/>
毕业论文的预想和最终稿内容有许多不同，但是依然还是有三万多字的内容，很充实。也就是说没有完成之前预想的实验也达到了毕业的水平，而且内容充实。我的论文题目开的不怎么好，题目太大了，涵盖了许多方面的内容。起初论文的设想是把这几个方面完整的做出来，由于完成实验需要高出自己能力和精力的付出以及自己对毕业论文的期望（及格就行）远低于导师对论文水准的期望，所以我一直在拖延着。直到最后时刻，我只把已经做出的东西写进去才发现工作量已经足够毕业了——如果真的按照起初论文的设想完成的话，我不敢说那是一个博士生的工作量，但两三个硕士生毕业是没有问题的。<br/>
不管怎样，事情已经过去，说什么都要算作是马后炮了。<br/>
总结来说，这个学期让我认识到一个人习性的改变是多么的困难——现在的毕业答辩可以说和本科时准备毕业论文时的狼狈很相似。当时信誓旦旦的要改变自己，要改掉逃避压力的习性，几年过去了，起色不大。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Kernel概览]]></title>
    <link href="http://liuyix.org/blog/2013/linux-kernel-overview/"/>
    <updated>2013-10-22T20:19:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/linux-kernel-overview</id>
    <content type="html"><![CDATA[<blockquote><p>总结下读过的有关Kernel的书籍，主要是<a href="http://book.douban.com/subject/2287506/">&lt;Understanding the Linux Kernel></a>>、<a href="http://book.douban.com/subject/6097773/">&lt;Linux Kernel Development></a>、<a href="http://book.douban.com/subject/1723151/">&lt;Linux Device Drivers></a></p></blockquote>

<h3>终极目标</h3>

<p>完整的回答以下问题：</p>

<ul>
<li>从开机上电到进入命令提示行，Linux完整的启动过程</li>
<li>Linux终端下敲入<code>ls</code>的完整过程。(从接收键盘设备中断到显示到结果显示到屏幕)</li>
<li>Linux终端下输入<code>cat foo.txt</code>的完整过程。(同上，其中包含了读写磁盘的操作)</li>
<li><em>to be continued&hellip;</em></li>
</ul>


<!--more-->


<h3>内核态/用户态</h3>

<p>Intel x86有4种不同的状态，Unix内核只使用内核态和用户态。</p>

<p>内核线程：</p>

<ul>
<li>内核态在内核地址空间执行</li>
<li>不与用户直接交互，无须终端设备</li>
<li>通常在系统启动时创建，一直活跃直到系统关闭</li>
</ul>


<p>陷入内核态的几种方式：</p>

<ul>
<li>用户态进程调用<code>syscall</code>系统调用</li>
<li>遇到<code>Exception</code>(无效指令、越界访问、除数为0等)：内核会代表进程处理异常</li>
<li>外设向CPU发出<code>interrupt</code></li>
<li>执行内核线程</li>
</ul>


<h3>进程实现</h3>

<p>当进程暂停时，将表征进程状态的寄存器保存到<strong>进程描述符</strong>中，其中包括：程序计数器、栈指针寄存器、通用寄存器、CPU状态信息的控制寄存器（处理器状态字）以及内存管理寄存器。当需要恢复进程执行时，再将保存的字段恢复即可。</p>

<h3>可重入内核</h3>

<p>可重入内核可以包含非可重入代码，需要利用锁机制。</p>

<p><em>Kernel Control Path</em> 内核控制路径表示内核态中内核进行的任务类型：处理syscall、异常、中断处理程序。 <br/>
内核控制路径可以交错执行。</p>

<h3>进程地址空间</h3>

<p>每个进程有“私有”的地址空间，用户态下：私有栈、数据区、代码区；内核态：内核的数据区和代码区、<strong>进程内核栈</strong></p>

<p>在进程的角度上每个进程都是独立的地址空间，但是内核管理上未必是独立的，有可能是共享。</p>

<h3>同步和临界区</h3>

<p>利用同步机制防止多个内核控制路径破坏全局的内核数据结构。</p>

<ul>
<li>非抢占式内核</li>
<li>禁止中断</li>
<li>信号量</li>
<li>自旋锁</li>
<li>避免死锁：Linux通过按规定的顺序请求信号量避免死锁。</li>
</ul>


<h3>信号和IPC</h3>

<p><em>信号机制</em>将系统事件报告给进程的机制。系统事件分为两种：异步通告(SIGINT),同步错误或异常。</p>

<p>进程间通信的机制：信号量、信息队列、共享内存；标准有两种：System V IPC和POSIX</p>

<h3>进程管理</h3>

<ul>
<li><code>fork</code></li>
<li><code>exec</code></li>
<li><code>_exit</code></li>
<li><code>wait4</code></li>
<li>zombie进程</li>
<li><em>process group</em></li>
<li><em>login session</em></li>
</ul>


<h3>内存管理</h3>

<h4>虚拟内存</h4>

<blockquote><p>虚拟内存(virtual memory) 作为一种逻辑层，处于应用程序的内存请求与MMU(Memory Management Unit，硬件内存管理单元)之间。</p></blockquote>

<h4>RAM的使用</h4>

<p>RAM中有一部分存放内核映像部分(内核代码和内核数据结构)。其余部分有三种不同的作用：</p>

<ul>
<li>内核使用</li>
<li>进程使用</li>
<li>磁盘和其他设备的高速缓存</li>
</ul>


<h4>KMA: Kernel Memory Allocator</h4>

<p>KMA内核内存分配器子系统用来处理所有的内存请求，其中包括内核内其他子系统、用户进程通过syscall请求增加内存使用的请求。</p>

<p>KMA的特点：</p>

<ul>
<li>快</li>
<li>省,浪费最少</li>
<li>尽量无碎片</li>
<li>可以同其他内存管理子系统合作</li>
</ul>


<h4>进程虚拟地址空间处理</h4>

<p><strong>尽可能的“懒”的做法</strong> ：必要时才做耗时的工作(COW和demand paging策略)，如果必须要做耗时的工作就多做些(预读取机制)</p>

<ul>
<li>demand paging内存分配策略：进程可在页没有载入主存下执行，当访问到不存在的页时，发生缺页中断，之后中断处理程序将页载入到内存。</li>
<li>COW写时复制策略</li>
</ul>


<h4>高速缓存</h4>

<ul>
<li>推迟写回磁盘的操作</li>
<li><code>sync</code> 调用</li>
</ul>


<h3>设备驱动程序</h3>

<p><img src="http://liuyix.org/images/device-driver-interface.bmp" alt="/images/device-driver-interface.bmp" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[百度校招-系统研发工程师-笔试题]]></title>
    <link href="http://liuyix.org/blog/2013/baidu-exam-review/"/>
    <updated>2013-10-15T01:36:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/baidu-exam-review</id>
    <content type="html"><![CDATA[<p>几道编程算法题：</p>

<ul>
<li>实现类似wget一样的进度条</li>
<li>100亿个单词，每个单词长度小于30，输出去重后的所有单词。</li>
</ul>


<!--more-->


<h3>实现类似wget进度条</h3>

<blockquote><p>当时没有想出来，回来才搜索之后才知道考察的是对转义符的理解。</p></blockquote>

<p>关于换行，话题看起来看似简单，但实际内容不少。</p>

<p><strong>主流操作系统文本换行的差异</strong></p>

<table>
<thead>
<tr>
<th></th>
<th> OS </th>
<th> 按下回车后插入的控制字符 </th>
<th> 含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Windows </td>
<td> <code>\r\n</code> </td>
<td> 0x0D 0x0A <em>CR LF</em> </td>
</tr>
<tr>
<td></td>
<td> Linux </td>
<td> <code>\n</code> </td>
<td> 0x0D <em>LF</em> </td>
</tr>
<tr>
<td></td>
<td> Mac OSX </td>
<td> <code>\r</code> </td>
<td> 0x0D <em>CR</em> </td>
</tr>
</tbody>
</table>


<p>因此你经常会遇到Windows下用notepad看某些Linux编辑的文本，都没有换行。</p>

<p>基本的内容就这么多，如何实现wget的进度条即是在Linux下用<code>\r</code>而不用<code>\n</code>，这样会不断的将新内容输出到同一行，从而达到“刷新”的效果。</p>

<figure class='code'><figcaption><span>demo.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//类似wget的进度条的实现，实际就是转移符\r的使用，\r的作用是返回至行首而不换行</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">bar</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">bar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;#&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;progress:[%s]%d%%</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bar</span><span class="o">+</span><span class="n">len</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>        <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span><span class="c1">//一定要fflush，否则不会会因为缓冲无法定时输出。</span>
</span><span class='line'>        <span class="n">usleep</span><span class="p">(</span><span class="mi">100000</span><span class="p">);</span><span class="c1">// 睡眠100ms</span>
</span><span class='line'>        <span class="c1">//sleep(1);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>给定100亿个单词，每个单词长度小于30，输出去重后的所有单词序列。</h3>

<p>面试准备不充分，这是trie树的最典型的题目了。
更多的信息可以看July的文章。
<a href="http://blog.csdn.net/v_july_v/article/details/6897097">http://blog.csdn.net/v_july_v/article/details/6897097</a></p>
]]></content>
  </entry>
  
</feed>
