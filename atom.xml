<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Liuyix]]></title>
  <link href="http://liuyix.org/atom.xml" rel="self"/>
  <link href="http://liuyix.org/"/>
  <updated>2015-04-06T10:39:28+08:00</updated>
  <id>http://liuyix.org/</id>
  <author>
    <name><![CDATA[liuyix]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[git workflow]]></title>
    <link href="http://liuyix.org/blog/2015/git-workflow/"/>
    <updated>2015-04-05T23:30:00+08:00</updated>
    <id>http://liuyix.org/blog/2015/git-workflow</id>
    <content type="html"><![CDATA[<p>Git近几年有逐渐取代svn的趋势，一部分原因是github的风靡，google code也关门大吉，令人唏嘘<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。很多公司开始逐渐从svn代码仓库迁移到企业私有版的github&mdash;<a href="https://gitlab.com/">gitlab</a>。知道怎么玩git是大势所趋。</p>

<p>Git小白推荐读物：atlassian出版的<a href="https://www.atlassian.com/git/tutorials">Git Tutorials</a>，这家公司拥有mac上最佳git客户端SourceTree以及Bitbucket。</p>

<p>本文是对<a href="https://www.atlassian.com/git/tutorials/comparing-workflows">Comparing Workflows</a>这篇文章和自己的使用心得所做的总结。</p>

<p>以下三种工作流只是典型的代表，不是规范，而是参考，可以结合自己的使用特点灵活选择和修改。</p>

<ul>
<li>Centralized Workflow</li>
<li>Feature Branch Workflow</li>
<li>Gitflow</li>
</ul>


<!--more-->


<h3>Centralized Workflow</h3>

<ul>
<li>适合几个人的小项目或者自己玩。</li>
<li>和svn差别小。</li>
<li>多人协作采用rebase方式并入master。

<ul>
<li>小李和小红分别把代码拉到本地进行开发，然后小李先提交到了master，这时候小红再提交她的修改会被reject，因为push的过程中小红本地的Master分支和remote（服务器）上的不同。这时候小红需要<code>git pull --rebase origin master</code>将远程的代码和她本地的修改进行融合，融合的目的是让小红提交的所有的commit看起来实在小李同学push到master分支后的那个点开始做的。</li>
</ul>
</li>
</ul>


<p><img src="https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/centralized-workflow/11.svg" alt="小红在小李之后push到master" /></p>

<h3>Feature Branch Workflow</h3>

<ul>
<li>适合几个人的小项目。</li>
<li>利用<em>pull request</em>进行code review和交流改进。</li>
</ul>


<p>相比<em>Centralized Workflow</em>，这个工作流没有增加多少内容，只是在merge过程时一定要创建<code>pull request</code>让大家可以有个代码review和交流修改的过程。</p>

<h3>Gitflow</h3>

<p>比较适合多人的大型项目。</p>

<p><img src="http://nvie.com/img/git-model@2x.png" title="git branching model" alt="git branching model" /></p>

<ul>
<li>master</li>
<li>develop</li>
<li>release</li>
<li>feature</li>
<li>bugfix</li>
</ul>


<!-- 一个例子是线上生产稳定的跑着1.2版本（master分支），开发和测试主要活跃在develop分支，产品路线图中计划的下个月的1.3版本的发布是develop的一个release分支。在1.3版本中总共加入了3个feature和5个bugfix，总共由4个人负责代码开发。-->




<!--2个主要分支：master和develop。master分支对应生产环境跑的代码，很像rpm包的`current channel`；develop对应的就是rpm发布的`test channel`，feature和release在完成后都会并入到develop分支。-->



<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>http://google-opensource.blogspot.com/2015/03/farewell-to-google-code.html<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL 5.6 GTID 学习笔记]]></title>
    <link href="http://liuyix.org/blog/2014/mysql-gtid-introduction/"/>
    <updated>2014-09-20T18:45:00+08:00</updated>
    <id>http://liuyix.org/blog/2014/mysql-gtid-introduction</id>
    <content type="html"><![CDATA[<h3>Reading List</h3>

<ul>
<li>Facebook部署5.6 GTID的blog: <a href="https://www.facebook.com/notes/mysql-at-facebook/lessons-from-deploying-mysql-gtid-at-scale/10152252699590933">Lessons from Deploying MySQL GTID at Scale</a>(需要翻墙)

<ul>
<li>Facebook@Percona Live 2014 <a href="http://www.percona.com/live/mysql-conference-2014/sessions/global-transaction-id-facebook">GLOBAL TRANSACTION ID AT FACEBOOK</a></li>
<li>MySQL Manual使用时GTID时的限制：<a href="http://dev.mysql.com/doc/refman/5.6/en/replication-gtids-restrictions.html">17.1.3.4 Restrictions on Replication with GTIDs</a></li>
</ul>
</li>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash Tips]]></title>
    <link href="http://liuyix.org/blog/2014/bash-tips/"/>
    <updated>2014-09-14T16:59:00+08:00</updated>
    <id>http://liuyix.org/blog/2014/bash-tips</id>
    <content type="html"><![CDATA[<h3>Bash 遇到错误就退出</h3>

<p><a href="http://stackoverflow.com/a/4382179">http://stackoverflow.com/a/4382179</a></p>

<p><code>set -e</code></p>

<blockquote><p>If you put set -e in a script, the script will terminate as soon as any command inside it fails (i.e. as soon as any command returns a nonzero status). This doesn&rsquo;t let you write your own message, but often the failing command&rsquo;s own messages are enough.</p>

<p>The advantage of this approach is that it&rsquo;s automatic: you don&rsquo;t run the risk of forgetting to deal with an error case.</p>

<p>Commands whose status is tested by a conditional (such as if, &amp;&amp; or ||) do not terminate the script (otherwise the conditional would be pointless). An idiom for the occasional command whose failure doesn&rsquo;t matter is command-that-may-fail || true. You can also turn set -e off for a part of the script with set +e.</p></blockquote>

<h2>Bash使用数组</h2>

<h3>快速入门</h3>

<p>(Bash For Loop Array: Iterate Through Array Values)[<a href="http://www.cyberciti.biz/faq/bash-for-loop-array/">http://www.cyberciti.biz/faq/bash-for-loop-array/</a>]</p>

<ul>
<li>用括号指定，空格指定就好</li>
<li>遍历： <code>for i in "${var[@]}"</code></li>
</ul>


<h3>深入</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'># array-ops.sh: More fun with arrays.
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>array=( zero one two three four five )
</span><span class='line'># Element 0   1   2    3     4    5
</span><span class='line'>
</span><span class='line'>echo ${array[0]}       #  zero
</span><span class='line'>echo ${array:0}        #  zero
</span><span class='line'>                       #  Parameter expansion of first element,
</span><span class='line'>                       #+ starting at position # 0 (1st character).
</span><span class='line'>echo ${array:1}        #  ero
</span><span class='line'>                       #  Parameter expansion of first element,
</span><span class='line'>                       #+ starting at position # 1 (2nd character).
</span><span class='line'>
</span><span class='line'>echo "--------------"
</span><span class='line'>
</span><span class='line'>echo ${#array[0]}      #  4
</span><span class='line'>                       #  Length of first element of array.
</span><span class='line'>echo ${#array}         #  4
</span><span class='line'>                       #  Length of first element of array.
</span><span class='line'>                       #  (Alternate notation)
</span><span class='line'>
</span><span class='line'>echo ${#array[1]}      #  3
</span><span class='line'>                       #  Length of second element of array.
</span><span class='line'>                       #  Arrays in Bash have zero-based indexing.
</span><span class='line'>
</span><span class='line'>echo ${#array[*]}      #  6
</span><span class='line'>                       #  Number of elements in array.
</span><span class='line'>echo ${#array[@]}      #  6
</span><span class='line'>                       #  Number of elements in array.
</span><span class='line'>
</span><span class='line'>echo "--------------"
</span><span class='line'>
</span><span class='line'>array2=( [0]="first element" [1]="second element" [3]="fourth element" )
</span><span class='line'>#            ^     ^       ^     ^      ^       ^     ^      ^       ^
</span><span class='line'># Quoting permits embedding whitespace within individual array elements.
</span><span class='line'>
</span><span class='line'>echo ${array2[0]}      # first element
</span><span class='line'>echo ${array2[1]}      # second element
</span><span class='line'>echo ${array2[2]}      #
</span><span class='line'>                       # Skipped in initialization, and therefore null.
</span><span class='line'>echo ${array2[3]}      # fourth element
</span><span class='line'>echo ${#array2[0]}     # 13    (length of first element)
</span><span class='line'>echo ${#array2[*]}     # 3     (number of elements in array)
</span><span class='line'>
</span><span class='line'>exit</span></code></pre></td></tr></table></div></figure>


<p>(Arrays)[<a href="http://www.tldp.org/LDP/abs/html/arrays.html">http://www.tldp.org/LDP/abs/html/arrays.html</a>]</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[拖延的反思]]></title>
    <link href="http://liuyix.org/blog/2014/procrastination-helps/"/>
    <updated>2014-09-14T11:39:00+08:00</updated>
    <id>http://liuyix.org/blog/2014/procrastination-helps</id>
    <content type="html"><![CDATA[<p>昨天在多看阅读中看到的一篇关于拖延症的文章&mdash;《“被绑架”了的拖延症患者 &mdash; 爱上拖延症的八个理由》。原始出处已无法考据，感谢原作者的分享。在网上找到了一个<a href="http://talk.ifeng.com/zaixianjiangtang/shys/special/tuoyanzheng/zuixin/detail_2012_10/30/18669615_0.shtml">引用链接</a>。</p>

<p>之前也正好看到了李松蔚在微信公众账号里面发表的拖延症系列文章中的《框架中的拖延者（3）：和解，无关明日》，二者有想通之处：拖延是内心不和谐的表征，造成拖延一定有更深层次的原因。如果发生拖延了不深究原因只一味的自责，那么拖延只会恶化，身心不会得到解脱，真正的“病因”因此会一直纠缠着自己。</p>

<p>在《被绑架》一文中，笔者就内省自己拖延的原因，勇敢的做出了改变。</p>

<p>笔者自述自己拖延中大部分时间是用来玩游戏、听音乐、看电影、读文章、读书。相比于『有意义的工作』，笔者把这作为自己内省和成长的一部分。</p>

<p>这一点上我部分赞同，不想工作必然有其他可理解的原因，不仅仅是『找回属于自己的时间』。我觉得拖延不做工作，尤其是周末。有可能是自己的身体在通过『懒惰小人』告诉自己需要休息放松。<em>人不是机器，一般情况下很难长期保持高强度的工作。</em></p>

<p>在“行为和内心一致”这一节中，笔者在工作中发现越来越讨厌工作，逃避工作。</p>

<blockquote><p>这一阶段的拖延虽然还有漫无目的的无聊，但更多的是一些有意识地利用拖延下来的时间学习哲学、心理学或者英语和写作等相关技能
事后从这个角度看，事情甚至完全反过来，就像是为了获得收入和安全感拖延了我的学习时间而去做无趣的工作。</p></blockquote>

<p>笔者确实发现了自己不喜欢自己的工作。（事后也用自己的行动的结果说明了自己在其他领域有更好的发展。）但是通常而言无论是什么事，总有你不愿意做的部分和喜欢做的部分。认清自己内心到底喜欢做什么并能持之以恒，这是需要智慧的。若是缺乏智慧，则误把因为“懒”做事挑肥拣瘦当做这不是我喜欢做的工作。今天从银行辞职该做摄影师，坚持不了多久又觉得摄影不是真正喜欢的事情，又改写小说&hellip;<br/>
用智慧做出判断，用勇气做出改变相比治疗拖延症是更重要的。
关于如何甄选自己喜欢的职业，建议读一读<a href="http://book.douban.com/subject/4953695/">《拆掉思维里的墙》</a>这本书。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[积跬步至千里]]></title>
    <link href="http://liuyix.org/blog/2014/keep-doing-make-miracle/"/>
    <updated>2014-09-13T21:19:00+08:00</updated>
    <id>http://liuyix.org/blog/2014/keep-doing-make-miracle</id>
    <content type="html"><![CDATA[<p>焦虑的我今天冥冥中发现了BYVoid的github，进而去他的博客兜了一圈，感触良多。先介绍下背景。</p>

<p>BYVoid这个人是去年校招时听闻的。那时刚参加完阿里的校招，还没有出结果，焦急的等待中持续关注着北邮人论坛的有关阿里校招的消息。那个时候不知阿里内部哪位好事者漏出了一张阿里校招时给出A+ offer的面试后台系统记录截图。（A+就是去年阿里校招的阿里星计划，60W年薪+股票期权），这个八卦中的主角就是郭家宝，网名BYVoid。一个九零后的清华本科生，本科的假期在MSRA，Google，Hulu，Facebook有过实习经历，初高中参加信息学竞赛，后来保送到清华。还出过一本书<a href="http://book.douban.com/subject/10789820/">《Node.js开发指南》</a>。<br/>
关于他个人的更多介绍，可以看下他的博客介绍：<a href="https://www.byvoid.com/zht/about/resume">链接</a>以及他的报告<a href="https://byvoid.github.io/slides/experiences-2014/index.html">《我的一些经历》</a></p>

<p>我最感兴趣的是<em>一个牛人是如何成长的</em>，<em>他的博客文章的质量是如何提高的</em>。进到博客一看发现这位新秀从2007年就开始写博客了(2010年才上大学)。于是我就从最后面的文章开始翻起来，有种在读别人的日记的赶脚&hellip;（兴致勃勃的去看一个本科毕业生在初三时写的文章，没有这种赶脚才怪呢）BYVoid<br/>
这几年确实没少写。每个月有十几篇二十几篇的数量。</p>

<p>花了一个晚上的时间把所有的文章题目过了一遍。感触挺多:
技术牛人其实也是普通人，只是做事更加深入、认真，专注一些和坚持久一些『罢了』。</p>

<h4>履历</h4>

<p>BYVoid初中一次偶然的机会，他的老师发现了他在信息学上的天分（拿出一张卷子让他做，结果竟然很多都做对了，后来才知道这是去年的信息学竞赛试题）。也许就是这样的契机让郭同学的人生轨迹变得和同龄人与众不同。之后郭家宝同学通过竞赛保送到省实验中学，之后的高中几年就一直在做信息学竞赛。从他的博客上来看，BYVoid不仅是有天分，本身也很喜欢信息学竞赛，解数学题。他不仅做了老师要求的内容，还在课下自己主动刷题训练（高中的文章很多都是UASCO解题报告）。高中联赛名次不错，最后联赛超常发挥拿到了国家比赛的金牌，靠这块金牌顺利的保送到了清华大学，这时的他才高中二年级。接下去的一年和很多人不同的是，他不再有高考压力，于是在看新白娘子传奇的过程中，发现了自己对汉语字体的兴趣，逐渐开始了汉字研究。到了大学，还保持着这份兴趣。建立了至今广为使用的Opencc开源项目。<br/>
<em>良好的编程功底</em>加上清华大学计算机系拥有的资源，BYVoid在MSRA, Hulu, Google, Facebook都做过实习。今年毕业的他应该是去了瑞士Google（从他的LinkedIn了解到的）</p>

<h4>感悟</h4>

<ul>
<li>不怀目的的写作是最真实的成长记录，<a href="https://www.byvoid.com/zhs/blog/read-rss">这篇文章</a>就是很好的一个例子。</li>
<li>任何人都是从基础逐渐开始成长。写作的能力也一样，长文写作也是一点点培养建立的，BYVoid自己也做了几年博客文章的一个总结（<a href="https://www.byvoid.com/zhs/blog/my-blog-four-years">link</a>）。技能的提高都是通过不断的坚持练习达到的。对于写作来说只有不断的写，开始时也许文字会短小、不连贯，包含很多主观的随感以及转载。但是不断的坚持，慢慢的开始有了深度和广度。在BYVoid的博客中我看到了<strong>每一个阶段都是真实的表现了自己同期的水平和状态</strong>，一个初中生不会一开始就会写出有研究深度的文章和报告而是会写出介绍环境搭建、介绍Vim用法等入门心得。没有刻意地训练只是日积月累的写作，量变终会得到质变。写就<a href="https://byvoid.github.io/slides/cassandra/index.html"><Cassandra></a>、<a href="https://byvoid.github.io/slides/bitcoin-internals/index.html">Bitcoin Internals</a>这样的Slides。</li>
<li><strong>兴趣</strong>、<strong>自我驱动</strong>更有可能成为领域达人。退一步讲成为不了达人，自己也可以自得其乐。这也是『过程比结果重要』的一种诠释吧。兴趣使然 &mdash;> 深入研究 &mdash;> 升华提高。</li>
<li><strong>持久</strong>和<strong>钻研</strong>的个性是能力持续提高的秘诀。拥有兴趣而没有持之以恒的坚持也很难成为一位达人（当然也可以将持久作为兴趣定义的属性）。这些文章 <a href="https://www.byvoid.com/blog/string-hash-compare">Hash函数比较</a>，<a href="%E7%A0%B4%E8%A7%A3Firefox%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8%E5%8A%A0%E5%AF%86%E7%9A%84%E4%BF%A1%E6%81%AF">破解Firefox密码管理器加密的信息</a>，<a href="https://www.byvoid.com/zhs/blog/firefox-js">CmYkRgb123 Online Grading System</a> ，还有OpenCC 不仅能看出他的兴趣也能感受到一份钻研的热情。</li>
</ul>


<p>拥有足够浓厚的兴趣和一个非功利的健康心态很容易成为某一领域的达人。但是如果没有这些，只要你：持之以恒、不浮躁、耐心、钻研、自我驱动也一样可以达成。</p>

<h3>『我不追求输赢，我只是认真』</h3>

<p>『钻研』是BYVoid给我印象最深的一点。作为一种个性，不仅是在技术能力上体现，会在生活的很多方面能感受得到。高中信息学竞赛时，他把NOIP2000到2007年所有题都做了一遍<a href="https://www.byvoid.com/blog/noip-allsolutions/">link</a> 并整理出来这个就不是所有人都能做到的。还有他特别爱玩仙剑奇侠传游戏，这个很多人都爱玩，但是很少有人像他这样详细相关的情节、剧情都详细写成评测文章，<a href="https://www.byvoid.com/blog/pal4-experience">仙剑四</a>，<a href="https://www.byvoid.com/zhs/blog/tag/%E4%BB%99%E5%8A%8D%E4%BA%94">仙剑五系列</a>。或者看一部电影做一个影评<a href="https://www.byvoid.com/zhs/blog/under-the-hawthorn-tree">山楂树之恋</a>。还体现在文字的研究上，从他的<a href="https://www.byvoid.com/zhs/blog/xb-word-pron">第一篇文章</a>，之后有了OpenCC——<a href="https://www.byvoid.com/zhs/blog/open-chinese-convert">文章link</a>，在简繁字体的研究一直持续着。</p>

<p>因为没有看到合适的介绍node.js的书籍，也恰逢认识了图灵图书的编辑，于是促成了一本Node.js开发指南的诞生。这让我想到『机会总是留给有准备的人』。</p>

<p>所以成就一个牛人主要是一个人身上的某种品质——如BYVoid的钻研，而不仅仅是兴趣。</p>

<h3>一些博客链接</h3>

<ul>
<li><a href="https://www.byvoid.com/zhs/blog/new-year-2009">2008年总结</a>，2008年年末开始刷POI，2009年开始写比较长的解题报告，匈牙利算法，很认真的画了图，写了很详细，很认真</li>
<li>2009年近半年的近期总结-<a href="https://www.byvoid.com/zhs/blog/summary-2009-3">https://www.byvoid.com/zhs/blog/summary-2009-3</a></li>
<li>一次吐槽 &mdash; <a href="https://www.byvoid.com/zhs/blog/sequence-mad">https://www.byvoid.com/zhs/blog/sequence-mad</a></li>
<li>NOI2009 &mdash; <a href="https://www.byvoid.com/zhs/blog/noi-2009%EF%BC%8Chttps://www.byvoid.com/zhs/blog/noi-ssc-exp">https://www.byvoid.com/zhs/blog/noi-2009%EF%BC%8Chttps://www.byvoid.com/zhs/blog/noi-ssc-exp</a></li>
<li>语言研究的第一篇文章 &mdash; <a href="https://www.byvoid.com/zhs/blog/xb-word-pron%EF%BC%8C%E4%B9%8B%E5%90%8E%E6%85%A2%E6%85%A2%E5%BC%80%E5%A7%8B%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E8%AF%AD%E8%A8%80%E4%BA%86%EF%BC%8C%E6%9C%89%E8%B6%A3%E7%9A%84%E4%B8%80%E7%AF%87https://www.byvoid.com/zhs/blog/bh-diao-cao%EF%BC%8C%E4%B9%8B%E5%90%8E%E5%B0%B1%E4%B8%80%E7%9B%B4%E5%9C%A8%E7%A0%94%E7%A9%B6%E7%AE%80%E7%B9%81%E5%AD%97%E4%BD%93">https://www.byvoid.com/zhs/blog/xb-word-pron%EF%BC%8C%E4%B9%8B%E5%90%8E%E6%85%A2%E6%85%A2%E5%BC%80%E5%A7%8B%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E8%AF%AD%E8%A8%80%E4%BA%86%EF%BC%8C%E6%9C%89%E8%B6%A3%E7%9A%84%E4%B8%80%E7%AF%87https://www.byvoid.com/zhs/blog/bh-diao-cao%EF%BC%8C%E4%B9%8B%E5%90%8E%E5%B0%B1%E4%B8%80%E7%9B%B4%E5%9C%A8%E7%A0%94%E7%A9%B6%E7%AE%80%E7%B9%81%E5%AD%97%E4%BD%93</a></li>
<li>有自己开发维护的系统：<a href="https://www.byvoid.com/zhs/blog/vakuum-dev-note-02">https://www.byvoid.com/zhs/blog/vakuum-dev-note-02</a></li>
<li>2010年6月开启了OpenCC项目 <a href="https://www.byvoid.com/zhs/blog/open-chinese-convert">https://www.byvoid.com/zhs/blog/open-chinese-convert</a></li>
<li>讲述自己与汉语 <a href="https://www.byvoid.com/zhs/blog/i-and-chinese-language">https://www.byvoid.com/zhs/blog/i-and-chinese-language</a></li>
<li>2011年11月份的博客质量很高

<ul>
<li><a href="https://www.byvoid.com/zhs/blog/godel-incompleteness-theorems-agnosticism">https://www.byvoid.com/zhs/blog/godel-incompleteness-theorems-agnosticism</a></li>
<li><a href="https://www.byvoid.com/zhs/blog/rdbms-isolation-lock-concurrency">https://www.byvoid.com/zhs/blog/rdbms-isolation-lock-concurrency</a></li>
</ul>
</li>
<li>仙剑五总结 <a href="https://www.byvoid.com/zhs/blog/pal5-comment">https://www.byvoid.com/zhs/blog/pal5-comment</a></li>
<li>写书小记 &mdash; <a href="https://www.byvoid.com/zhs/blog/compose-a-book">https://www.byvoid.com/zhs/blog/compose-a-book</a></li>
<li><a href="https://www.byvoid.com/zhs/blog/why-functional-programming">https://www.byvoid.com/zhs/blog/why-functional-programming</a></li>
<li><a href="https://www.byvoid.com/zhs/blog/i-and-chinese-language">https://www.byvoid.com/zhs/blog/i-and-chinese-language</a></li>
<li>影评山楂树之恋 <a href="https://www.byvoid.com/zhs/blog/under-the-hawthorn-tree">https://www.byvoid.com/zhs/blog/under-the-hawthorn-tree</a></li>
<li>2012年的总结 **<a href="https://www.byvoid.com/zhs/blog/recent-one-year**">https://www.byvoid.com/zhs/blog/recent-one-year**</a></li>
<li><a href="https://www.byvoid.com/blog/treasure-young-days/">https://www.byvoid.com/blog/treasure-young-days/</a></li>
<li>美国之行系列： <a href="https://www.byvoid.com/blog/usa-tour-impress">https://www.byvoid.com/blog/usa-tour-impress</a></li>
<li>海外面试经历 <a href="https://www.byvoid.com/zhs/blog/oversea-internship-interviews">https://www.byvoid.com/zhs/blog/oversea-internship-interviews</a></li>
<li>绥芬河出国 <a href="https://www.byvoid.com/zhs/blog/archive/2014/1">https://www.byvoid.com/zhs/blog/archive/2014/1</a></li>
<li><a href="http://www.qyer.com/u/1754807/footprint">http://www.qyer.com/u/1754807/footprint</a></li>
<li>整个高中的经历：

<ol>
<li> <a href="https://www.byvoid.com/zhs/blog/my-highschool-1">https://www.byvoid.com/zhs/blog/my-highschool-1</a></li>
<li> <a href="https://www.byvoid.com/blog/my-highschool-2">https://www.byvoid.com/blog/my-highschool-2</a></li>
<li> <a href="https://www.byvoid.com/blog/my-highschool-3">https://www.byvoid.com/blog/my-highschool-3</a></li>
<li> <a href="https://www.byvoid.com/blog/my-highschool-4">https://www.byvoid.com/blog/my-highschool-4</a></li>
<li> <a href="https://www.byvoid.com/blog/my-highschool-5">https://www.byvoid.com/blog/my-highschool-5</a></li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[明日迷的一天]]></title>
    <link href="http://liuyix.org/blog/2014/work-review/"/>
    <updated>2014-09-13T13:09:00+08:00</updated>
    <id>http://liuyix.org/blog/2014/work-review</id>
    <content type="html"><![CDATA[<p>上一篇博客还是在1月份，转眼已经大半年过去了。大概曾经有兴趣关注本人的也都没什么兴致了吧，呵呵。 <br/>
不禁有些感慨。 <br/>
对一个人的真正了解，无论是了解他人还是认识自己，从行动上看的最真实的。我以为自己爱写字、爱表现。可是从博客的更新频度和质量上来看，这些只是内心的美好想法，说的不好听就是“幻觉”。能真正认识自己很难。而且与这相比，更难的是认识了之后接受这样的自己。</p>

<p>前几天在微信中读到的印象很深的是李松蔚先生在微信公众账号里面的一篇文章<a href="https://app.yinxiang.com/shard/s3/sh/26f47ed4-d76e-4c39-8dd6-bda46e068ca5/733c63d816b9fbc42f341cb4b0eb0021">《框架中的拖延者（4）：希望与不满》</a>，文章中描述了生活中的一类人“明日迷”，我是非常典型的这类人。</p>

<blockquote><p>&hellip;每一位明日迷的心里都积压了深深的不满。我们对自己失望。我们懊恼，愤怒，责怪自己又浪费了时间，碌碌无为，离明日的解脱还是遥遥无期。
每一个“今天”，我们都用这种想法折磨自己，再用行动上的放纵补偿自己。</p></blockquote>

<p>这篇文章中的每一个字都几乎命中了我的每一日生活，我对现在的自己不满意，我觉得我可以做的更好，做的更努力，现在的我达不到我内心中那个满意的标准。“现在，我不满意自己”。</p>

<p>令我没有想到的是这样的“上进的”想法，我一直引以为豪，以为是我不断进步的想法竟然是给我造成痛苦的罪魁祸首。</p>

<blockquote><p>  “现在，我不满意自己。”这个念头潜移默化地，为我们带来了多少痛苦？<br/>
  让我们不快乐，让我们觉得现在这些时间毫无价值。<br/>
  让我们耽于幻想，沉迷于将来有朝一日成功后的如释重负。<br/>
  让我们忍不住泄气，自怨自艾，精神萎靡，缺乏动力。<br/>
  “啊，还是先睡一觉，先吃点零食，先刷刷淘宝，养精蓄锐再开始奋斗吧……”<br/>
  甚至于，即使有兴趣的事，快乐的事，如果当成“正事”来做，也会慢慢感觉到痛苦，感觉到肩上的担子一天比一天沉。原理很简单：做正事，我们就希望“进步”。<br/>
  而希望进步，就等于说现在，我们还不满意自己。</p></blockquote>

<p>呵呵，还是个不断恶性循环的怪圈。</p>

<ol>
<li>在“你丫连自己满意的标准还没有达到，赶紧进步”的想法中过的不快乐 &mdash;></li>
<li>转念便有了“别看你们现在这么神气，哥以后一定会成为技术新秀，藐杀所有不努力的人。”的幻想 &mdash;></li>
<li>可是&hellip;“哎呀，我还有好多书买了都没有看，连最经典最基础的都没看完，更别提读经典的代码了，事情好多啊，累觉不爱啊” &mdash;></li>
<li>压力之后，潜意识就会&hellip; “刚起床，先刷个朋友圈缓解下吧”，“在看看今天有什么新闻”，“今天周末了，看个电影放松下，前一段时间太累了，需要多休息的”，一个上午就这样消磨掉了。&mdash;></li>
<li>于是想到了“你丫连自己满意的标准还没有达到，赶紧进步！”，再次回到了开始的不快乐。</li>
</ol>


<p>产生的结果是在不快乐郁闷中，用看电影、刷微博、看朋友圈过了一上午。而且</p>

<blockquote><p>甚至于，即使有兴趣的事，快乐的事，如果当成“正事”来做，也会慢慢感觉到痛苦，感觉到肩上的担子一天比一天沉。原理很简单：做正事，我们就希望“进步”。</p></blockquote>

<p>文章的最后正写出了我们的内心写照：</p>

<blockquote><p>一旦把目光放到未来的进步，对此刻的不满就难以避免。“勤奋小人”和“懒惰小人”会立刻开战。而我们已经知道了，一旦被这场希望与不满的战争席卷，我们的内心便会天昏地暗，永无宁日。做事的乐趣破坏殆尽，我们背着沉重的包袱，举步维艰。</p></blockquote>

<p>万万没想到，优秀青年具有的上进的想法是事实上自己不是很上进的心理根源。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SMP L1 Cache MESI Coherence Protocol Internal]]></title>
    <link href="http://liuyix.org/blog/2014/cache-internal-professional/"/>
    <updated>2014-01-07T15:02:00+08:00</updated>
    <id>http://liuyix.org/blog/2014/cache-internal-professional</id>
    <content type="html"><![CDATA[<h2>Gem5 Simulator Ruby Memory System</h2>

<p>Ruby Memory</p>

<h2>基于Directory的SMP L1 Cache MESI协议的内部实现</h2>

<p><strong>Directory</strong> :
<strong>SMP</strong> :
<strong>L1</strong> :</p>

<p><img src="http://liuyix.org/images/Diagrama_MESI.gif" alt="/images/Diagrama_MESI.gif" /></p>

<p>而实际上<strong>SMP架构</strong>中的MESI具有多个<em>瞬时状态</em> ,在研究Gem5模拟器中集成的<em>Ruby Memory System Simulator</em>的实现，根据协议实现代码，我得到了以下添加了瞬时状态后的有限状态机图示（ <strong>该图依然为简化后的图，其中省略了自旋状态转换</strong> ，这样看起来更清晰些）</p>

<p><img src="http://liuyix.org/images/MESI-orig.png" alt="MESI" /></p>

<p>当然这依然不是最终实现的结构，该图并没有考虑目前已经广泛应用在各种处理器上的 <em>Prefetcher</em>
本文之后会介绍这些 <em>State</em> 以及对应的 <em>Event</em> 。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我在BIT的这几年]]></title>
    <link href="http://liuyix.org/blog/2014/my-work-in-bit/"/>
    <updated>2014-01-03T19:39:00+08:00</updated>
    <id>http://liuyix.org/blog/2014/my-work-in-bit</id>
    <content type="html"><![CDATA[<h3>Changelog</h3>

<table>
<thead>
<tr>
<th></th>
<th>Version </th>
<th>  Time </th>
<th> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> 0.3 </td>
<td> 2014-3-1 </td>
<td> 毕业设计的总结</td>
</tr>
<tr>
<td></td>
<td> 0.21 </td>
<td> 2014-1-5 </td>
<td> 最后一学年的小结</td>
</tr>
<tr>
<td></td>
<td> 0.2 </td>
<td>  2014-1-4 </td>
<td> 研究生第二年</td>
</tr>
<tr>
<td></td>
<td> 0.1 </td>
<td>  2014-1-3 </td>
<td> 研究生第一年</td>
</tr>
</tbody>
</table>


<h2>我在BIT的这几年</h2>

<p>2年半的研究生即将结束，聊以此文做一下这几年的回顾吧。</p>

<p>2011年我考入了BIT，之后机缘之下来到了现在的实验室，正式成为了现在的导师的<em>第一任</em>弟子。实话说如果当时选择导师的时候能了解到更多的信息，可能就不会是这个选择了。幸运的是误打误撞的还碰到了不错的导师，与其说是导师，现在感觉倒更像是朋友和师兄，他给予了充分的自由和平等，我很感激。不过自己的散漫之气也因此耽误了不少事情，实感愧疚。这个之后会有提到。</p>

<!--more-->


<h2>第一学期</h2>

<h4>研究生课程</h4>

<p>研究生的第一年主要是上课了，没有在实验室待多少时间。第一个学期和大多数人一样尽力把培养方案中要求的课程上完，于是乎第一个学期几乎是宿舍、研究生楼、食堂、实验室这四个地方奔波，课满的时候一天5节课，从早上8点一直到晚上9点半。比较坑爹的是下午和晚上的课程之间的休息仅有40分钟——下午6点下课，晚上的课6点40就开始，40分钟几乎连晚饭都搞不定。（一是下课高峰人很多，二来距离不近）<br/>
研究生的课程难度上其实和本科生差别不大，不过还是让我感受到了一些压力：每一门专业课程都有至少一个，有时几个可以称得上是project的作业。虽然听说这种程度的project其实只能算是接近于本科生课程的要求，有的甚至还要宽松。但这恰恰是燕山大学计算机专业的不足之处，本科时我一直期待着可以有这种一试身手的有挑战的任务。</p>

<h4>环境</h4>

<p>住宿和饮食得益于北京重点高校的给力扶持令人满意，所住的宿舍环境干净、宽松，食堂因为学校的补助，饭菜相比外面实惠很多。（不过现在也因为CPI有所涨价了，从2011年￥8每顿饭到现在￥12左右）<br/>
实验室的环境同其他同学相比也好一些，人均面积可以说是在整个学院来说都是很大的。刚到的时候实验室的机器不怎么给力，是2007年的老机器了，忍受了一年之后终于在2012年的时候换成了目前非常给力的工作站。 <br/>
研究生阶段不同于大学本科，每个人的作息和时间安排因实验室而异，有的实验室要求很严格，规定了下课后必须到实验室;有的则相对灵活宽松，没有具体的要求，只要及时把任务搞定就可以。我很幸运的是后者，所以没有课的时候比较自由。不过后面会提到这样带来的一些副作用。</p>

<h4>实验室工作</h4>

<p>每个实验室因Boss不同，对研究生以及整个实验室的工作方向都有相当的差别。有的是企业项目导向的，以企业合作的方式让学生去完成一些企业项目（说白了就是当廉价劳动力&hellip;）;有的是以学术研究为导向的，具体来说就是拿到了某个基金，之后来做一些研究工作，说白了就是发论文;更多的则是兼而有之，既有一些与企业合作的项目，也有一些学术型的研究。我所在的实验室是第二种，单纯以学术研究为导向的，因而研究生的第一个学期我在实验室的主要任务就是读论文，内容集中在<em>Simulation</em>,<em>Performance Evaluation</em>这一块。由于自己之前没有什么基础，因而读的时候收获甚微。<br/>
除此之外，我还接触了<em>Gem5模拟器</em>。惭愧的是在实验室待了2年有余，Gem5模拟器钻研的不是很精，只是对整个架构，完整的工作原理有了一个初步的了解，实现了一些功能的扩展。这个稍后会细说。</p>

<p>整个一个学期，最令我印象深刻的事是关于人工智能课程，其实这个课程当初没有选，几个舍友选了之后向我推荐，当时想着不如多学些让自己有个更宽的知识面，没成想最后的结束比较狼狈，课程项目做的马马虎虎，考试也只是擦边60分水过，自己现在对AI依旧比较陌生，不得不说是一个遗憾。<strong>现在想来这是自己的一个弱点——对自己没感觉的东西，总是不能做的令人满意，如果现在设想十年后自己没有成功的原因的话，这应该算上一条。</strong></p>

<h2>第二学期</h2>

<p>2012年4月份这一个学期伊始，导师出国做为期一年的访问学者。</p>

<h4>几个月的实习</h4>

<p>临走前将我安排到了中国软件评测中心CSTC做实习（在2011年年末的时候就已经有了一些接触，当时不过是在学校来做，这个时候就正式去公司去做实习了）。实习工作比较水，一如给的不足一百的实习薪水。做的内容是Android平台的安全软件研究。具体来说就是“研究”LBE隐私卫士的实现原理。这也是我第一次接触LBE。 <br/>
之后大概两个月都在做这一块的逆向研究，越发的感觉到LBE“主动防御”技术真的好牛逼。恰巧的是同年四五月份，360安全卫士、腾讯管家也才陆陆续续的推出了类似功能。我在CSTC的情况很微妙，只是我一个人独立在做这一块，最终是大概到了4月末还是没有作出成果，原因是多方面的，对Android整个系统的了解我只是个大菜鸟，只是自学了一点皮毛，同时我也不是Hacker级别的玩家。虽然对我来说我也研究出了一些门道，但很遗憾的没有做出成品。<br/>
这一段时间我实现了利用ptrace实现<em>动态注入共享库</em>，还有运行时的<em>function redirection</em>，对Android Binder协议也接触了一点。我已经尽力了，没什么遗憾。 <br/>
之后为了交差，CSTC的指导人又让我做一个简单的短信和来电骚扰拦截应用，这个相对于前者难度很小，于是大概一个月的时间就做出来一个基于黑白名单的短信和电话过滤应用。实现使用的核心原理没什么难度，网上都有，就是Java反射调用一个没有公开的接口从而实现来电拦截。这个应用代码主要是sqlite的增删改查以及界面的实现。</p>

<h4>实验室工作</h4>

<p>导师和我在这个学期还是经常有邮件的联系，实验室的工作也一直还有，主要工作就是完成一个很tricky的trace收集算法，在gem5上实现，然后发会议paper，因为CSTC的实习，实验室的这块工作就没怎么顾得上，到了七八月份眼看着到了论文deadline，这时候CSTC那一块要求做的来电和短信的过滤应用也告一段落，因此就决定把实习辞掉，专心来做paper，这个时候是7月末。<br/>
于是从7月末开始，也就是研究生第一年的暑假，整个一个假期都在实验室苦逼地做实验，一直到9月初deadline截至时，尤其印象深刻的是deadline是北京时间的上午，距离几个小时前依旧在跑实验数据，最终算是勉强把数据跑完加上了，论文几乎没有怎么校对过。现在回顾看来，这其中至少一半的原因在于我的拖延，论文实际上在大约五六月份时就已经有了初稿。<strong>自己在一段时间不能兼顾多个任务使得最终放弃了实习，专注于实验室的工作。坦诚地来说，这也是自己需要做出改变的一点。</strong><br/>
经过了2个月的奋战，论文首先经历了HPCA顶级会议的考验。没有做出实际成品之前，一直觉得这个东西有些难度，需要花上很大的工作量才能搞定，可完成之后反过来回顾时会觉得实际做出来的东西真正弄透以后会觉得实际的东西没有那么高大上，只不过是&hellip;.（此处省去1万字）。最终在HPCA的peer review阶段，我们根据reviewer的反馈还是将paper撤了下来，得到了许多我们之前没有考虑过的东西，也发现了一些reviewer的关注点，总体上讲我们的主要目的是达到了——让顶级会议的大牛们看一下你的成果，发表下意见。如果大家都很感兴趣，那么自然很有希望被会议录用，反之也可以得到一些中肯的反驳意见。<br/>
最终我们这篇paper发到了一个C类会议上，结果虽然不是最好的，但也不至于很失望。</p>

<h2>第三学期</h2>

<p>这个学期是“无政府状态”的巅峰时期，几乎完全荒废了学业。这个学期我完全的变成了无业游民般的自由——2012年9月初，论文的事情进入尾声，此时这个学期要进行研究生的毕业开题，因此就没有找实习。这样子整个一个学期只有开题这一个任务。这里还有个背景：我所在的实验室是以学术为唯一目的的实验室，大boss，我的导师的导师，近几年几乎不招收硕士了，“<em>两年半的时间，其中还有一年来上课，半年毕业，做研究的时间太少了</em>”，因而导致<em>曾经人满为患的一个屋子现在几乎是空荡荡的，这个学期到了人最少的一个学期——常驻的学生只有我一个人&hellip;</em><br/>
虽然看起来屋子很宽敞，自己一个人极为自由，可那种只能和空气说话的气氛，人待久了会疯掉的。也就是在这个时候我发现自己一天几乎说不了几句话。（研一开始的时候就没有选择什么课余活动，宿舍的哥们都和我一样，每天宅在各自的实验室，只有晚上的时候会在宿舍）当时的我就很恐慌，怕自己因此变得自闭，与人隔绝了一般。<br/>
于是我决定做出改变，不能为了科学让自己变得脱离社会，要找机会融入集体多和人交流，找人一起玩，而因为硕士生毕业开题的事情自己觉得又不应该离开学校，恰逢第一学年的新学期开始，研究生会开始招新。于是我作为研二的学长参加了研究生会。虽然这个学期学业上几乎完全荒废了，可此时回顾来看，我依旧不后悔当初的决定，如果给我重新选择的机会，我还是会这样选择。<br/>
此后的研究生会的活动中，自从研究生开始就没怎么参加集体活动的我玩的很嗨很投入，自然而然地结交了很多好朋友，认识了许多有意思的人，同时也有机会认识了相当多的其他学院的朋友，我很满足。这里给后来人提一个醒，无论怎样都要找到一个集体，融入进去，无论是学术的还是娱乐的，人不能脱离了群体而存在。我之所以选择加入研究生会，是因为学术上并没有给我提供充分的群体归属感，我只能从其他地方寻找。<br/>
这里不得不提到知乎上的一个精彩回答:<strong>二十多岁该做些什么，将来才不会后悔？</strong><br/>
作者是<a href="http://www.zhihu.com/people/yolfilm">yolfilm</a>, 链接地址：<a href="http://zhi.hu/CddD">http://zhi.hu/CddD</a></p>

<blockquote><p>「一個人」的狀態，總是最糟的。</p>

<p>我覺得說一些我的個人經驗，於你無用，因為環境機遇不同。（多一半，還有自我吹噓的潛意識存在）。但，我可以給你一個，我母親給過我的，非常好的建議。</p>

<p>我母親曾經告誡過我，一個人的狀態，總是最糟的。</p>

<p>你一人吃穿用，一人度日過日，非常容易解決，也非常容易跌入谷底，高興時無人分享，但，失志時，那種惡劣的狀態，卻只能一再重復浸淫。所以，要讓自己振作，第一件事，絕不要長期保持「一個人」的狀態。</p>

<p>再不濟，你養條狗，這狗，都要逼你準時餵牠，準時拉牠出去運動，牠病了，你得給牠奔走求醫。你悲傷時，牠會給你溫暖，分攤你的愁苦。你成功時，牠會哈哈斥斥地笑張大嘴，靜坐在一邊共享你的快樂。</p>

<p>牠是你的責任，也是你的負擔。按我母親說的，就是養條狗，你也不會是「一個人」。</p>

<p>你可以不成家，你可以是失怙孤兒，你可以是找不見伴侶的同性戀，你可以悲慘到無以復加的地步，但，就是到那樣境地，你也要強迫自己，不要是一個人。</p>

<p>孤獨殺手里昂，也要養盆花。</p>

<p>孤獨殺手亞蘭德倫，也要養隻金絲雀。</p>

<p>我個人的經驗是，只要你不是一個人，你即使不成功，但，也絕不會失敗。</p>

<p>我一直記住老娘的教誨，一直在身上背著負擔。搞合唱團時，背著團員，搞劇團時，背著團員，開公司時，背著員工，寫劇本時，背著徒弟，拍戲時，背著債務，背著投資人。成家時，背著老婆孩子。</p>

<p>因為總不是一個人，所以你荒唐不起來，也沒辦法混噩度日。</p>

<p>如此，你謀生求職，你艱辛度日，你的理想事業，就是失敗了，但因為有負擔，不是一個人，只要保全了身上背著這些負擔，另一個層面來說，你也總是成功的。</p>

<p>所以，只要你不是一個人，不是只為自己活，某種層面來說，你永遠不會失敗。</p>

<p>你就是被車撞死了，死在半夜的馬路上，因為你不是一個人，就會至少有一個人在惦記著你。</p>

<p>你的生命，就不會沒有意義。</p></blockquote>

<!--看到了别声张，谢谢
这一学期我认识了我这辈子目前为止最有feel的她。先说下结局吧，我俩没在一起，我搞砸了。直到现在每次回忆起这段往事时都会默默的在心里骂自己是个SB，十足的，我知道即使当初没有那么二，也未必会有更好的结果，但我想至少我不会像现在这样后悔。
我第一次体会到了那种想一个人可以想到废寝忘食，整天魂不守舍，整整2个月的时间，除了研究生会的活动以外，我的生活里面只有她。然而因为自己种种的犯二到荒唐的程度（我常常以爱到失去理性安慰自己）导致我们的额关系经历了大起最终归于尘埃，到现在没有联系。在2013年上半年的时候，我依旧想着可以再重新挽回，虽然也感觉到没有了当初的那么强烈的感觉，可这时已经发现她已有了另一半，自己躁动的心也算是平静了，祝福她幸福，也再次(每次想到这段事我都会做的)对我当时的犯二行为给她造成的伤害表示歉意-->


<p>这个学期玩的太用力，导致整个开题报告做的马马虎虎，给之后的毕业论文埋下了很大的隐患，这是后话。这个学期可以用几个关键词来总结：研究生会、玩、开题报告。</p>

<h2>第四学期</h2>

<p>这学期出国访学一年的导师回来了！这也是我的研究生二年级的最后一个学期。<br/>
这个学期周围很多人开始了毕业前的实习，看到许多人开始实习，我也有些心急了，毕竟我没打算继续读博，因而找到一份理想的工作是我的主要目标。也许每一个初当导师的人都心慈手软吧，或者我的导师本来就是一个很好说话的人，总之这个学期我成功的出去实习了。<br/>
实习的公司很有意思，就是LBE！看过前面的应该都知道我在第二学期实习时花了很久来逆向研究LBE的隐私卫士，对它的技术上有很好的印象。现在来看，LBE团队依旧是具有很强的技术实力。能在LBE实习有很大的偶然——正是在自己在论坛扒实习帖子的时候偶然发现了他们在byr论坛发布的招实习生的帖子，之后才知道这个帖子已经贴了很久，我加入那时候其实他们已经不打算继续招人了的。<br/>
去LBE面试，就是面总本人来面的我（后来才知道的==），结果顺利地通过了，当时非常欣喜，竟然只有一面，因为之前一直以为能做出这么高技术含量的人，一定是一个相当规模的牛逼团队，要进入得具有相当的实力才行。<br/>
就这样，我开始了接近半年时间的实习生活。<br/>
加入LBE后才发现，这是一个不到20人创业型团队，实际开发的不到十人。而且做出隐私卫士第一版主要作者竟然是面总一个人！！膜拜&hellip;加入到LBE，原本就打算以后就从事Android平台的开发了，做个Android Developer。可命运再次向我开了个玩笑。<br/>
进去后，面总想要我来做一键root的三星专版，因为三星手机市占率很高同时三星刷机和升级手机使用的是自己开发的特殊协议Odin，同时该协议已经被国外某位大神逆向出来，制成了Heimdall工具，当时国内还没有哪一家公司使用这种方式root手机，由于当时LBE只有我和面总对Linux这一块熟悉，而他还要继续负责LBE核心应用的开发，因而自然由我来承担这块工作。这也就是我在LBE——一个以Android平台安全软件出名的公司几个月的工作成果——<em>LBE一键root三星专版</em>。而这只和Android平台沾边，<del>一点都不</del>几乎不涉及Java的开发，而主要工作是Linux系统开发、QT完成的Windows桌面应用的维护、还有一系列脚本以及一个后台抓取数据的python程序，基本上可以将这些工作归为后台开发，当然整个过程只是覆盖面很<strong>广</strong>：从<em>Linux平台的脚本</em>、<em>python程序</em>到<em>Windows平台的驱动</em>、<em>QT应用</em>再到Android手机上Framework层下的<em>Android su</em>以及Android平台的<em>Superuser</em>，单独来看哪一个部分涉及的技术要求都不高，但是得懂。<br/>
在LBE实习的这几个月，认识了许多小伙伴，大家也给予了我很多肯定，我很感激大家。唯一让我郁闷的地方是公司的地点离学校太远了，学校在西三环，而公司在东三环，后来又搬到了东四环，每天要坐地铁加步行总共1个多小时才能到，每天有2个半小时时间是在地铁上的，很辛苦。</p>

<!--
在今年的下半年的时候，遇到了很有意思的女孩子。成熟，漂亮，性格偏女汉子，有很强的事业心。
-->


<h2>最后一学期</h2>

<p>9月份研究生最后一个学年（两年半学制）。一到九月份就结束了自己的实习，在暑期的时候就得知和导师合作的那篇论文被会议录用了，会议的地点就在贵阳，因此可以两个人一起去那里参加，很开心。 <br/>
9月初2014年秋季校园招聘就逐渐拉开了大幕，第一波互联网公司的校招接踵而至，首先来的是阿里巴巴——我最向往的互联网公司。自己还曾下豪言，如果拿到阿里的offer真的就别无他求了。与此同时，至于毕业设计嘛，呵呵&hellip;不巧的是阿里校招的笔试时间和那个国际会议的的时间几乎挨着，可为了阿里的校招，果断放弃了去贵州贵阳“免费旅游”的机会。<br/>
就这样9月下旬参加了阿里校招，一周后得到面试通知，面试那天从上午10点一直聊到了中午12点多，感觉还蛮不错的。这时正巧临近十一长假，最终有没有通过面试只有长假之后才会通知。就这样几乎杳无音信的一直到10月18日，终于得到了阿里巴巴发来的短信，拿到了阿里的offer!虽然这几周过得异常虐心和纠结，现在想来也算值了。在等待的这一段时间由于不敢确定阿里是否能给offer，所以还是其他的笔试面试没有掉以轻心，百度、小米和网易的都参加了笔试和面试，因为自己选择的都是Linux内核相关以及底层的东西，因为自己没有实际经验，小米的算是面试之后默拒了，百度的一面就被不明原因莫名其妙的刷掉了，至今还很纳闷，网易等其他的公司都是在收到阿里offer之后才给的面试通知，因此就都没有去。<br/>
之后的事情目前还没有结束，待本学期结束了再做总结吧。</p>

<!--<center>To be continued&#8230;</center>&#8211;>


<p>时光匆匆，现在已到了2014年3月了，在校的日子已经只有几周。恰逢前几日北京严重雾霾天气，真心觉得离开北京可以说是一个正确的选择（也许心理暗示的成分更多些吧）。杭州，我就要来了！<br/>
继续开始总结。
10月到12月，本应该专心做毕业论文的时候基本上却没怎么忙毕业设计，这一段时间一部分精力集中在做一个关于手机root的兼职开发维护工作，中间还夹杂了一个甲骨文的几次面试。最后甲骨文止于最后一面，蛮可惜的。</p>

<!--当然不得不提的是我遇到了一个漂亮，更重要的是性格我也很欣赏的女孩子，遗憾的是以好朋友交往的短短2个月就发生了数次分分合合，看来有些事真的强求不来，她在一些事上总是很强势，她的心思更在自己的实习工作和学习生活上，我的地位总是卑微的，在11月中下旬的时候终于在一次争吵中结束。
-->


<p>可以说确定offer后的这一段时间里是研究生阶段里最堕落的一段时间了：上午10点左右起床，到实验室也快中午，上上微博看看新闻就去吃午饭，然后下午做一些事情，晚上便又开始玩了起来。毕业设计的进度极为缓慢，过了年末才慢慢的抓紧时间了。这应该算是一个典型拖延症患者的自白了吧。<br/>
幸好这一段时间一直使用印象笔记做每天的时间流水账，回顾可以看到每天差不多专心工作的时间大概在3小时上下，有时还不到这个数。完全可以说这个学期专注工作的能力已经残了&hellip;<br/>
就这样，到了1月中下旬为了逃避论文的压力，我早早的启程回家了。事实证明，这是个极错误的决定。1月19日到家后，我才发现家里的环境远远不如学校实验室，在家里甚至连个像样的桌子也没有。而这时候正好是春节前夕，因此更加的不想做毕设了，可心里又很清楚年后就要毕业答辩了，这样纠结的情绪一直弥漫于整个在家的假期之中，以至于春节的那几天躺在床上回想时“想到实验还没做出来，不到几周就要答辩了，这是要悲剧的节奏啊！！！”，于是我失眠了。年三十的时候和导师做了电话沟通，我像个犯了错误的孩子一样忏悔了自己的无作为，于是我和导师研究了毕业论文的解决方案。我们选择了改变策略，做不到预想的实验就不做了，把已有的实验结果加上去也算完整。沟通之后，忐忑的心总算平静了一些。<br/>
本来已经订了农历十六返程车票，因为爷爷家出了一些事，临时改变了计划，当时一想反正也要退票，不如直接提前回校了。后来证明这是最后时刻做出的正确选择。<br/>
就这样我农历十二就到校了。可是对我来说，这依旧没有到<em>最后时刻</em>，每天还是会开小差，到了2月12日，论文的初稿还没有弄出来。这时候开始了爆发突击模式，2月13日到2月17日这几天每天都搞到很晚，还通宵了两次，总算在2月17日交了初稿，并且于2月18日通宵完成修订稿，2月20日发出外审。在最后时刻及时完成了毕业论文。2月27日顺利过了毕业答辩。<br/>
毕业论文的预想和最终稿内容有许多不同，但是依然还是有三万多字的内容，很充实。也就是说没有完成之前预想的实验也达到了毕业的水平，而且内容充实。我的论文题目开的不怎么好，题目太大了，涵盖了许多方面的内容。起初论文的设想是把这几个方面完整的做出来，由于完成实验需要高出自己能力和精力的付出以及自己对毕业论文的期望（及格就行）远低于导师对论文水准的期望，所以我一直在拖延着。直到最后时刻，我只把已经做出的东西写进去才发现工作量已经足够毕业了——如果真的按照起初论文的设想完成的话，我不敢说那是一个博士生的工作量，但两三个硕士生毕业是没有问题的。<br/>
不管怎样，事情已经过去，说什么都要算作是马后炮了。<br/>
总结来说，这个学期让我认识到一个人习性的改变是多么的困难——现在的毕业答辩可以说和本科时准备毕业论文时的狼狈很相似。当时信誓旦旦的要改变自己，要改掉逃避压力的习性，几年过去了，起色不大。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Kernel概览]]></title>
    <link href="http://liuyix.org/blog/2013/linux-kernel-overview/"/>
    <updated>2013-10-22T20:19:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/linux-kernel-overview</id>
    <content type="html"><![CDATA[<blockquote><p>总结下读过的有关Kernel的书籍，主要是<a href="http://book.douban.com/subject/2287506/">&lt;Understanding the Linux Kernel></a>>、<a href="http://book.douban.com/subject/6097773/">&lt;Linux Kernel Development></a>、<a href="http://book.douban.com/subject/1723151/">&lt;Linux Device Drivers></a></p></blockquote>

<h3>终极目标</h3>

<p>完整的回答以下问题：</p>

<ul>
<li>从开机上电到进入命令提示行，Linux完整的启动过程</li>
<li>Linux终端下敲入<code>ls</code>的完整过程。(从接收键盘设备中断到显示到结果显示到屏幕)</li>
<li>Linux终端下输入<code>cat foo.txt</code>的完整过程。(同上，其中包含了读写磁盘的操作)</li>
<li><em>to be continued&hellip;</em></li>
</ul>


<!--more-->


<h3>内核态/用户态</h3>

<p>Intel x86有4种不同的状态，Unix内核只使用内核态和用户态。</p>

<p>内核线程：</p>

<ul>
<li>内核态在内核地址空间执行</li>
<li>不与用户直接交互，无须终端设备</li>
<li>通常在系统启动时创建，一直活跃直到系统关闭</li>
</ul>


<p>陷入内核态的几种方式：</p>

<ul>
<li>用户态进程调用<code>syscall</code>系统调用</li>
<li>遇到<code>Exception</code>(无效指令、越界访问、除数为0等)：内核会代表进程处理异常</li>
<li>外设向CPU发出<code>interrupt</code></li>
<li>执行内核线程</li>
</ul>


<h3>进程实现</h3>

<p>当进程暂停时，将表征进程状态的寄存器保存到<strong>进程描述符</strong>中，其中包括：程序计数器、栈指针寄存器、通用寄存器、CPU状态信息的控制寄存器（处理器状态字）以及内存管理寄存器。当需要恢复进程执行时，再将保存的字段恢复即可。</p>

<h3>可重入内核</h3>

<p>可重入内核可以包含非可重入代码，需要利用锁机制。</p>

<p><em>Kernel Control Path</em> 内核控制路径表示内核态中内核进行的任务类型：处理syscall、异常、中断处理程序。 <br/>
内核控制路径可以交错执行。</p>

<h3>进程地址空间</h3>

<p>每个进程有“私有”的地址空间，用户态下：私有栈、数据区、代码区；内核态：内核的数据区和代码区、<strong>进程内核栈</strong></p>

<p>在进程的角度上每个进程都是独立的地址空间，但是内核管理上未必是独立的，有可能是共享。</p>

<h3>同步和临界区</h3>

<p>利用同步机制防止多个内核控制路径破坏全局的内核数据结构。</p>

<ul>
<li>非抢占式内核</li>
<li>禁止中断</li>
<li>信号量</li>
<li>自旋锁</li>
<li>避免死锁：Linux通过按规定的顺序请求信号量避免死锁。</li>
</ul>


<h3>信号和IPC</h3>

<p><em>信号机制</em>将系统事件报告给进程的机制。系统事件分为两种：异步通告(SIGINT),同步错误或异常。</p>

<p>进程间通信的机制：信号量、信息队列、共享内存；标准有两种：System V IPC和POSIX</p>

<h3>进程管理</h3>

<ul>
<li><code>fork</code></li>
<li><code>exec</code></li>
<li><code>_exit</code></li>
<li><code>wait4</code></li>
<li>zombie进程</li>
<li><em>process group</em></li>
<li><em>login session</em></li>
</ul>


<h3>内存管理</h3>

<h4>虚拟内存</h4>

<blockquote><p>虚拟内存(virtual memory) 作为一种逻辑层，处于应用程序的内存请求与MMU(Memory Management Unit，硬件内存管理单元)之间。</p></blockquote>

<h4>RAM的使用</h4>

<p>RAM中有一部分存放内核映像部分(内核代码和内核数据结构)。其余部分有三种不同的作用：</p>

<ul>
<li>内核使用</li>
<li>进程使用</li>
<li>磁盘和其他设备的高速缓存</li>
</ul>


<h4>KMA: Kernel Memory Allocator</h4>

<p>KMA内核内存分配器子系统用来处理所有的内存请求，其中包括内核内其他子系统、用户进程通过syscall请求增加内存使用的请求。</p>

<p>KMA的特点：</p>

<ul>
<li>快</li>
<li>省,浪费最少</li>
<li>尽量无碎片</li>
<li>可以同其他内存管理子系统合作</li>
</ul>


<h4>进程虚拟地址空间处理</h4>

<p><strong>尽可能的“懒”的做法</strong> ：必要时才做耗时的工作(COW和demand paging策略)，如果必须要做耗时的工作就多做些(预读取机制)</p>

<ul>
<li>demand paging内存分配策略：进程可在页没有载入主存下执行，当访问到不存在的页时，发生缺页中断，之后中断处理程序将页载入到内存。</li>
<li>COW写时复制策略</li>
</ul>


<h4>高速缓存</h4>

<ul>
<li>推迟写回磁盘的操作</li>
<li><code>sync</code> 调用</li>
</ul>


<h3>设备驱动程序</h3>

<p><img src="http://liuyix.org/images/device-driver-interface.bmp" alt="/images/device-driver-interface.bmp" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[百度校招-系统研发工程师-笔试题]]></title>
    <link href="http://liuyix.org/blog/2013/baidu-exam-review/"/>
    <updated>2013-10-15T01:36:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/baidu-exam-review</id>
    <content type="html"><![CDATA[<p>几道编程算法题：</p>

<ul>
<li>实现类似wget一样的进度条</li>
<li>100亿个单词，每个单词长度小于30，输出去重后的所有单词。</li>
</ul>


<!--more-->


<h3>实现类似wget进度条</h3>

<blockquote><p>当时没有想出来，回来才搜索之后才知道考察的是对转义符的理解。</p></blockquote>

<p>关于换行，话题看起来看似简单，但实际内容不少。</p>

<p><strong>主流操作系统文本换行的差异</strong></p>

<table>
<thead>
<tr>
<th></th>
<th> OS </th>
<th> 按下回车后插入的控制字符 </th>
<th> 含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Windows </td>
<td> <code>\r\n</code> </td>
<td> 0x0D 0x0A <em>CR LF</em> </td>
</tr>
<tr>
<td></td>
<td> Linux </td>
<td> <code>\n</code> </td>
<td> 0x0D <em>LF</em> </td>
</tr>
<tr>
<td></td>
<td> Mac OSX </td>
<td> <code>\r</code> </td>
<td> 0x0D <em>CR</em> </td>
</tr>
</tbody>
</table>


<p>因此你经常会遇到Windows下用notepad看某些Linux编辑的文本，都没有换行。</p>

<p>基本的内容就这么多，如何实现wget的进度条即是在Linux下用<code>\r</code>而不用<code>\n</code>，这样会不断的将新内容输出到同一行，从而达到“刷新”的效果。</p>

<figure class='code'><figcaption><span>demo.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//类似wget的进度条的实现，实际就是转移符\r的使用，\r的作用是返回至行首而不换行</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">bar</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">bar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;#&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;progress:[%s]%d%%</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bar</span><span class="o">+</span><span class="n">len</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>        <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span><span class="c1">//一定要fflush，否则不会会因为缓冲无法定时输出。</span>
</span><span class='line'>        <span class="n">usleep</span><span class="p">(</span><span class="mi">100000</span><span class="p">);</span><span class="c1">// 睡眠100ms</span>
</span><span class='line'>        <span class="c1">//sleep(1);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>给定100亿个单词，每个单词长度小于30，输出去重后的所有单词序列。</h3>

<p>面试准备不充分，这是trie树的最典型的题目了。
更多的信息可以看July的文章。
<a href="http://blog.csdn.net/v_july_v/article/details/6897097">http://blog.csdn.net/v_july_v/article/details/6897097</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小米面试内核驱动工程师总结]]></title>
    <link href="http://liuyix.org/blog/2013/xiaomi-onsite/"/>
    <updated>2013-10-11T19:54:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/xiaomi-onsite</id>
    <content type="html"><![CDATA[<blockquote><p>此为吐槽贴，略涉及技术。</p></blockquote>

<p>之前网申投的是<em>内核驱动工程师</em>，这个职位是凭着自己对Linux Internal还保持非常浓厚的兴趣，虽然实践不多，还有就是一看到这个title就有种高端大气上档次的赶脚。之后前几天打来电话去面试，这才知道这次是小米的bsp团队招人。</p>

<p>怀着忐忑和兴奋的心情去小米参加bsp团队的面试。结果比较让人失望，一方面是自己还有很多不够深入的地方，一方面是bsp团队明显准备不足。</p>

<!--more-->


<h4>小米总部真够偏僻的&hellip;</h4>

<p>地铁上地站下来之后，<strong>非上下班时间，没有公交车可以直达</strong>，只能打车。</p>

<h4>面试原来可以这样</h4>

<p>五彩城的环境还是蛮不错的，我直接到15层会议室，之后被告知面试官正忙，等一会儿。好吧，我就等等吧，<strong>这一等就20分钟</strong>。<br/>
之后进来一位年纪轻轻的面试官哥哥。 <br/>
面试原来可以被当做临时指派的任务。我有很大的把握说面试官是在看到我之前的几分钟才看我的简历。<br/>
<em>#自我检讨#</em> 对自己的研究工作没有弄的足够深入，被面试官稍一刁难就被问倒。一直纠缠于cache和spm之间的性能和功耗上的比较问题，最后只好作罢。于是乎慢慢的气氛变成了质疑我们实验室的研究水平，当时有点气愤，不过在有效的说明了自己发表的关于单程序trace获取的论文时还算将气氛扳回来一些。<br/>
聊了半个多小时面试官哥哥就又被叫出去开会，囧rz&hellip;大概10分钟后，另外一位面试官哥哥进来，然后由于不知道之前的面试官哥哥都<del>问过我什么问题</del>聊过什么话题，于是又有好多重复的问题出现&hellip;囧rz</p>

<p>不过第二个面试官哥哥谈吐和问的问题上明显感觉很专业，对内核和存储乃至trace这块都有很深的见解，和他聊我的毕业设计时，我还取得了非常很有价值的反馈。很赞！</p>

<p>由于自己在内核驱动这块知道的不多，第二位面试官哥哥几次试图问一些汇编语言、内核驱动的问题时，我都很无奈的回答懂得不多，<em>面试一大忌讳就是回答不了解，这样让双方都会有些挫败感，面试官可能会降低印象分</em>，但是对这几块确实连突击的时间都没有，只好这么回答了。<em>检讨：对简历上技术点挖掘的不够深，写了自己常玩github，就被问到了git的用法；写了自己爱玩新技术，就被问到了自己感兴趣的新技术有哪些，这些很可惜都能没有准备。</em> <br/>
再聊了半个小时左右之后，就结束了。感觉应该是挂了。</p>

<p>之前打听过bsp团队之前没有招过应届毕业生，所以我吐槽的这些还是可以理解的。但是没有为面试拿出足够的准备还是蛮失望的。</p>

<p>最后询问时就聊了一些比较轻松的话题，让面试官哥哥介绍了一下目前bsp团队。现在获得的情报是：目前团队规模五六十人，负责了miui之下的大部分工作，包括驱动开发、底层系统优化等等，甚至包括Java层的问题调试，工作范围面很宽。 <br/>
依旧是个创业团队的节奏——连续多年每周6x12hr的工作量。无愧于外界所说的高执行力的团队。</p>

<p>校园招聘是一个双向选择的过程，既是企业挑选人才，也是真正的人才选择企业。在面试的方方面面都会体现出一个企业，一个团队对人才的重视程度，也是赢得口碑的机会。在认真程度上来说，这次面试的体验不如阿里巴巴。<br/>
总体上这两位面试官哥哥给我的感受是非常实干的类型，对小米的这个创业团队强度的团队技术实力上的印象还是很好。祝愿你们能找到适合的人才。</p>

<h4>自己这次面试的经验</h4>

<ul>
<li>简历上的内容还需要加强。

<ul>
<li>在简历的准备上功夫还不够，还是有被问倒的可能，需要加强和巩固。</li>
<li>简历涉及的技术点还是挖掘的不够细致。</li>
</ul>
</li>
<li>面试中还没有hold住场面的能力</li>
<li>面试中需要事先准备一个可以让面试官眼前一亮的闪光点，可以是技术上的，也可以是表达或者其他方面</li>
</ul>


<h3>Update:问到的题目</h3>

<p>昨天没写是因为自己当时没记起来多少&hellip;今天复习时才慢慢都想起来了，在此分享下。</p>

<ul>
<li>关于抢占的理解（何时抢占，怎样实现的抢占）</li>
<li>kmalloc与vmalloc的区别</li>
<li>kmalloc内核是如何实现存储管理的，比如申请了14B的空间</li>
<li>A,B两个进程，运行顺序是A&mdash;B&mdash;A,有多少种可能导致的，比如阻塞，抢占等。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mac上安装octopress]]></title>
    <link href="http://liuyix.org/blog/2013/mac-install-octopress/"/>
    <updated>2013-10-06T12:31:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/mac-install-octopress</id>
    <content type="html"><![CDATA[<blockquote><p>Update: 经人提醒，可以改用国内淘宝的rubygems源下载，具体操作：<a href="http://ruby.taobao.org/">http://ruby.taobao.org/</a> <br/>
<del>可算折腾出来了。最大的障碍是渣一样的网络，rubygems想法不错，可到了国内情况就会变得很糟糕。最后不得已用goagent总算顺利的完成了。</del></p></blockquote>

<ol>
<li>安装homebrew</li>
<li>安装rbenv以及ruby-build</li>
<li><code>rbenv install 1.9.3-p448</code></li>
<li><code>official install octopress</code></li>
<li>在octopress目录下面新建配置文件<code>echo '1.9.3-p448' &gt; $your-octopress-path/.ruby-version</code></li>
</ol>


<!--more-->


<h3>原有的octopress迁移到mac</h3>

<p>如果之前在其他地方已经使用了octopress，那么在mac上的稍有不同。具体为：</p>

<ul>
<li>clone <em>yourname.github.com</em>的source分支：<code>git clone git clone -b source git@github.com:yourname/yourname.github.com.git octopress</code></li>
<li>在clone<em>yourname.github.com</em>的master分支到<code>$your_octopress/_deploy</code>目录: <code>git clone git clone git@github.com:yourname/yourname.github.com.git _deploy</code></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># 如果之前就已经在使用octopress，迁移到mac的话，不要clone octopress源，而是要clone你自己的repo源的source分支</span>
</span><span class='line'>git clone -b <span class="nb">source </span>git@github.com:yourname/yourname.github.com.git octopress
</span><span class='line'>git clone git@github.com:yourname/yourname.github.com.git octopress/_deploy
</span><span class='line'>
</span><span class='line'><span class="c">###### 安装octopress ######</span>
</span><span class='line'><span class="c"># install homebrew</span>
</span><span class='line'>ruby -e <span class="s2">&quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 使用brew安装rbenv</span>
</span><span class='line'>brew install rbenv ruby-build
</span><span class='line'>
</span><span class='line'><span class="c"># 修改.bash_profile</span>
</span><span class='line'><span class="nb">echo</span> <span class="s1">&#39;export RBENV_ROOT=/usr/local/var/rbenv&#39;</span> &gt;&gt; ~/.bash_profile
</span><span class='line'><span class="nb">echo</span> <span class="s1">&#39;if which rbenv &gt; /dev/null; then eval &quot;$(rbenv init -)&quot;; fi&#39;</span> &gt;&gt; ~/.bash_profile
</span><span class='line'>
</span><span class='line'><span class="c"># 关闭terminal，再重新开启</span>
</span><span class='line'>rbenv install ruby-1.9.3-p448
</span><span class='line'>rbenv versions <span class="c">#应该显示的是system和1.9.3-p448</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 进入到你的octopress</span>
</span><span class='line'><span class="nb">cd</span> <span class="nv">$your</span>-octopress
</span><span class='line'><span class="nb">echo</span> <span class="s1">&#39;1.9.3-p448&#39;</span> &gt; .ruby-version
</span><span class='line'>
</span><span class='line'><span class="c"># 再次关闭终端，重新打开进入到你的ocotpress目录</span>
</span><span class='line'>ruby --version <span class="c"># 应该显示的是ruby 1.9.3p448</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 推荐可选操作：更改rubygems源至国内淘宝源，下载更稳定,参考链接：ruby.taobao.org</span>
</span><span class='line'>gem sources -l <span class="c"># 看一下默认的rubygems源的url</span>
</span><span class='line'>gem sources --remove https://rubygems.org/ <span class="c">#此处的url以上一条命令为准，有时可能是http而不是https</span>
</span><span class='line'>gem sources -a http://ruby.taobao.org
</span><span class='line'>gem sources -l <span class="c"># 此处应该只显示的是淘宝的rubygems源</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 现在就可以参考官方的安装说明安装了</span>
</span><span class='line'>gem install bundler
</span><span class='line'>rbenv rehash    <span class="c"># If you use rbenv, rehash to be able to run the bundle command</span>
</span><span class='line'>bundle install
</span><span class='line'>
</span><span class='line'><span class="c"># 如果是第一次安装octopress，还需要安装默认的theme</span>
</span><span class='line'>rake install
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#吐槽# Octopress：想说爱你不容易...]]></title>
    <link href="http://liuyix.org/blog/2013/octopress-fails/"/>
    <updated>2013-09-27T23:09:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/octopress-fails</id>
    <content type="html"><![CDATA[<p>几个月时间，博客转到了github pages上的Octopress，结果是输出的文章比之前更少。（之前的几十篇文章也不见了踪影&hellip;）</p>

<p>我似乎不属于个例——一直以来都特意关注了我所能遇到的Octopress搭建的独立博客，<em>大部分Octopress我所遇到中文博客都很少更新，其中大多迁移到Octopress后几个月内就不再更新了</em>。
结合这几个月为数不多的使用，说一下Octopress的使用感受。</p>

<!--more-->


<h2>对ruby写的jekyll有种陌生的敬畏</h2>

<p>ruby从来没有学过，因此对自己不了解的东西始终有种不自觉的排斥(coder都会有这种感觉吧)，所以每次都是怀着忐忑的心情敲着 <code>rake new_post['XXX']</code> , <code>rake generate</code> ，生怕出现什么闪失而不知所措。可不幸的是，意外总是时而发生。而对此我只能做的就是打开octopress.org，照着文档重新搭建下环境。</p>

<h2>搭建环境简直就是pain in the ass</h2>

<p>我对ruby完全不了解（用了octopress感觉也不会用ruby了&hellip;）搭建环境非常繁琐，以下吐槽就当作一个不懂ruby的coder对ruby项目的吐槽吧。</p>

<p>首先是不能使用系统自带的ruby程序，需要单独下载 <code>rbenv</code> 或者 <code>rvm</code> 来搭建奇葩的ruby-1.9.3。（反观python，大多数应用直接使用默认的环境，多么的方便。）<br/>
而且每次实际上都是下载ruby源代码进行本地编译安装，<code>rbenv</code> / <code>rvm</code> 默认都需要从国外官网下载源码，速度在教育网可以说是惨不忍睹，再加之这两个工具都是个人开发，项目质量不好说，我偶尔会出现因网络问题导致失败重来的情况&hellip;<br/>
之后还要陆陆续续的现在一坨各种插件和工具，在漫长的（速度巨慢）忐忑的（尼玛要出出点啥问题我很难解决，ruby不会文档又少&hellip;）等待后，环境总算是搭建好了。<br/>
之后是 rbenv/rvm 的奇葩设置，这两种工具实际上每次都是靠<code>.bash_profile</code> 载入ruby-1.9.3环境，而Ubuntu默认的terminal必须要设置成非默认的<code>以shell运行的方式运行命令</code> 才会正常的载入ruby环境。<br/>
千辛万苦加若干次挫折你才能开始真正的写blog。</p>

<h2>不能“随时随地方便的写作”</h2>

<p>想在不同的地点，不同的电脑、设备中更新博客几乎是不可能的。（事实上这是可能的，我之前努力研究过，非常麻烦）而我的环境恰恰就是这个样子：实验室常用主机一台，宿舍笔记本一台。仅仅多了一台编辑设备，你需要更多的努力才能正确的将环境搭好。</p>

<p>这里简单的说下折腾的大致过程：</p>

<ol>
<li>clone自己blog的<code>source</code>分支到新电脑，比如clone到 <code>foo.github.com</code></li>
<li>在<code>foo.github.com</code>下新建目录<code>_deploy</code> 然后clone <code>master</code> 分支到该目录下</li>
<li>在<code>foo.github.com</code>下搭建octopress</li>
</ol>


<p>嗯，这仅仅是折腾的开始，如果在不同地点编辑的话，你需要经常<code>git pull</code>才可以，而且要是没有写好的blog，也需要push到服务器中，然后在另外的地方pull下来才能继续编辑。</p>

<hr />

<p>吐槽到此结束，没有坚持写博客，上述都是次要原因，主要的原因应该还是自己比较懒&hellip;（Octopress又让写博客变得略微的艰难，于是更加的懒）</p>

<p>嗯&hellip;你没猜错，这是又要搬家的节奏&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻墙下载附带字幕的youtube视频]]></title>
    <link href="http://liuyix.org/blog/2013/youtube-download-with-subtitle/"/>
    <updated>2013-08-09T23:59:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/youtube-download-with-subtitle</id>
    <content type="html"><![CDATA[<blockquote><p>许久没写了，上一篇水文教程。</p></blockquote>

<p>需要的工具：</p>

<ul>
<li><a href="https://code.google.com/p/goagent/">goagent</a></li>
<li><a href="http://rg3.github.io/youtube-dl/download.html">youtube-dl</a></li>
</ul>


<p>goagent教程就不上了，这个是翻墙的基本知识。:-P</p>

<h3>使用youtube-dl下载youtube视频</h3>

<p>事先声明, Windows平台的我没有试过。按照说明需要安装python 2.6以上的版本才能运行。<br/>
然后先用浏览器翻墙看一下复制你要下载的youtube的链接，比如 <a href="http://www.youtube.com/watch?v=9bZkp7q19f0">http://www.youtube.com/watch?v=9bZkp7q19f0</a><br/>
然后进入命令行，输入</p>

<ol>
<li>此步骤可选，若想选择下载的格式和大小，则可以先列出可下载的格式列表，使用命令： <code>./youtube-dl --write-sub --proxy 'http://127.0.0.1:8087' --list-formats http://www.youtube.com/watch?v=OPethpwuYEk</code></li>
<li>若执行了(1)则此步骤中可以指定<code>--format 22</code>, 即<code>./youtube-dl --write-sub --proxy 'http://127.0.0.1:8087' --format 22 http://www.youtube.com/watch?v=OPethpwuYEk</code></li>
</ol>


<p>几分钟之后就会下载好选择的视频(文件名称默认为解析出的视频名称)</p>

<hr />

<p>让我的感觉印象深刻的是这个项目是由python编写，但是项目的部署非常不错，只有一个可执行文件，没有任何其他依赖。这个之后研究下 :&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 4.3新特性——SElinux简介 ]]></title>
    <link href="http://liuyix.org/blog/2013/android-4-dot-3-selinux/"/>
    <updated>2013-07-28T00:32:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/android-4-dot-3-selinux</id>
    <content type="html"><![CDATA[<p>New Jelly Bean &mdash; Android 4.3于7月底发布，这次整体上变化不是很大，所以还是叫Jelly Bean。不过在底层，Android在安全上实际增强了不少，Android 4.3开始集成SELinux, 系统的安全性(<em>潜力</em>)提高了一个档次。</p>

<p>New Jelly Bean, New JB，Android 4.3指的都是Google新发布的Android 4.3系统，代号依旧是Jelly Bean</p>

<h2>The End of Root?</h2>

<p><strong>Absolutely NO!!</strong></p>

<ol>
<li>SELinux 目前（从长远看也很可能）是 <em>permissive</em> 模式，即不会拒绝而只是记录<em>违规</em>事件；而不是最严格的 <em>enforce</em> 模式——只要违反规则就会denial，因为普通消费者能遇到的应用和情形会非常复杂，如果使用该模式会出现更多的问题，同时也会给用户束缚自由的感觉（如同厂商卖给你手机的同时给你规定好了“你只可以xxxx而不能xxxx”，不管你是不是这样觉得，我反正是这么觉得）。这也就意味着使用漏洞提权的方法获得root权限依旧可行，只要SELinux使用的是<code>permissive</code>模式。</li>
<li>即使SELinux设置为<code>enforce</code>模式，也不会是root的末日。我们还可以通过<em>线刷</em>的方法刷入修改的或者其他的定制ROM方法获取Root权限。这样做的前提是手机厂商不锁bootloader（从而给用户自由刷机的权利）。谷歌的Nexus系列就是不锁bootloader——可以使用<code>fastboot oem unlock</code> 解锁，之后就可以用<code>fastboot</code>随意的修改定制手机ROM。
而三星手机没有强硬的采取严格的手段锁bootloader，可以用Samsung的<em>官方</em>刷机工具Odin<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>刷机，一样可以实现不锁bootloader的效果——随意修改定制手机。其他厂商就不太了解了。</li>
</ol>


<h4>New challenge for Root</h4>

<p>New Jelly Bean给root确实增加一些阻碍，这其中包括：增加了nosuid选项的system分区以及root用户的capabilities的限制。所以两位手机root的大神chainfire和koush在New JB上都采用了新的 <em>daemon</em> 模式。</p>

<!--more-->


<h2>SELinux带来了什么？</h2>

<p>极大的增强了Android系统的安全性潜力，SELinux机制实际效用依赖于<code>selinux policy</code>等SELinux的设定。SELinux的加入为Android进入更高安全性和保密性的团体和企业中提供了很大的便利，Android在企业市场有了更多的想象空间。<br/>
试举一栗子：涉密企业项目的成员移动设备定制化安全服务——可以由Android安全服务公司负责定制ROM，根据项目或者企业需求加入定制化的SELinux策略。好吧，Android移动安全领域的门槛又矮了一截子。</p>

<h2>Android SELinux一窥</h2>

<p>Google写的SELinux Guide（<a href="https://source.android.com/devices/tech/security/se-linux.html">here</a>）对部署和设置SELinux提出了指导性的概括。 <br/>
SELinux模块包含了内核空间和用户空间两部分，配置SELinux需要使用相应的Android内核。</p>

<h3>SELinux 编译和部署</h3>

<ol>
<li><p>下载源代码至<code>&lt;root&gt;/device/manufacturer/device-name/sepolicy</code>：</p>

<ul>
<li>包含SELinux的内核： <a href="https://android.googlesource.com/kernel/common/">https://android.googlesource.com/kernel/common/</a></li>
<li>编译时需要提供的SELinux配置文件: <a href="https://android.googlesource.com/platform/external/sepolicy/">https://android.googlesource.com/platform/external/sepolicy/</a></li>
</ul>
</li>
<li><p>修改BoardConfig.mk</p></li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>BOARD_SEPOLICY_DIRS :<span class="o">=</span> <span class="se">\</span>
</span><span class='line'>        &lt;root&gt;/device/manufacturer/device-name/sepolicy
</span><span class='line'>
</span><span class='line'>BOARD_SEPOLICY_UNION :<span class="o">=</span> <span class="se">\</span>
</span><span class='line'>        genfs_contexts <span class="se">\ </span>
</span><span class='line'>        file_contexts <span class="se">\ </span>
</span><span class='line'>        sepolicy.te
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>重新编译内核</li>
</ol>


<h3>SELinux定制流程(via Google)</h3>

<blockquote><ul>
<li><p>SELinux uses a whitelist approach, meaning it grants special privileges based upon role. Because the default policy provided by Android is so permissive, OEMs have great leeway in strengthening it. Here is how we recommend proceeding:</p></li>
<li><p>Use the latest Android kernel.</p></li>
<li>Adopt the principle of least privilege.</li>
<li>Address only your own additions to Android. The default policy works with the Android Open Source Project codebase automatically.</li>
<li>Compartmentalize software components into modules that conduct singular tasks.</li>
<li>Create SELinux policies that isolate those tasks from unrelated functions.</li>
<li>Put those policies in *.te files (the extension for SELinux policy source files) within the <root>/device/manufacturer/device-name/sepolicy directory.</li>
<li>Release your SELinux implementation in permissive mode first.</li>
<li>Analyze results and refine policy settings.</li>
</ul>
</blockquote>

<h2>More about SELinux for Android</h2>

<p>本节大部分信息都是从<a href="http://selinuxproject.org/page/SEAndroid">SEAndroid Wiki</a>上获取.</p>

<p>Android 4.3 采用的是SEAndroid<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，但是做了相当的精简和改变，其中没有以下部分<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>：</p>

<ul>
<li>SELinux管理API以及附带的示例程序 (The new device admin APIs for managing the SELinux functionality and the SEAdmin sample device admin app for using those APIs.)</li>
<li>除了 <code>a restricted form of its sefinfo support for labeling apps</code> 以外，没有任何MAC机制的中间件。</li>
<li>没有 <code>auditd</code> ,<em>也就是说Android 4.3并没有一个收集SELinux审计log的daemon程序</em> （The audit daemon (auditd) for collecting SELinux audit denials and writing them to /data/misc/audit/audit.log. )</li>
<li>采用和SEAndroid不同的策略，<em>fully permissive and unconfined</em> (Our sample policy configuration (Android 4.3 and AOSP master have diverged from our policy, replacing it with a policy that is fully permissive and unconfined).
)</li>
<li>没有重载SELinux策略上的优化，重载策略还需要重启daemon(Some improvements to how policy reloading is handled, particularly avoiding the need to restart daemons.)</li>
<li>对于多用户目录没有合适的安全标签（<code>security label</code>)</li>
</ul>


<p>所以如果想使用<em>完整版</em>的SEAndroid需要去下载使用独立的<a href="https://bitbucket.org/seandroid">SEAndroid</a></p>

<hr />

<p>未完待续&hellip;</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>有关Odin的XDA论坛地址：<a href="http://forum.xda-developers.com/showthread.php?t=2189539">http://forum.xda-developers.com/showthread.php?t=2189539</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>SELinux项目地址：<a href="https://bitbucket.org/seandroid">https://bitbucket.org/seandroid</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="http://selinuxproject.org/page/SEAndroid#Merge_Status">http://selinuxproject.org/page/SEAndroid#Merge_Status</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android平台上的JNI技术介绍]]></title>
    <link href="http://liuyix.org/blog/2013/android-ndk-and-jni-introduction/"/>
    <updated>2013-07-15T06:00:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/android-ndk-and-jni-introduction</id>
    <content type="html"><![CDATA[<h2>NDK简介</h2>

<p>Android是由Google领导开发的操作系统，Android依靠其开放性，迅速普及，成为目前最流行的智能手机操作系统。</p>

<p><img src="http://liuyix.org/images/android-system-architecture.jpg" alt="/images/android-system-architecture.jpg" /></p>

<center>图0-1 Android系统架构图</center>


<p>图0-1是Android系统架构图。</p>

<!--more-->


<p>大多数程序位于最上层的Java Application层。Android通过把系统划分为几个层次从而使得开发者可以使用平台无关的Java语言进行Android应用开发，不必关心程序实际的硬件环境。 Google不仅为开发者提供了SDK开发套件，为了能让开发者使用C/C++编写的本地化的共享库，利用编译后的共享库更高效的完成计算密集型的操作来提高应用的性能，或者移植重用已有的C/C++组件，提高开发效率，Android 1.5之后，又推出了NDK（Native Development Kit）。有了NDK，开发者能够在Android平台上使用JNI(Java Native Interface)技术，实现应用程序中调用本地二进制共享库。 由于Android系统不同于以往的JNI使用环境而是在嵌入式硬件环境下，Android NDK提供了一套交叉编译工具链,和构建程序的工具方便开发者在桌面环境下编译目标平台的二进制共享库。 目前NDK提供了对ARMv5TE,ARMv7-A,x86和MIPS指令集平台的支持，同时在本地接口的支持上，目前以下本地接口支持</p>

<ul>
<li>libc</li>
<li>libm</li>
<li>libz</li>
<li>liblog</li>
<li>OpenGL ES 1.1 and OpenGL ES 2.0 (3D graphics libraries) headers</li>
<li>libjnigraphics (Pixel buffer access) header (Android 2.2 以上可用).</li>
<li>C++头文件的一个子集</li>
<li>Android native应用API接口</li>
<li>JNI头文件接口</li>
</ul>


<p>由上面的介绍，我们可以知道，实际上NDK开发是以JNI技术为基础的，因此要求开发者必须要掌握基本的JNI技术，这样才能进行有效的NDK开发。</p>

<h2>JNI技术简介</h2>

<p>JNI（Java Native Interface）是Java SDK 1.1时正式推出的，目的是为不同JVM实现间提供一个标准接口，从而使Java应用可以使用本地二进制共享库，扩充了原有JVM的能力，同时Java程序仍然无需再次编译就可以运行在其他平台上，即保持了平台独立性又能使用平台相关的本地共享库提升性能。在Java开发中的位置如下图所示。JNI作为连接平台独立的Java层(以下简称Java层)与与平台相关的本地环境(以下简称Native层)之间的桥梁。</p>

<p><img src="http://liuyix.org/images/role-of-jni-intro.gif" alt="/images/role-of-jni-intro.gif" /></p>

<p>图1-1 JNI在Java开发中的位置</p>

<p>实际上在Android内部就大量的使用了JNI技术，尤其是在Libraries层和Framework层。</p>

<h2>何时使用Android NDK</h2>

<p>Google在其文档提到了NDK不能让大多数应用获益,其增加的复杂度远大于获得的性能的代价。Google建议当需要做大量的cpu密集同时少量存储操作或者重用C/C++代码时可以考虑使用NDK。 本文的余下部分将具体介绍Android平台下通过NDK的支持的如何进行JNI的开发。</p>

<h2>Hello,NDK</h2>

<p>本节通过一个简单的例子，介绍NDK开发流程以及JNI的基本使用。 笔者假定你已经下载了NDK，且有Android SDK开发的经验。 在NDK开发包中就有若干的NDK示例。其中 <code>hello-jni</code> 是一个简单的实例。该实例从native层传递字符串到java层，并显示在界面上。（你可以在Eclipse里选择 <strong>新建Anroid项目</strong> ,之后选择 “Create project from existing source”，并定位到NDK目录中的 <strong>Sample/hello-jni</strong> ,这样就可以将示例代码导入到Eclipse中。） HelloJni的Java代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">example</span><span class="o">.</span><span class="na">hellojni</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">android.app.Activity</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">android.view.View</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">android.widget.Button</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">android.widget.TextView</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">android.os.Bundle</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">android.view.View.OnClickListener</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloJni</span> <span class="kd">extends</span> <span class="n">Activity</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="cm">/** Called when the activity is first created. */</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
</span><span class='line'>        <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">main</span><span class="o">);</span>
</span><span class='line'>        <span class="n">Button</span> <span class="n">btn</span> <span class="o">=</span> <span class="o">(</span><span class="n">Button</span><span class="o">)</span><span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">btn</span><span class="o">);</span>
</span><span class='line'>        <span class="kd">final</span> <span class="n">TextView</span> <span class="n">txtv</span> <span class="o">=</span> <span class="o">(</span><span class="n">TextView</span><span class="o">)</span><span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">txtv</span><span class="o">);</span>
</span><span class='line'>        <span class="n">btn</span><span class="o">.</span><span class="na">setOnClickListener</span><span class="o">(</span><span class="k">new</span> <span class="n">OnClickListener</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>            <span class="nd">@Override</span>
</span><span class='line'>            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onClick</span><span class="o">(</span><span class="n">View</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">txtv</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="n">stringFromJNI</span><span class="o">());</span><span class="c1">//调用native函数</span>
</span><span class='line'>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">});</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* A native method that is implemented by the</span>
</span><span class='line'><span class="cm">     * &#39;hello-jni&#39; native library, which is packaged</span>
</span><span class='line'><span class="cm">     * with this application.</span>
</span><span class='line'><span class="cm">     * 声明含有native关键词的函数，就可以在类中使用了。</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">native</span> <span class="n">String</span>  <span class="nf">stringFromJNI</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* </span>
</span><span class='line'><span class="cm">     * 该函数并没有在共享库中实现，但是仍然可以声明。</span>
</span><span class='line'><span class="cm">     * 没有实现的native函数也可以在类中声明，native方法仅在首次调用时才开始搜索。</span>
</span><span class='line'><span class="cm">     * 若没有找到该方法，会抛出java.lang.UnsatisfiedLinkError异常</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">native</span> <span class="n">String</span>  <span class="nf">unimplementedStringFromJNI</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* this is used to load the &#39;hello-jni&#39; library on application</span>
</span><span class='line'><span class="cm">     * startup. The library has already been unpacked into</span>
</span><span class='line'><span class="cm">     * /data/data/com.example.HelloJni/lib/libhello-jni.so at</span>
</span><span class='line'><span class="cm">     * installation time by the package manager.</span>
</span><span class='line'><span class="cm">     * 使用静态方式再创建类时就载入共享库，该共享库（后面会介绍）在程序安装后</span>
</span><span class='line'><span class="cm">     * 位于/data/data/com.example.HelloJni/lib/libhello-jni.so</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">static</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">loadLibrary</span><span class="o">(</span><span class="s">&quot;hello-jni&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Java代码中调用native函数很简单。大致分为以下几步：</p>

<ul>
<li>调用 <code>System.loadLibrary</code> 方法载入共享库</li>
<li>声明native方法</li>
<li>调用native方法</li>
</ul>


<p>JNI的使用的一个关键点是 1) 如何找到共享库 2)如何将Java代码中的声明的native方法和实际的C/C++共享库中的代码相关联，即JNI函数注册。 第一个问题可以交给NDK构建工具 <code>ndk-build</code> 解决:通常是将编译好的so共享库放在 <code>libs/armeabi/libXXX.so</code> 之后会有更详细的介绍。第二个问题可以将在第二节中系统讲述，现在我们只简单的说一下如何做。</p>

<h3>利用javah生成目标头文件</h3>

<p>简易实用的方法是通过利用Java提供的 <code>javah</code> 工具生成和声明的native函数对应的头文件。具体操作是如下：</p>

<ol>
<li> 命令行进入到你的项目目录中</li>
<li> 确认你的android项目的java代码已经编译，如果存在 <code>bin/</code> 目录，应该是编译好的。</li>
<li> 确认你的android项目目录中存在 <code>jni</code> 子目录，如果没有则创建一个（我们现在使用的自带的实例代码，因此可以）。</li>
<li> 在项目根目录下执行命令： <code>javah -jni com.example.hellojni.HelloJNI -classpath bin/classes -o jni/hello-jni.h</code> <strong>确认javah所在路径已经在的$PATH路径下</strong></li>
<li> 若上一命令执行成功，则会在 <code>jni</code> 目录下生成一个名为 <code>my_jni_header.h</code> 的头文件。</li>
</ol>


<h3>编写C/C++共享库代码</h3>

<p>上一步骤我们得到了与Java源文件对应的头文件，因此只要编写 <code>my_jni_header.c</code> ，实现头文件里面的声明的源代码。生成的内容如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cm">/* DO NOT EDIT THIS FILE - it is machine generated */</span>
</span><span class='line'><span class="cp">#include &lt;jni.h&gt;</span>
</span><span class='line'><span class="cm">/* Header for class com_example_hellojni_HelloJni */</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#ifndef _Included_com_example_hellojni_HelloJni</span>
</span><span class='line'><span class="cp">#define _Included_com_example_hellojni_HelloJni</span>
</span><span class='line'><span class="cp">#ifdef __cplusplus</span>
</span><span class='line'><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * Class:     com_example_hellojni_HelloJni</span>
</span><span class='line'><span class="cm"> * Method:    stringFromJNI</span>
</span><span class='line'><span class="cm"> * Signature: ()Ljava/lang/String;</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">JNIEXPORT</span> <span class="n">jstring</span> <span class="n">JNICALL</span> <span class="n">Java_com_example_hellojni_HelloJni_stringFromJNI</span>
</span><span class='line'>  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * Class:     com_example_hellojni_HelloJni</span>
</span><span class='line'><span class="cm"> * Method:    unimplementedStringFromJNI</span>
</span><span class='line'><span class="cm"> * Signature: ()Ljava/lang/String;</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">JNIEXPORT</span> <span class="n">jstring</span> <span class="n">JNICALL</span> <span class="n">Java_com_example_hellojni_HelloJni_unimplementedStringFromJNI</span>
</span><span class='line'>  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#ifdef __cplusplus</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到生成的头文件中的函数和示例项目 <code>hello-jni</code> 中的 <code>hello-jni.c</code> 正好对应。据此也可知我们生成的头文件是正确的。 <code>hello-jni.c</code> 源代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;string.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;jni.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* This is a trivial JNI example where we use a native method</span>
</span><span class='line'><span class="cm"> * to return a new VM String. See the corresponding Java source</span>
</span><span class='line'><span class="cm"> * file located at:</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> *   apps/samples/hello-jni/project/src/com/example/HelloJni/HelloJni.java</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">jstring</span>
</span><span class='line'><span class="n">Java_com_example_hellojni_HelloJni_stringFromJNI</span><span class="p">(</span> <span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span>
</span><span class='line'>                                                  <span class="n">jobject</span> <span class="n">thiz</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="s">&quot;Hello from JNI.&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">NewStringUTF</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>使用NDK提供的工具编译生成共享库</h3>

<p>经过以上两步，我们已经得到了C/C++共享库的源代码，现在需要使用交叉编译工具将其编译成目标机器上的二进制共享库。NDK工具提供了一个简单的构建系统，开发者之需要编写 <code>Android.mk</code> ，之后在项目根目录下执行命令 <code>ndk-build</code> 就可以完成交叉编译过程。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">LOCAL_PATH</span> <span class="o">:=</span> <span class="err">$</span><span class="p">(</span><span class="n">call</span> <span class="n">my</span><span class="o">-</span><span class="n">dir</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">CLEAR_VARS</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">LOCAL_MODULE</span>    <span class="o">:=</span> <span class="n">hello</span><span class="o">-</span><span class="n">jni</span>
</span><span class='line'><span class="n">LOCAL_SRC_FILES</span> <span class="o">:=</span> <span class="n">hello</span><span class="o">-</span><span class="n">jni2</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">BUILD_SHARED_LIBRARY</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Android.mk</code> 可以看作是小型的makefile，关于 <code>Android.mk</code> 的更多细节，限于篇幅，这里不做详细介绍请参考NDK自带文档，里面有完整的介绍。 输出的信息类似下面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">Gdbserver</span>      <span class="o">:</span> <span class="p">[</span><span class="n">arm</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">androideabi</span><span class="o">-</span><span class="mf">4.4.3</span><span class="p">]</span> <span class="n">libs</span><span class="o">/</span><span class="n">armeabi</span><span class="o">/</span><span class="n">gdbserver</span>
</span><span class='line'><span class="n">Gdbsetup</span>       <span class="o">:</span> <span class="n">libs</span><span class="o">/</span><span class="n">armeabi</span><span class="o">/</span><span class="n">gdb</span><span class="p">.</span><span class="n">setup</span>
</span><span class='line'><span class="n">Compile</span> <span class="n">thumb</span>  <span class="o">:</span> <span class="n">hello</span><span class="o">-</span><span class="n">jni</span> <span class="o">&lt;=</span> <span class="n">hello</span><span class="o">-</span><span class="n">jni</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'><span class="n">SharedLibrary</span>  <span class="o">:</span> <span class="n">libhello</span><span class="o">-</span><span class="n">jni</span><span class="p">.</span><span class="n">so</span>
</span><span class='line'><span class="n">Install</span>        <span class="o">:</span> <span class="n">libhello</span><span class="o">-</span><span class="n">jni</span><span class="p">.</span><span class="n">so</span> <span class="o">=&gt;</span> <span class="n">libs</span><span class="o">/</span><span class="n">armeabi</span><span class="o">/</span><span class="n">libhello</span><span class="o">-</span><span class="n">jni</span><span class="p">.</span><span class="n">so</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的信息告诉我们生成好的so文件路径为 <code>libs/armeabi/libhello-jni.so</code> 。至此一个简单的NDK程序的已经制作完成。 总结一下大致过程是：</p>

<ul>
<li>编写好Java源文件，使用静态代码段载入共享库，并声明native函数。之后编译android项目</li>
<li>使用 <code>javah</code> 工具生成头文件</li>
<li>根据头文件编写native函数</li>
<li>利用 <code>ndk-build</code> 完成共享库的编译</li>
</ul>


<h2>native函数的动态注册方法</h2>

<p>上一节我们通过一个简单的实例，对NDK开发有了一个感性的认识。但是你也许会发现Java层上声明的native函数与native上面的实现之间的关联是通过javah生成头文件完成的，这个方法显得很笨拙。 实际上这种静态注册的方法是通过函数名（ <code>Java_com_example_hellojni_HelloJni_stringFromJNI</code> ）来建立联系。这种做法有诸多弊端：</p>

<ul>
<li>名字很长，没有可读性。</li>
<li>每个声明了native函数的类都要生成一个对应的头文件，对于真实的应用程序，类文件很多时不现实。</li>
<li>每次载入都需要查询native函数，效率低。</li>
</ul>


<p>Android内部实现上，在使用JNI时很显然并没有这样做，它采用了更加规范的 <code>动态注册</code> 的方法进行两个层次上的关联。</p>

<h3>动态注册版Hello-Jni</h3>

<p>以下代码是上面的 <code>hell-jni.c</code> 的动态注册版，代码中使用的是自定义的native函数名称。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;string.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;jni.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">jstring</span> <span class="n">getHelloString</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="n">JNINativeMethod</span> <span class="n">gMethods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>    <span class="s">&quot;stringFromJNI&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s">&quot;()Ljava/lang/String;&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">getHelloString</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">nMethods</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">jstring</span> <span class="n">getHelloString</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="s">&quot;Hello from JNI.&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">NewStringUTF</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">jint</span> <span class="n">JNI_OnLoad</span><span class="p">(</span><span class="n">JavaVM</span> <span class="o">*</span><span class="n">vm</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">reserved</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">jint</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="n">jclass</span> <span class="n">clz</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">vm</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetEnv</span><span class="p">(</span><span class="n">vm</span><span class="p">,(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">env</span><span class="p">,</span> <span class="n">JNI_VERSION_1_4</span><span class="p">)</span> <span class="o">!=</span> <span class="n">JNI_OK</span><span class="p">){</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">clz</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FindClass</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="s">&quot;com/example/hellojni/HelloJni&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RegisterNatives</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="n">clz</span><span class="p">,</span><span class="n">gMethods</span><span class="p">,</span><span class="n">nMethods</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">JNI_VERSION_1_4</span><span class="p">;</span><span class="c1">//根据JNI规范，JNI_OnLoad必须返回版本号常量否则出错。</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>根据Java的官方文档<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，当VM载入共享库时，会寻找 <code>jint JNI_OnLoad(JavaVM *vm, void *reserved)</code> 函数，如果存在则再载入共享库之后调用该函数。因此我们可以在该函数中完成native函数的注册工作。 <code>JNI_OnLoad</code> 函数的参数有两个，最主要就是 <code>JavaVM</code> 结构。 <code>JavaVM</code> 是存储VM信息的数据结构。更多信息将在后面讲到，这里我们只需要知道，通过JavaVM指针我们可以得到另一个JNI核心结构—— <code>JNIEnv</code> , <code>JNIEnv</code> 代表了整个JNI环境的数据结构，实际是一个函数表,其中存储了JNI的各种相关操作的函数指针，后文会详细介绍，在这里我们只需要知道在JNIEnv结构有以下的方法，通过调用就可以实现动态注册。</p>

<ul>
<li><code>jclass FindClass(JNIEnv *env, const char *name)</code> 传入JNIEnv指针和类名称返回代表这个类的结构<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></li>
<li><code>jint RegisterNatives(JNIEnv *env, jclass clazz,const JNINativeMethod *methods, jint nMethods)</code> 注册native函数的函数<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></li>
</ul>


<h3>JNINativeMethod结构</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">`</span><span class="n">RegisterNatives</span><span class="err">`</span> <span class="err">用来注册一组</span><span class="n">native</span><span class="err">函数，其中使用到了</span> <span class="err">`</span><span class="n">JNINativeMethod</span><span class="err">`</span> <span class="err">结构，具体定义如下</span><span class="mi">3</span><span class="err">：</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span> <span class="c1">//Java代码中声明的native函数的名称</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">char</span> <span class="o">*</span><span class="n">signature</span><span class="p">;</span> <span class="c1">//对应Java代码层native函数的签名，下面会介绍</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">void</span> <span class="o">*</span><span class="n">fnPtr</span><span class="p">;</span> <span class="c1">//共享库中函数指针</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="n">JNINativeMethod</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这里就涉及到了 <strong>函数签名</strong></p>

<h4>函数签名</h4>

<p>Java允许函数重载，因此在注册时就要具体区分出来，否则会出现混乱，因而这里就要使用一种方法将每个Java中的方法标上唯一的标记。这种方法就是 <strong>函数签名</strong> 。函数签名应该属于JVM内部的规范，不具有可读性。规定<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>如下：</p>

<table>
<thead>
<tr>
<th></th>
<th>类型标识 </th>
<th> Java类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Z </td>
<td> boolean</td>
</tr>
<tr>
<td></td>
<td> B </td>
<td> byte </td>
</tr>
<tr>
<td></td>
<td> C </td>
<td> char </td>
</tr>
<tr>
<td></td>
<td> S </td>
<td> short</td>
</tr>
<tr>
<td></td>
<td> I </td>
<td> int </td>
</tr>
<tr>
<td></td>
<td> J </td>
<td> long </td>
</tr>
<tr>
<td></td>
<td> F </td>
<td> float </td>
</tr>
<tr>
<td></td>
<td> D </td>
<td> double </td>
</tr>
<tr>
<td></td>
<td> L/java/lang/String; </td>
<td> String </td>
</tr>
<tr>
<td></td>
<td> [I </td>
<td> int[] </td>
</tr>
<tr>
<td></td>
<td> [L/java/lang/object; </td>
<td> Object[] </td>
</tr>
<tr>
<td></td>
<td> V </td>
<td> void </td>
</tr>
</tbody>
</table>


<p> 表1 类型标示对应表</p>

<p>每个函数签名大致格式 <code>(&lt;参数签名&gt;)返回值类型签名</code> 引用类型的参数签名形式为 <code>L&lt;包名&gt;</code></p>

<table>
<thead>
<tr>
<th></th>
<th> Java函数函数签名 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> String f()</td>
</tr>
<tr>
<td></td>
<td> ()L/java/lang/String;</td>
</tr>
<tr>
<td></td>
<td> void f(String s,AClass cls,long l)</td>
</tr>
<tr>
<td></td>
<td> (L/java/lang/String;L/com/example/AClass;J)V</td>
</tr>
<tr>
<td></td>
<td> String f(byte[]) </td>
</tr>
<tr>
<td></td>
<td> ([B)V</td>
</tr>
</tbody>
</table>


<p>表2 一些签名示例 函数看起来很难懂，我们可以利用 <code>javap</code> 工具查看类中的函数签名那个信息，具体用法：</p>

<ol>
<li> 命令行转到 <code>$PROJECT/bin/classes</code> 下（$PROJECT代表Android程序项目根目录，并假定java文件已经编译好，存在bin目录）</li>
<li> 执行命令 <code>javap -s com.example.helljni.HelloJni</code> 其中 <code>com.example.hellojni.HelloJni</code> 是类的完整名称</li>
</ol>


<h3>小结</h3>

<p>这一节中，通过动态注册版的hello-jni代码示例，简要介绍如何在JNI中实现更灵活的动态注册方法关联Java层中native函数和Native层中的实现函数。JNI规范中规定VM在载入共享库之后，要调用 <code>JNI_OnLoad</code> 函数，一般可以在共享库中实现该方法并完成动态注册。 初步接触了 <code>JavaVM</code> 结构和 <code>JNIEnv</code> 结构，并了解了 <code>JNIEnv</code> 的两个“函数成员” <code>FindClass</code> 和 <code>registerNatives</code> 。之后还看到了JNI中保存关联信息的 <code>JNINativeMethod</code> 结构以及了解了Java的 <strong>函数签名</strong> 。</p>

<h2>两个世界的数据互换</h2>

<p>Java层和Native层之间如同两个说着不同语言的国家一样，如果要互相交流就必须要懂得对方的语言。在Native层中是如何表示Java层的数据类型呢？</p>

<h3>基本数据类型和引用数据类型</h3>

<table>
<thead>
<tr>
<th></th>
<th>Java数据类型 </th>
<th> Native层数据类型 </th>
<th> 符号属性(unsigned/signed) </th>
<th> 长度(bit) </th>
<th> </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> boolean </td>
<td> jboolean </td>
<td> unsigned </td>
<td> 8 </td>
<td></td>
</tr>
<tr>
<td></td>
<td> byte </td>
<td> jbyte </td>
<td> unsigned </td>
<td> 8</td>
<td></td>
</tr>
<tr>
<td></td>
<td> char </td>
<td> jchar </td>
<td> unsigned </td>
<td> 16</td>
<td></td>
</tr>
<tr>
<td></td>
<td> short </td>
<td> jshort </td>
<td> signed </td>
<td> 16</td>
<td></td>
</tr>
<tr>
<td></td>
<td> int </td>
<td> jint </td>
<td> signed </td>
<td> 32 </td>
<td></td>
</tr>
<tr>
<td></td>
<td> long </td>
<td> jlong </td>
<td> signed </td>
<td> 64</td>
<td></td>
</tr>
<tr>
<td></td>
<td> float </td>
<td> jfloat </td>
<td> signed </td>
<td> 32</td>
<td></td>
</tr>
<tr>
<td></td>
<td> double </td>
<td> jdouble </td>
<td> signed </td>
<td> 64</td>
<td></td>
</tr>
</tbody>
</table>


<p> 表3 基本数据类型转换表</p>

<table>
<thead>
<tr>
<th></th>
<th> Java引用类型 </th>
<th> Native类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> 所有object </td>
<td> jobject</td>
</tr>
<tr>
<td></td>
<td> java.lang.Class </td>
<td> jclass</td>
</tr>
<tr>
<td></td>
<td> java.lang.String </td>
<td> jstring</td>
</tr>
<tr>
<td></td>
<td> Object[] </td>
<td> jobjectArray</td>
</tr>
<tr>
<td></td>
<td> boolean[] </td>
<td> jbooleanArray</td>
</tr>
<tr>
<td></td>
<td> byte[] </td>
<td> jbyteArray</td>
</tr>
<tr>
<td></td>
<td> char[] </td>
<td> jcharArray</td>
</tr>
<tr>
<td></td>
<td> short[] </td>
<td> jshortArray</td>
</tr>
<tr>
<td></td>
<td> int[] </td>
<td> jintArray</td>
</tr>
<tr>
<td></td>
<td> long[] </td>
<td> jlongArray</td>
</tr>
<tr>
<td></td>
<td> float[] </td>
<td> jfloatArray</td>
</tr>
<tr>
<td></td>
<td> double[] </td>
<td> jdoubleArray</td>
</tr>
<tr>
<td></td>
<td> java.lang.Throwable </td>
<td> jthrowable</td>
</tr>
</tbody>
</table>


<p> 表4 引用数据类型转换表 <br/>
 Native层中将除String以外的类都作为 <code>jobject</code> 处理，对于数组类型，只有基本数据类型的数组是单独表示，其他类型的都以 <code>jobjectArray</code> 类型存储。</p>

<h3>JavaVM</h3>

<p>JavaVM指针指向了一个代表整个VM的实例，同时对所有native线程都有效。主要有以下几个接口可以使用<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>：</p>

<ul>
<li><code>DestroyJavaVM</code> 卸载整个VM实例</li>
<li><code>AttachCurrentThread</code> 将当前的native线程attach到VM实例中，当线程加入到VM线程后，该线程就可以调用诸如访问Java对象、调用Java方法等JNI函数</li>
<li><code>DetachCurrentThread</code> 与 <code>AttachCurrentThread</code> 相反</li>
<li><code>GetEnv</code> 既可以用来检查当前线程是否已经attach到VM实例，还可以得到当前线程的JNIEnv结构。</li>
</ul>


<h3>JNIEnv</h3>

<p>JNIEnv接口包含了JNI的主要功能的函数接口，注意JNIEnv是与线程相关的结构，JNIEnv接口实际是指向内部的一个函数集合，要在Native层操纵某个具体的类，或者调用方法，则需要 <code>JNIEnv</code> 。在native函数的动态注册方法这一节就使用 <code>JNIEnv</code> 的函数进行了native函数的注册。 <code>JNIEnv</code> 是指向一个函数表的指针的指针。 其具体定义如下<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">typedef</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">JNINativeInterface</span> <span class="o">*</span><span class="n">JNIEnv</span><span class="p">;</span>
</span><span class='line'><span class="k">const</span> <span class="k">struct</span> <span class="n">JNINativeInterface</span> <span class="p">...</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>    <span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>    <span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>    <span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>    <span class="n">GetVersion</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">DefineClass</span><span class="p">,</span>
</span><span class='line'>    <span class="n">FindClass</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">FromReflectedMethod</span><span class="p">,</span>
</span><span class='line'>    <span class="n">FromReflectedField</span><span class="p">,</span>
</span><span class='line'>    <span class="n">ToReflectedMethod</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">GetSuperclass</span><span class="p">,</span>
</span><span class='line'>    <span class="n">IsAssignableFrom</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">ToReflectedField</span><span class="p">,</span>
</span><span class='line'>    <span class="p">....</span><span class="c1">//还有很多，这里略去</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>下图是 <code>JNIEnv</code> 的一个简单图示<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup></p>

<p><img src="http://liuyix.org/images/jnienv.gif" alt="/images/jnienv.gif" /></p>

<p>JNIEnv能提供的功能非常多，大体可以分为以下几类5：</p>

<ul>
<li>取得JavaVM实例</li>
<li>Java对象实例的操作

<ul>
<li>成员访问</li>
<li>方法调用</li>
</ul>
</li>
<li>静态成员的访问</li>
<li>String操作</li>
<li>Object操作</li>
<li>Array操作</li>
<li>Native方法的注册，前文介绍过。</li>
<li>Global Reference &amp; Local Reference</li>
<li>提供VM版本信息</li>
<li>JNI的Exception</li>
<li>对Java反射的支持</li>
</ul>


<p>限于篇幅，在此无法一一讲解用法。仅说明较常用的几个。更多详细信息请参考Sun出版的JNI开发者指南（<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/">地址</a>）</p>

<h4>通过JNIEnv在Native层对Java对象进行访问和调用</h4>

<p>通过JNIEnv提供的以下方法就可以调用对象的方法</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">//调用对象方法的函数原型</span>
</span><span class='line'><span class="n">NativeType</span> <span class="n">Call</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span><span class="n">Method</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span><span class="n">jmethodID</span> <span class="n">methodID</span><span class="p">,</span> <span class="p">...);</span>
</span><span class='line'><span class="n">NativeType</span> <span class="n">Call</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span><span class="n">MethodA</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span><span class="n">jmethodID</span> <span class="n">methodID</span><span class="p">,</span> <span class="n">jvalue</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
</span><span class='line'><span class="n">NativeType</span> <span class="n">Call</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span><span class="n">MethodV</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span><span class="n">jmethodID</span> <span class="n">methodID</span><span class="p">,</span> <span class="n">va_list</span> <span class="n">args</span><span class="p">);</span>
</span><span class='line'><span class="c1">//对对象成员操作的函数原型</span>
</span><span class='line'><span class="n">NativeType</span> <span class="n">Get</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span><span class="n">Field</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span><span class="n">jfieldID</span> <span class="n">fieldID</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span><span class="n">Field</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span> <span class="n">jfieldID</span> <span class="n">fieldID</span><span class="p">,</span><span class="n">NativeType</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'><span class="c1">//取得methodID,fieldId的函数原型</span>
</span><span class='line'><span class="n">jmethodID</span> <span class="n">GetMethodID</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jclass</span> <span class="n">clazz</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sig</span><span class="p">);</span>
</span><span class='line'><span class="n">jfieldID</span> <span class="n">GetFieldID</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jclass</span> <span class="n">clazz</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sig</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>前三个函数为一组调用对象方法的函数，区别仅在于传递参数的方式不同。其中 <code>NativeType</code> 表示Java方法返回值对应的Native类型，具体转换见表3,表4。 <code>&lt;type&gt;</code> 是 <code>Void</code> / <code>Boolean</code> / <code>Int</code> / <code>Long</code> / <code>Object</code> 等Java基本数据类型。调用这一组函数时，既需要传递对象的信息，还要传递方法的标识以及Java类中的方法的参数。 <code>jobject</code> 变量既可以通过在Native层中调用 <code>CallObjectMethod</code> 得到，也可以通过后面提到的创建对象实例得到。 <code>methodId</code> 则可以通过 <code>GetMethodID</code> 取得。 <code>jclass</code> 参数可以由前文提到的 <code>env-&gt;FindClass</code> 函数取得。 类似地，还有 <code>CallStatic&lt;type&gt;Method</code> 、 <code>GetStatic&lt;type&gt;Field</code> 、 <code>SetStatic&lt;type&gt;Field</code> 在此不再赘述。</p>

<h3>jstring</h3>

<p>由于String特别常用，且存在比较复杂的编码问题，JNI特意将String类作为一个独立的Native层中的数据类型jstring处理。同其他Object操作类似，jstring也是通过 <code>JNIEnv</code> 来管理的。主要的操作函数有：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">jstring</span> <span class="n">NewString</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="k">const</span> <span class="n">jchar</span> <span class="o">*</span><span class="n">unicodeChars</span><span class="p">,</span><span class="n">jsize</span> <span class="n">len</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">ReleaseStringChars</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">string</span><span class="p">,</span><span class="k">const</span> <span class="n">jchar</span> <span class="o">*</span><span class="n">chars</span><span class="p">);</span>
</span><span class='line'><span class="k">const</span> <span class="n">jchar</span> <span class="o">*</span> <span class="n">GetStringChars</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">string</span><span class="p">,</span><span class="n">jboolean</span> <span class="o">*</span><span class="n">isCopy</span><span class="p">);</span>
</span><span class='line'><span class="n">jsize</span> <span class="n">GetStringLength</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">string</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">jstring</span> <span class="n">NewStringUTF</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bytes</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">ReleaseStringUTFChars</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">string</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">utf</span><span class="p">);</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">GetStringUTFChars</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">string</span><span class="p">,</span><span class="n">jboolean</span> <span class="o">*</span><span class="n">isCopy</span><span class="p">);</span>
</span><span class='line'><span class="n">jsize</span> <span class="n">GetStringUTFLength</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">string</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数的功能可以从名称大致了解到，其中 <code>New</code> 开头的都是将JNI中将String按照编码分为两种，一种是Unicode编码（UTF-16），一种是UTF-8编码 需要注意的是Native层中并没有垃圾自动回收机制，因此申请字符串资源，用完之后要进行释放操作，否则会引起内存泄露。 使用过程中还要注意：Unicode字符串不是“0结尾”的，因此不要依赖 <code>\u0000</code> 进行字符串的操作。 常见的错误还包括调用 <code>NewStringUTF</code> 传入的参数 <code>bytes</code> 必须是 <code>Modified UTF-8</code> 格式的，否则会出现乱码。<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup></p>

<h3>jarray</h3>

<p>Native层可以通过操作jarray数据来处理Java层的数组类型。JNI中将基本类型Java数组和引用类型数组分开处理。 下面是几个Java数组的例子。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">int</span><span class="p">[]</span> <span class="n">iarr</span><span class="p">;</span> <span class="c1">//基本类型数组</span>
</span><span class='line'><span class="kt">float</span><span class="p">[]</span> <span class="n">farr</span><span class="p">;</span><span class="c1">//基本类型数组</span>
</span><span class='line'><span class="n">Object</span><span class="p">[]</span> <span class="n">oarr</span><span class="p">;</span><span class="c1">//引用类型数组，数组元素是Object</span>
</span><span class='line'><span class="kt">int</span><span class="p">[][]</span> <span class="n">arr2</span><span class="p">;</span><span class="c1">//引用类型数组，数组元素是 int[]</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>基本类型数组的操作</h3>

<p>下表是基本类型数组操作的函数小结</p>

<table>
<thead>
<tr>
<th></th>
<th> JNI函数描述 </th>
<th>    </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Get<Type>ArrayRegion </td>
<td> 将基本类型数组的数据复制到预先申请好的C数组中或者反方向操作操作</td>
</tr>
<tr>
<td></td>
<td> Set<Type>ArrayRegion </td>
<td>   </td>
</tr>
<tr>
<td></td>
<td> Get<Type>ArrayElements </td>
<td> 获得/释放指向基本类型数组的数据的指针</td>
</tr>
<tr>
<td></td>
<td> Release<Type>ArrayElements </td>
<td>   </td>
</tr>
<tr>
<td></td>
<td> GetArrayLength </td>
<td> 返回数组的长度</td>
</tr>
<tr>
<td></td>
<td> New<Type>Array </td>
<td> 新建一个指定长度的数组</td>
</tr>
<tr>
<td></td>
<td> GetPrimitiveArrayCritical </td>
<td> 获得/释放指向基本类型数据的指针</td>
</tr>
<tr>
<td></td>
<td> ReleasePrimitiveArrayCritical </td>
<td>   </td>
</tr>
</tbody>
</table>


<p>表5 基本数据类型数组的操作函数</p>

<h3>引用类型数组的操作</h3>

<p>下面以一个简单的代码片段作为说明<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup>。假设某段Java代码中声明了以下的native函数</p>

<pre><code>native int[][] get2DArray(int size);//返回 int[size][size]大小的二维数组
</code></pre>

<p>Native层可以用以下代码实现</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">jobjectArray</span> <span class="n">get2DArray</span><span class="p">(</span><span class="n">jint</span> <span class="n">size</span><span class="p">){</span>
</span><span class='line'>     <span class="n">jobjectArray</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>     <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>     <span class="n">jclass</span> <span class="n">intArrCls</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FindClass</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;[I&quot;</span><span class="p">);</span>
</span><span class='line'>     <span class="k">if</span> <span class="p">(</span><span class="n">intArrCls</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>         <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* exception thrown */</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">NewObjectArray</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">intArrCls</span><span class="p">,</span>
</span><span class='line'>                                     <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>     <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>         <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* out of memory error thrown 可能遇到空间不足*/</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>         <span class="n">jint</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>  <span class="cm">/* make sure it is large enough! */</span>
</span><span class='line'>         <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>         <span class="n">jintArray</span> <span class="n">iarr</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">NewIntArray</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'>         <span class="k">if</span> <span class="p">(</span><span class="n">iarr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>             <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* out of memory error thrown */</span>
</span><span class='line'>         <span class="p">}</span>
</span><span class='line'>         <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>             <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>         <span class="p">}</span>
</span><span class='line'>         <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SetIntArrayRegion</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">iarr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
</span><span class='line'>         <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SetObjectArrayElement</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">iarr</span><span class="p">);</span>
</span><span class='line'>         <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DeleteLocalRef</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">iarr</span><span class="p">);</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>上述代码展示了 <code>NewObjectArray</code> 、 <code>NewIntArray</code> 、 <code>SetObjectArrayElement</code> 、 <code>SetIntArrayRegion</code> 等函数的用法，代码可读性很高，这里不做进一步解释。</p>

<h2>垃圾回收管理</h2>

<p>Java作为高级语言，具有垃圾自动回收管理机制，内存管理相对轻松。而C/C++则没有这样的机制，因此在Native层对象实例可能被垃圾回收。这里就涉及到了JNI的对象引用的管理。 JNI支持三种引用类型—— <code>LocalReference</code> /  <code>GlobalReference</code> / <code>WeakGlobalReference</code> ，每一种引用类型的生命周期是不同的。 大多数JNI函数使用的是 <strong>LocalReference</strong> ,即在函数中调用的&#8221;New&#8221;操作返回的都是对象的 <code>LocalReference</code> 。 <code>LocalReference</code> 只在函数执行代码范围内有效，只要JNI函数一返回，引用就会被释放。相对地， <code>GlobalReference</code> 可以在多个函数之间共享，直到开发者自己调用释放函数才会被垃圾回收。另一方面 <code>WeakGlobalReference</code> 则具有 <strong>引用缓存</strong> 功能——一方面它可以像 <code>GlobalReference</code> 一样跨函数共享引用，另一方面它不会阻碍引用的垃圾回收过程。但JNI文档中建议开发者使用 <code>GlobalReference</code> 和 <code>LocalReference</code> 替代 <code>WeakGlobalReference</code> ,因为该引用随时都可能会被垃圾回收，即使是在调用了 <code>IsSameObject</code> 判定引用有效之后仍然可能会失效<sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup>。 有关引用的操作有</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">//GlobalReference</span>
</span><span class='line'><span class="n">jobject</span> <span class="n">NewGlobalRef</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">DeleteGlobalRef</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">globalRef</span><span class="p">);</span>
</span><span class='line'><span class="c1">//LocalReference</span>
</span><span class='line'><span class="kt">void</span> <span class="n">DeleteLocalRef</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">localRef</span><span class="p">);</span>
</span><span class='line'><span class="n">jobject</span> <span class="n">NewLocalRef</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">ref</span><span class="p">);</span>
</span><span class='line'><span class="c1">//WeakLocalReference</span>
</span><span class='line'><span class="n">jweak</span> <span class="n">NewWeakGlobalRef</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">DeleteWeakGlobalRef</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jweak</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="c1">//通用的引用操作</span>
</span><span class='line'><span class="n">jobject</span> <span class="n">AllocObject</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jclass</span> <span class="n">clazz</span><span class="p">);</span>
</span><span class='line'><span class="n">jobject</span> <span class="n">NewObject</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jclass</span> <span class="n">clazz</span><span class="p">,</span><span class="n">jmethodID</span> <span class="n">methodID</span><span class="p">,</span> <span class="p">...);</span>
</span><span class='line'><span class="n">jclass</span> <span class="n">GetObjectClass</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="n">jobjectRefType</span> <span class="n">GetObjectRefType</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="n">jboolean</span> <span class="n">IsSameObject</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">ref1</span><span class="p">,</span><span class="n">jobject</span> <span class="n">ref2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>更多信息请参考官方文档（<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#global_local">地址</a>)和JNI开发者指南(<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/refs.html">地址</a>)</p>

<h2>总结</h2>

<p>本文大致介绍了Android NDK的相关技术以及NDK的基础——JNI的使用，其中简述了NDK的开发流程、函数注册的两种方式、JNI技术的基本内容，其中包括了Java层和Native层之间的数据转换和互操作方法。不难发现，JNI技术扩展了原有Java技术的能力。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Java Native Interface Specification <a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/invocation.html">http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/invocation.html</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#wp16027">http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#wp16027</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#wp17734">http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#wp17734</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>深入理解Android：卷I pp28-29 <a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>Java Native Interface: Programmer&rsquo;s Guide and Specification <a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html">http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html</a><a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p>JNIEnv定义 <a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#wp23720">http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#wp23720</a><a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
<li id="fn:7">
<p><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/objtypes.html#5190">http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/objtypes.html#5190</a><a href="#fnref:7" rev="footnote">&#8617;</a></p></li>
<li id="fn:8">
<p>Android Developers JNI Tips <a href="http://developer.android.com/guide/practices/design/jni.html#UTF_8_and_UTF_16_strings">http://developer.android.com/guide/practices/design/jni.html#UTF_8_and_UTF_16_strings</a><a href="#fnref:8" rev="footnote">&#8617;</a></p></li>
<li id="fn:9">
<p>代码改编自 (The Java Native Interface Programmer&rsquo;s Guide and Specification)<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/objtypes.html#27791">http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/objtypes.html#27791</a><a href="#fnref:9" rev="footnote">&#8617;</a></p></li>
<li id="fn:10">
<p><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#weak">http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html#weak</a><a href="#fnref:10" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Root 那些事]]></title>
    <link href="http://liuyix.org/blog/2013/android-root/"/>
    <updated>2013-07-14T19:14:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/android-root</id>
    <content type="html"><![CDATA[<h2>Root</h2>

<p>所谓root就是在Android手机上获取最高权限，Android的底层就是Linux，因此Root过程就是普通Linux用户的提权过程。</p>

<!--more-->


<h2>获得Root的几个思路</h2>

<ul>
<li>利用Android内核漏洞(实际上也是Linux的漏洞)进行提权</li>
<li>使用<code>fastboot</code> 或者厂商提供的刷机工具(比如三星的 <em>Odin</em> )刷入修改的Kernel或者第三方的Recovery，再刷入root程序</li>
</ul>


<h2>Root文件</h2>

<ul>
<li>su</li>
<li>root权限管理应用: 如常用的Superuser.apk/SuperSU.apk</li>
</ul>


<h2>Opensourced Superuser</h2>

<p>Android Hack界大神Koush写了被广泛使用的Root管理软件: <a href="https://play.google.com/store/apps/details?id=com.noshufou.android.su&amp;hl=en">Superuser</a>
Koush的Superuser由于Cyanogenmod的一部分，因此是开源的。地址：<a href="https://github.com/koush/Superuser">https://github.com/koush/Superuser</a><br/>
阅读代码我们就可以了解Android的Root管理应用以及su原理以及如何实现的。</p>

<p>未完待续&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《程序员的自我修养》小结]]></title>
    <link href="http://liuyix.org/blog/2013/advanced-linkers-and-loaders/"/>
    <updated>2013-04-09T21:05:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/advanced-linkers-and-loaders</id>
    <content type="html"><![CDATA[<p>应用开发程序员面向的是软件用户;系统程序员面向的是程序员。<br/>
应用程序使用OS提供的“抽象”的硬件——应用程序接口使用实际的硬件——用来计算的CPU，用来计时的计时器，用来输入的键盘、触摸屏、鼠标、麦克风，用来显示屏幕，用来发声的扬声器,用来保存数据的硬盘，用来和他人通信的网络等等。如果没有操作系统、没有开发工具链，那么应用的开发将回归到“原始社会”。</p>

<h2>OS存在于每一个程序之中</h2>

<p>也许你和我一样，都有一个疑问：自己编写的程序编译之后就能运行了，完全没有感觉到操作系统的存在，告诉自己操作系统只是提供了应用程序运行的平台，如同自己制作的蛋糕拿到市场售卖一般。<br/>
其实，你错了。<strong>操作系统存在于每一个程序之中。</strong><br/>
参考 <a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory">Anatomy of a Program in Memory</a> 的图示</p>

<p><img src="http://liuyix.org/images/kernelUserMemorySplit.png" alt="虚拟空间的分布" /></p>

<p>每一个操作系统上运行的原生程序，在它的虚拟内存中都有1G~2G是不属于自己的，即所谓的“kernel space”</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress修改记录]]></title>
    <link href="http://liuyix.org/blog/2013/my-customize-octopress/"/>
    <updated>2013-03-08T22:27:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/my-customize-octopress</id>
    <content type="html"><![CDATA[<p>&lt;&mdash;more&mdash;></p>

<h3>Octopress</h3>

<p>Reference: <a href="http://blog.zerosharp.com/clone-your-octopress-to-blog-from-two-places/">Clone Your Octopress to Blog From Two Places</a></p>

<p><code>$octopress</code> 代表的是 <code>git clone -b source git@github.com:username/username.github.com.git octopress</code></p>

<p>octopress有2个branch—— <code>source</code> 和 <code>master</code></p>

<p><code>master</code> 是jekyll生成后的静态网站源码，<strong>位置在_deploy目录</strong><br/>
<code>source</code> 是 octopress源码，是<em>octopress</em>根目录</p>

<h4>Blog流程</h4>

<p><code>cd $octopress &amp;&amp; rake generate</code></p>

<ol>
<li>更新octopress源码(目的是要保存markdown源文件)

<ul>
<li><code>git add &lt;modified file&gt;</code></li>
<li><code>git commit -am 'some comment'</code></li>
<li>git push origin <strong>source</strong></li>
</ul>
</li>
<li>生成后的网站源码部署

<ul>
<li><code>rake deploy</code></li>
</ul>
</li>
</ol>


<h3>多个电脑上编写octopress博客</h3>

<p>可能很多人会像我一样有这样的需求：工作地点和家里都想要更新下自己的blog，还有有时会在自己的台式机和笔记本上更新blog，这时你就会遇到我现在的问题： <em>怎么在多个电脑上部署octopress环境</em></p>

<h3>表格boarder的修复</h3>

<p>参考: <a href="" title="http://programus.github.com/blog/2012/03/07/add-table-data-css-for-octopress/">链接</a><br/>
只是作者修改的有点麻烦，我只是把data-table.css粘贴到了 <code>sass/custom/_styles.scss</code> 里面了就出效果了。</p>

<h3>markdown interpreter换成了kramdown</h3>

<p>因为默认的不支持footnote，所以直接换成了<a href="http://kramdown.rubyforge.org">kramdown</a></p>

<h4>Update 2013-07-14</h4>

<p>octopress升级到了2.0, 新的<code>rdiscount</code>支持了footnote特性，因此又换回了<code>rdiscount</code></p>

<h3>404 page</h3>

<p>在source下面建立404.html</p>

<h3>自定义sidebar</h3>

<p>这个教程里就有</p>

<h3>category-list</h3>

<p>TODO</p>

<h3>stylesheet小幅改动</h3>

<h4>awkward ul ol</h4>

<p><a href="https://github.com/imathis/octopress/issues/417">issue417</a>
在 <code>sass/custom/_styles.scss</code> 里修改</p>

<h4>footnote</h4>

<p>一个插件<a href="https://github.com/fmcypriano/footnote-octopress">octopress-footnote</a>,只是个人试用效果不好，遂将js部分去掉了，配合  <a href="http://kramdown.rubyforge.org">kramdown</a> 正好适合</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[期待 Octopress 2.1]]></title>
    <link href="http://liuyix.org/blog/2013/expecting-octopress-2-dot-1/"/>
    <updated>2013-03-08T00:11:00+08:00</updated>
    <id>http://liuyix.org/blog/2013/expecting-octopress-2-dot-1</id>
    <content type="html"><![CDATA[<p>想给Octopress添加几个新功能,想目录的自动生成和点击图片的弹出效果。</p>

<p>搜索了一番，发现有现成的解决方案，不过稍微显得繁琐，原因之一是要手动集成jQuery，许多有趣的功能都依赖于这个强大的js库，纳闷为什么作者没有支持，搜索之后发现很早之前就有人提出这个<a href="https://github.com/imathis/octopress/issues/637#issuecomment-6565847">疑问</a>了，作者给予了回答，大意是太臃肿没必要，然社区群众们呼声很高，Octopress计划在2.1版本中支持jQuery!</p>

<blockquote><p>&#8230;Eventually I decided to add jQuery because that is what the community wants and it makes it easier for folks to work with javascript on Octopress. &#8230;</p><footer><strong>imathis, author of Octopress</strong> <cite><a href='https://github.com/imathis/octopress/issues/637#issuecomment-6565847'>github.com/imathis/octopress/&hellip;</a></cite></footer></blockquote>


<p>很期待新版本的Octopress!!</p>
]]></content>
  </entry>
  
</feed>
